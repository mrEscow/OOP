#pragma once


//--------------------------------------------------------------------------------------------------------------------------------------
//	Начиная с этого урока, будем с использованием полученных знаний по ООП создавать игру Blackjack.
//	Суть проста : раздаются карты, за каждую из которых начисляются очки.
//	Игрок пытается заработать 21 очко, не больше.За каждую карту с числом дается столько очков, сколько на ней указано.
//	За туз — либо 1 очко, либо 11 (что больше подходит игроку), а за валета, даму и короля — по 10 очков.
//	Компьютер выступает дилером и играет против группы от одного до семи игроков.
//	В начале кона все участники, включая дилера, получают две карты.
//	Игроки могут видеть все свои карты, а также сумму очков.Однако одна из карт дилера скрыта на протяжении всего кона.
//	Далее каждый игрок может брать дополнительные карты.
//	Если сумма очков у него превысит 21, он проигрывает.
//	Когда все игроки получили возможность набрать дополнительные карты, дилер открывает скрытую карту.
//	Далее он обязан брать новые карты до тех пор, пока сумма его очков не превышает 16. 
//	Если у дилера перебор, все игроки, не имеющие перебора, побеждают.
//	В противном случае сумма очков каждого из оставшихся игроков сравнивается с суммой очков дилера.
//	Игрок побеждает, если сумма его очков больше, чем у дилера.В противном случае — проигрывает.
//	Если суммы очков игрока и дилера одинаковы, засчитывается ничья.
//--------------------------------------------------------------------------------------------------------------------------------------


//---------------------------------------
//  Создание классов для игры Blackjack:
//---------------------------------------


//--------------------------------------------------------------------------------------------------------------------------------------
//	Создать класс Card, описывающий карту в игре БлэкДжек.
//	У этого класса должно быть три поля : масть, значение карты и положение карты(вверх лицом или рубашкой).
//	Сделать поля масть и значение карты типом перечисления(enum).Положение карты - тип bool.
//	Также в этом классе должно быть два метода :
//	метод Flip(), который переворачивает карту, т.е.если она была рубашкой вверх, то он ее поворачивает лицом вверх, и наоборот.
//	метод GetValue(), который возвращает значение карты, пока можно считать, что туз = 1.
//--------------------------------------------------------------------------------------------------------------------------------------



class Card {
public:
	enum Suit { Hearts, spades, diamonds, clubs } ;
	enum Rank {
		ace = 1,
		deuce, three, four, five, six, seven, eight, nine, ten,
		jack = 10,
		queen = 10,
		king = 10
	} ;

	
private:
	Suit m_Suit;
	Rank m_Rank;
	bool m_isFaceUp;

public:
	Card(Rank rank, Suit suit, bool ifu) : m_Rank(rank), m_Suit(suit), m_isFaceUp(ifu) {}
	void Flip() {
		m_isFaceUp = !m_isFaceUp;
	}

	int GetValue() {

		int value = 0;
		if (m_isFaceUp) {
			value = m_Rank;
		}
		return value;
	}
};

//---------------------------------------------------------------------------------------------------------------------------------------------
//	Реализовать класс Hand, который представляет собой коллекцию карт.
//	В классе будет одно поле : вектор указателей карт(удобно использовать вектор, 
//	т.к.это по сути динамический массив, а тип его элементов должен быть - указатель на объекты класса Card).
//	Также в классе Hand должно быть 3 метода :
//	метод Add, который добавляет в коллекцию карт новую карту, 
//	соответственно он принимает в качестве параметра указатель на новую карту
//	метод Clear, который очищает руку от карт
//	метод GetValue, который возвращает сумму очков карт руки(здесь предусмотреть возможность того, что туз может быть равен 11).
//---------------------------------------------------------------------------------------------------------------------------------------------

class Hand {
protected:
	vector<Card*> m_Cards;

public:
	Hand() { m_Cards.reserve(7); }
	
	virtual ~Hand(); 


	void Add(Card* pCard) {
		m_Cards.push_back(pCard);
	}

	void Clear() {
		vector<Card*>::iterator iter = m_Cards.begin();
		for (iter = m_Cards.begin(); iter != m_Cards.end(); ++iter)
		{
			delete* iter;
			*iter = 0;
		}
		m_Cards.clear();

	}

	int GetTotal() const {
		if (m_Cards.empty()) return 0;
		if (m_Cards[0]->GetValue() == 0) return 0;
		int sum{ 0 };
		for (auto card : m_Cards) 
			sum += card->GetValue();
		bool containsAce = false;
		for (auto card : m_Cards)
			if (card->GetValue() == Card::ace)
				containsAce = true;
		if (containsAce && sum <= 11)		
			sum += 10;
		
			
		return sum;
	}
};


Hand::~Hand() { Clear(); }

//------------------------------------------------------------------------------------------------------------------------
//	Согласно иерархии классов, которая представлена в методичке к уроку 3, от класса Hand наследует класс GenericPlayer, 
//	который обобщенно представляет игрока, ведь у нас будет два типа игроков - человек и компьютер.
//	Создать класс GenericPlayer, в который добавить поле name - имя игрока.Также добавить 3 метода:
//	IsHitting() - чисто виртуальная функция, возвращает информацию, нужна ли игроку еще одна карта.
//	IsBoosted() - возвращает bool значение, есть ли у игрока перебор
//	Bust() - выводит на экран имя игрока и объявляет, что у него перебор.
//------------------------------------------------------------------------------------------------------------------------

class GenericPlayer : protected Hand{
private:
	string m_name;
public:
	GenericPlayer(string name) : m_name(name) {}

	virtual bool IsHitting() = 0;

	bool IsBoosted() {
		if (GetTotal() > 21)
			return true;
		else
			return false;
	}
	void Bust() {
		cout << m_name << " has too many points!" << endl;
	}

};

//------------------------------------------------------------------------------------------------------------------------
//	Реализовать класс Player, который наследует от класса GenericPlayer.У этого класса будет 4 метода:
//	virtual bool IsHitting() const - реализация чисто виртуальной функции базового класса.
//	Метод спрашивает у пользователя, нужна ли ему еще одна карта и возвращает ответ пользователя в виде true или false.
//	void Win() const - выводит на экран имя игрока и сообщение, что он выиграл.
//	void Lose() const - выводит на экран имя игрока и сообщение, что он проиграл.
//	void Push() const - выводит на экран имя игрока и сообщение, что он сыграл вничью.
//------------------------------------------------------------------------------------------------------------------------

class Player {

};

//------------------------------------------------------------------------------------------------------------------------
//	Реализовать класс House, который представляет дилера.Этот класс наследует от класса GenericPlayer.
//	У него есть 2 метода:
//	virtual bool IsHitting() const - метод указывает, нужна ли дилеру еще одна карта.
//	Если у дилера не больше 16 очков, то он берет еще одну карту.
//	void FlipFirstCard() - метод переворачивает первую карту дилера.
//------------------------------------------------------------------------------------------------------------------------

class House {

};

class Deck {

};

class Game {
public:
	Game(vector<string> names) {

	}

	void Play() {

	}
};

//--------------------------------------------------------------------------------------------------------------------------------------
//	Написать перегрузку оператора вывода для класса Card.
//	Если карта перевернута рубашкой вверх(мы ее не видим), вывести ХХ, если мы ее видим, вывести масть и номинал карты.
//	Также для класса GenericPlayer написать перегрузку оператора вывода, 
//	который должен отображать имя игрока и его карты, а также общую сумму очков его карт.
//--------------------------------------------------------------------------------------------------------------------------------------

void Blackjack() {
	cout << "\t\tWelcome to Blackjack!\n\n";

	int numPlayers = 0;
	while (numPlayers < 1 || numPlayers > 7)
	{
		cout << "How many players? (1 - 7): ";
		//cin >> numPlayers;
		numPlayers = 1;
	}

	vector<string> names;
	string name;
	for (int i = 0; i < numPlayers; ++i)
	{
		cout << "Enter player name: ";
		cin >> name;
		names.push_back(name);
	}
	cout << endl;

	// ������� ����

	Game aGame(names);
	char again = 'y';
	while (again != 'n' && again != 'N')
	{
		aGame.Play();
		cout << "\nDo you want to play again? (Y/N): ";
		//cin >> again;
		again = 'n';
	}


}