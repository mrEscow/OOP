#pragma once

// МЕТОДИЧКА
// ------------------


// УРОК №1
//--------


/*
Основные понятия ООП.Инкапсуляция

История и причины возникновения ООП.
Классы и объекты.Методы классов.Инкапсуляция данных и методы доступа.
Средства ограничения доступа.Список инициализации членов класса.
Конструкторы и деструкторы.

Введение в ООП
Классы и объекты
Методы и свойства класса
Спецификаторы доступа public и private
Инкапсуляция
Set - и get - функции
Конструкторы
Список инициализации членов класса
Инициализация членов класса
Деструкторы
Статические переменные - члены класса
Практическое задание
Дополнительные материалы
Используемая литература

Введение в ООП
Объектно - ориентированное программирование — это парадигма программирования, основные концепции которой — понятия объектов и классов.
Ранее вы изучали процедурное программирование, подразумевающее простое последовательное выполнение набора команд.
В ООП все команды также выполняются последовательно, но есть существенное отличие в подходе к архитектуре : программист рассматривает все составные части программы как объекты со свойствами и поведением.
ООП позволяет создавать объекты, которые объединяют несколько разнотипных данных, их свойства и функции.
Чтобы понять концепцию ООП, обратимся к реальной жизни.Вокруг нас находятся объекты : магазины, автомобили, книги, люди.Все они имеют два основных компонента :
список свойств(цвет, размер, вес, форма и другие);
список поведений(делать что - то, открывать и т.д.).
В программировании мы не ориентируемся на написание функций, а сосредотачиваемся на определении объектов, которые имеют поля(свойства) и методы(виды поведения).
Основные причины популярности ООП :
повышение производительности и надежности программ;
создание больших блоков программного кода, пригодных для многократного использования;
упрощение написания и понимания кода.
Принципы ООП не заменяют традиционные методы программирования, а дополняют их.
Основными концепциями ООП являются абстракция, инкапсуляция, наследование и полиморфизм — рассмотрим их на ближайших уроках.
Классы и объекты
Для решения относительно простых задач язык С++ предоставляет ряд примитивных типов данных(int, double, char и другие).Для более сложных их может не хватать, поэтому С++ позволяет создавать пользовательские типы данных — например, перечисления(enum) и структуры(struct).
В следующем коде создается структура для хранения даты :
struct DateStruct
{
    int day;
    int month;
    int year;
};


Создадим перечисления для типа данных, хранящего дни недели :
enum days_of_week { Sun, Mon, Tue, Wed, Thu, Fri, Sat };


Перечисления и структуры — это средства традиционного подхода к программированию, поскольку с их помощью можно только хранить данные.Чтобы с ними можно было работать, необходимо создавать отдельные функции.Для вывода текущей даты напишем соответствующую функцию — вот полный код программы :
#include <iostream>
struct DateStruct
{
    int day;
    int month;
    int year;
} today = { 12, 12, 2018 };

void print(DateStruct& date)
{
    std::cout << date.day << "/" << date.month << "/" << date.year;
}

int main()
{
    today.day = 18; // используем оператор выбора члена для выбора члена структуры
    print(today);

    return 0;
}


Результат выполнения программы : 18 / 12 / 2018.
В парадигме ООП типы данных могут содержать не только данные, но и функции для их обработки.Чтобы определить такой тип данных, используется ключевое слово class.Структуры и классы по своему строению очень похожи, однако у классов больше возможностей.Фактически, следующая структура и класс идентичны :
struct DateStruct
{
    int day;
    int month;
    int year;
};

class DateClass
{
public:
    int m_day;
    int m_month;
    int m_year;
};


Единственное отличие — наличие ключевого слова public, о котором мы поговорим чуть позже.
Объявление класса, как и структуры, не приводит к выделению памяти до тех пор, пока мы не создадим переменную этого типа.Такая переменная называется экземпляром класса или объектом.Следующий фрагмент создает объект класса :
DateClass today{ 12, 11, 2018 }; // объявляем переменную класса DateClass


Для объекта today уже будет выделена память.
Структуры и классы выступают шаблонами, по которым может быть создано несколько объектов.В этом и заключается их главное достоинство — формирование единообразных данных, с которыми можно одинаковым образом работать.
Методы и свойства класса
Переменные, объявленные внутри класса, называются свойствами или переменными - членами.Помимо этого класс может содержать функции : методы или функции - члены.Методы могут быть определены как внутри класса, так и вне него.Программа объявления метода вывода даты, объявленного внутри класса :
class DateClass
{
public:
    int m_day;
    int m_month;
    int m_year;

    void printDate() // определяем функцию-член
    {
        std::cout << m_day << "/" << m_month << "/" << m_year;
    }
    void printYear();
};

// определяем функцию-член вне класса
void DateClass::printYear()
{
    std::cout << m_year << " year";
}



К методам и свойствам класса обращаются с помощью оператора «точка»(.) :
#include <iostream>

    class DateClass
{
public:
    int m_day;
    int m_month;
    int m_year;

    void print()
    {
        std::cout << m_day << "/" << m_month << "/" << m_year;
    }
};

int main()
{
    DateClass today{ 12, 12, 2018 };

    today.m_day = 18;
    today.print(); // используем оператор (.) для вызова метода объекта today класса DateClass

    return 0;
}

Результат выполнения программы : 18 / 12 / 2018.
Вызов функций - членов должен быть связан с объектом класса.Так компилятор может понять, для какого объекта вызывается функция.В определении самой функции мы не указываем, какому объекту принадлежат переменные.В данном примере мы просто обратились к членам - переменным с помощью строчки :
std::cout << m_day << "/" << m_month << "/" << m_year;

Такая запись возможна потому, что компилятор автоматически интерпретирует m_day как today.m_day и т.д.Связанный объект неявно передается функции - члену, поэтому такой объект называется неявным объектом.

Спецификаторы доступа public и private
Рассмотрим следующую программу, в которой нет ошибки :
struct DateStruct // члены структуры являются открытыми по умолчанию
{
    int day; // открыто по умолчанию, доступ имеет любой объект
    int month; // открыто по умолчанию, доступ имеет любой объект
    int year; // открыто по умолчанию, доступ имеет любой объект
};

int main()
{
    DateStruct date;
    date.day = 12;
    date.month = 11;
    date.year = 2018;

    return 0;
}

Данные члены структуры — открытые, или публичные(public - члены).К ним можно получить доступ извне этой структуры.
Теперь рассмотрим следующий код :
class DateClass // члены класса являются закрытыми по умолчанию
{
    int m_day; // закрыто по умолчанию, доступ имеют только другие члены класса
    int m_month; // закрыто по умолчанию, доступ имеют только другие члены класса
    int m_year; // закрыто по умолчанию, доступ имеют только другие члены класса
};

int main()
{
    DateClass date;
    date.m_day = 12; // ошибка
    date.m_month = 11; // ошибка
    date.m_year = 2018; // ошибка

    return 0;
}


Компилятор сообщает об ошибках, так как переменные класса являются закрытыми по умолчанию.Члены private — это члены класса, которые не могут быть изменены извне, и доступ к которым возможен только для других членов класса.

Хотя по умолчанию члены класса являются private, мы можем сделать их открытыми :
class DateClass
{
public: // обратите внимание, ключевое слово public и двоеточие
    int m_day; // открыто, доступ имеет любой объект
    int m_month; // открыто, доступ имеет любой объект
    int m_year; // открыто, доступ имеет любой объект
};

int main()
{
    DateClass date;
    date.m_day = 12; // ок, так как m_day имеет спецификатор доступа public
    date.m_month = 11;  // ок, так как m_month имеет спецификатор доступа public
    date.m_year = 2018;  // ок, так как m_year имеет спецификатор доступа public

    return 0;
}


Ключевое слово public является спецификатором доступа.В С++ есть три уровня доступа : public, private, protected.Спецификаторы доступа указывают, кто имеет доступ к членам класса.Спецификатор доступа protected (защищенный)рассмотрим далее.


В классе можно использовать несколько спецификаторов доступа.Как правило, для переменных - членов устанавливается доступ private, а для функций - членов — public.Порядок написания не имеет значения.
#include <iostream>

class DateClass // члены класса являются закрытыми по умолчанию
{
private:
    int m_day; // закрыто по умолчанию, доступ имеют только другие члены класса
    int m_month; // закрыто по умолчанию, доступ имеют только другие члены класса
    int m_year; // закрыто по умолчанию, доступ имеют только другие члены класса

public:
    void setDate(int day, int month, int year) // открыто, доступ имеет любой объект
    {
        // метод setDate() имеет доступ к закрытым членам класса, так как сам является членом класса
        m_day = day;
        m_month = month;
        m_year = year;
    }

    void print() // открыто, доступ имеет любой объект
    {
        std::cout << m_day << "/" << m_month << "/" << m_year;
    }
};

int main()
{
    DateClass date;
    date.setDate(12, 12, 2018); // ок, так как setDate() имеет спецификатор доступа public
    date.print(); // ок, так как print() имеет спецификатор доступа public

    return 0;
}

Мы не получим напрямую доступ к переменным класса, но можем через public - методы.Это основной механизм, который позволяет скрыть одно и открыть другое.

Следует отметить, что спецификаторы доступа работают на основе класса, то есть public - методы могут работать с private - переменными как данного объекта, так и любого другого :
#include <iostream>

class DateClass // члены класса являются закрытыми по умолчанию
{
private:  // данный спецификатор можно не указывать
    int m_day; // закрыто по умолчанию, доступ имеют только другие члены класса
    int m_month; // закрыто по умолчанию, доступ имеют только другие члены класса
    int m_year; // закрыто по умолчанию, доступ имеют только другие члены класса

public:
    void setDate(int day, int month, int year)
    {
        m_day = day;
        m_month = month;
        m_year = year;
    }
    void print()
    {
        std::cout << m_day << "/" << m_month << "/" << m_year;
    }
    // Обратите внимание на этот дополнительный метод
    void copyFrom(const DateClass& b)
    {
        // Мы имеем прямой доступ к закрытым членам объекта b
        m_day = b.m_day;
        m_month = b.m_month;
        m_year = b.m_year;
    }
};

int main()
{
    DateClass date;
    date.setDate(12, 12, 2018); // ок, так как setDate() имеет спецификатор доступа public

    DateClass copy;
    copy.copyFrom(date); // ок, так как copyFrom() имеет спецификатор доступа public
    copy.print();

    return 0;
}

Функция copyFrom() имеет доступ к private - членам класса m_day, m_month, m_year — так как private - членам класса имеют доступ только функции, принадлежащие этому классу.Это означает, что она может напрямую обращаться как к закрытым членам неявного объекта, так и к членам объекта b(другого).

Инкапсуляция
Инкапсуляция(сокрытие информации) — это процесс скрытого хранения деталей реализации объекта.В С++ инкапсуляция реализована с помощью спецификаторов доступа.Инкапсулированные классы проще в применении и уменьшают сложность программ.Один и тот же класс можно использовать в разных программах, при этом не заботиться о том, как устроен класс изнутри : достаточно просто знать его методы.Также инкапсуляция защищает ваши данные и предотвращает неправильное использование.Рассмотрим класс с public - переменной - массивом :
    class IntArray
{
public:
    int m_array[10];
};


Если бы пользователи напрямую обращались к массиву, могли бы использовать недопустимый индекс :
int main()
{
    IntArray array;
    array.m_array[16] = 2; // некорректный индекс
}


Но если мы сделаем массив закрытым, сможем заставить пользователя вызывать функцию, которая первым делом проверяет корректность индекса :
class IntArray
{
private:
    int m_array[10]; // пользователь не имеет прямой доступ к этому члену

public:
    void setValue(int index, int value)
    {
        // Если индекс недействителен, то не делаем ничего
        if (index < 0 || index >= 10)
            return;

        m_array[index] = value;
    }
};

Таким образом защитим программу от ошибок.
Инкапсулированные классы легче изменять и отлаживать, они проще в использовании, позволяют избегать ошибок и уменьшают сложность программы.
Set - и get - функции
В некоторых программах есть необходимость получать и изменять private - значения.Для этого разработчики пишут специальные public - функции для доступа к закрытым значениям.Для получения значения private - переменной(члена класса) используют get - функцию.Чтобы изменить ее значение — set - функцию.
class Date
{
private:
    int m_day;
    int m_month;
    int m_year;

public:
    int getDay() { return m_day; } // get-функция для day
    void setDay(int day) { m_day = day; } // set-функция для day

    int getMonth() { return m_month; } // get-функция для month
    void setMonth(int month) { m_month = month; } // set-функция для month

    const int& getYear() { return m_year; } // get-функция для year,возвращает значение по константной ссылке
    void setYear(int year) { m_year = year; } // set-функция для year
};


Пишите set - и get - функции только для тех классов, для которых это необходимо;
Get - функции должны возвращать значения по значению или по константной ссылке, которая не дает права изменять значение переменной в функции get().Не используйте неконстантные ссылки.Таким образом мы страхуемся от изменения значений.
Конструкторы
Конструктор — это особый тип метода класса, который автоматически вызывается при создании объекта этого класса.Конструкторы обычно используются для инициализации переменных - членов класса соответствующими значениями, которые предоставлены по умолчанию или пользователем.Еще они применяются для выполнения любых шагов настройки, необходимых для используемого класса.
В отличие от обычных методов, для конструкторов есть свои правила :
они всегда должны иметь то же имя, что и класс(учитывается верхний и нижний регистры);
у конструкторов нет типа возврата(даже void’а);
конструкторы вызываются автоматически при создании объекта;
нельзя вызвать конструктор для уже существующего экземпляра.
Конструктор, не имеющий параметров, называется конструктором по умолчанию.Чтобы создать объект с определенными значениями, используется конструктор с параметрами.В одном классе их может быть несколько — главное, чтобы их параметры были уникальными(учитывается количество и тип).Это возможно благодаря перегрузке функций.

#include <iostream>

class Date
{
private:
    int m_day;
    int m_month;
    int m_year;

public:
    void setDay(int day) { m_day = day; }
    int getDay() { return m_day; }
};

int main()
{
    Date date;
    date.setDay(7);
    std::cout << date.getDay() << '\n';
}

Старайтесь создавать хотя бы один конструктор, даже если он будет пустым.
Если один класс содержит другой в качестве переменной - члена, то конструктор внутреннего класса будет вызван раньше конструктора внешнего класса :
#include <iostream>

class Time
{
public:
    Time() { std::cout << "Time\n"; }
};

class Date
{
private:
    Time m_time; // Date содержит Time, как переменную-член

public:
    Date() { std::cout << "Date\n"; }
};

int main()
{
    Date date;
    return 0;
}

Результат выполнения данной программы :
Time
Date
При создании объекта date вызывается конструктор класса Time, а затем конструктор класса Date.В этом есть смысл, так как конструктор Date() может захотеть использовать переменную m_time, поэтому сначала нужно ее инициализировать.
Список инициализации членов класса
Константные типы данных должны быть инициализированы во время объявления.Если это константные переменные - члены, то инициализировать их с помощью конструктора нельзя.Для решения этой проблемы используются списки инициализации членов.Такой список располагается сразу после параметров конструктора и начинается с двоеточия(:), а затем в круглых скобках указывается значение для каждой переменной.Список инициализаторов не заканчивается точкой с запятой.
Пример использования списка инициализаторов членов :
class Date
{
private:
    const int m_day;
    const int m_month;
    const char* m_dayOfWeek; // День недели


public:
    Date(int day, int month, char* dayOfWeek = "mon")
        : m_day(day), m_month(month), m_dayOfWeek(dayOfWeek) // напрямую инициализируем переменные-члены класса
    {
        // Нет необходимости использовать присваивание
    }

    void print()
    {
        std::cout << "Date: " << m_day << ", " << m_month << ", " << m_dayOfWeek;
    }

};

int main()
{
    Date date(3, 5); // day = 3, month = 5, dayOfWeek = “mon” (значение по умолчанию)
    date.print();
    return 0;
}

Результат: Date: 3, 5, mon
Используйте списки инициализации вместо операций присваивания, чтобы инициализировать переменные - члены вашего класса.
Переменные в списке инициализаторов инициализируются не в том порядке, в котором указаны в списке инициализации, а в котором объявлены в классе.
Инициализация членов класса
Если при написании класса с несколькими конструкторами указывать значения по умолчанию всем их членам, появится лишний код(DRY — Don’t Repeat Yourself).В таких случаях переменным - членам класса можно задать значение напрямую.При инициализации переменных через список инициализации членов приоритет будет отдан последнему.
Пример инициализации членов класса :
#include <iostream>

class Rectangle
{
private:
    double m_length = 3.5;
    double m_width = 3.5;

public:
    Rectangle() // конструктор по умолчанию (присваиваются значения по умолчанию выше)
    {
    }

    Rectangle(double length, double width)
        : m_length(length), m_width(width)
    {
        // m_length и m_width инициализируются конструктором (значения по умолчанию выше не используются)
    }

    void print()
    {
        std::cout << "length: " << m_length << " and width: " << m_width << '\n';
    }
};

int main()
{
    Rectangle one;
    one.print();
    Rectangle two(4.5, 5.5);
    two.print();
    return 0;
}

Программа выведет :
length: 3.5 and width : 3.5
length : 4.5 and width : 5.5
Деструкторы
Деструктор — это функция - член, которая выполняется при удалении объекта класса.
Если объект содержит динамически выделенную память, или файл, или базу данных, деструктор может освободить память перед уничтожением объекта.
Как и у конструкторов, у деструкторов есть правила, которые касаются их названий :
деструктор должен иметь то же имя, что и класс, но со знаком «тильда»(~) перед ним;
деструктор не может принимать аргументы(следовательно, не может быть перегружен);
у деструктора нет типа возврата.
Рассмотрим пример программы, содержащей деструктор :
#include <iostream>
#include <cassert>

class Array
{
private:
    int* m_array;
    int m_length;

public:
    Array(int length) // конструктор
    {
        assert(length > 0);

        m_array = new int[length];
        m_length = length;
    }

    ~Array() // деструктор
    {
        // Динамически удаляем массив, который выделили ранее
        delete[] m_array;
    }

    void setValue(int index, int value) { m_array[index] = value; }
    int getValue(int index) { return m_array[index]; }
    int getLength() { return m_length; }
};

int main()
{
    Array arr(15); // выделяем 15 целочисленных значений
    for (int count = 0; count < 15; ++count)
        arr.setValue(count, count + 1);
    std::cout << "The value of element 7 is " << arr.getValue(7);
    return 0;
} // объект arr

Результат выполнения : The value of element 7 is 8
В конце функции main() объект arr выходит из области видимости, что приводит к вызову деструктора и удалению массива.
Обратите внимание, что в данной программе используется оператор assert — это макрос препроцессора, который обрабатывает условное выражение во время выполнения.Если оно истинно, оператор assert ничего не делает.Если же оно ложное, то выводится сообщение об ошибке и программа завершается.Это сообщение содержит ложное условное выражение, а также имя файла с кодом и номером строки с assert.Таким образом можно легко понять, какая была проблема и где она возникла, что очень помогает при отладке программ.
Сам assert реализован в заголовочном файле <cassert> и часто используется для проверки корректности переданных параметров функции и ее возвращаемого значения.
Статические переменные - члены класса
В C++ ключевое слово static используется при создании статических переменных - членов и статических методов.Переменные - члены класса можно сделать статическими, используя ключевое слово static.В отличие от обычных переменных - членов, статические являются общими для всех объектов класса.Рассмотрим следующую программу :
class Rectangle
{
public:
    static int m_square;
};

int Rectangle::m_square = 3;

int main()
{
    Rectangle first;
    Rectangle second;

    std::cout << first.m_square << '\n';
    first.m_square = 4;
    std::cout << second.m_square << '\n';
    return 0;
}


Результат:
3
4
Поскольку m_square — это статическая переменная - член, она является общей для всех объектов класса Rectangle.Следовательно, first.m_square — это та же переменная, что и second.m_square.Программа выше показывает, что к значению, которое мы установили через первый объект, можно получить доступ и через второй.
Хотя вы можете получить доступ к статическим членам через разные объекты класса(как в примере выше), оказывается, статические члены существуют, даже если объекты класса не созданы!Подобно глобальным переменным, они создаются при запуске программы и уничтожаются, когда программа завершает выполнение.
Следовательно, статические члены принадлежат классу, а не его объектам.Поскольку m_square существует независимо от любых объектов класса, то доступ к нему осуществляется напрямую через имя класса и оператор разрешения области видимости(в данном случае — Rectangle::m_square).
Обратите внимание : это определение статического члена не подпадает под действия спецификаторов доступа.Вы можете определить и инициализировать m_square, даже если оно будет private.
Практическое задание
Создать класс Power, который содержит два вещественных числа.Этот класс должен иметь две переменные - члена для хранения этих вещественных чисел.Еще создать два метода : один с именем set, который позволит присваивать значения переменным, второй — calculate, который будет выводить результат возведения первого числа в степень второго числа.Задать значения этих двух чисел по умолчанию.
Написать класс с именем RGBA, который содержит 4 переменные - члена типа std::uint8_t : m_red, m_green, m_blue и m_alpha(#include cstdint для доступа к этому типу).Задать 0 в качестве значения по умолчанию для m_red, m_green, m_blue и 255 для m_alpha.Создать конструктор со списком инициализации членов, который позволит пользователю передавать значения для m_red, m_blue, m_green и m_alpha.Написать функцию print(), которая будет выводить значения переменных - членов.
Написать класс, который реализует функциональность стека.Класс Stack должен иметь :
private - массив целых чисел длиной 10;
private целочисленное значение для отслеживания длины стека;
public - метод с именем reset(), который будет сбрасывать длину и все значения элементов на 0;
public - метод с именем push(), который будет добавлять значение в стек.push() должен возвращать значение false, если массив уже заполнен, и true в противном случае;
public - метод с именем pop() для вытягивания и возврата значения из стека.Если в стеке нет значений, то должно выводиться предупреждение;
public - метод с именем print(), который будет выводить все значения стека.
Код main() :
    int main()
{
    Stack stack;
    stack.reset();
    stack.print();

    stack.push(3);
    stack.push(7);
    stack.push(5);
    stack.print();

    stack.pop();
    stack.print();

    stack.pop();
    stack.pop();
    stack.print();

    return 0;
}


Этот код должен выводить :
()
(3 7 5)
(3 7)
()
Дополнительные материалы
Бьерн Страуструп.Программирование.Принципы и практика использования С++.
Стивен Прата.Язык программирования С++.Лекции и упражнения.
Роберт Лафоре.Объектно - ориентированное программирование в С++.
Используемая литература
Для подготовки данного методического пособия были использованы следующие ресурсы :
Онлайн справочник программиста на C и C++.Инкапсуляция.
Бьерн Страуструп.Программирование.Принципы и практика использования С++.
Ральф Джонсон, Ричард Хелм, Эрих Гамма.Приемы объектно - ориентированного программирования.Паттерны проектирования.
*/



// УРОК №2
//--------



/*
Наследование
Управление доступом к базовому классу. Конструкторы и наследование. Создание многоуровневой иерархии классов. Указатели на производные классы. Простое и множественное наследование.

Константные объекты классов
Определение методов вне класса
Скрытый указатель this
Базовое наследование
Дружественные функции
Дружественные классы
Спецификатор доступа protected
Типы наследования
Указатели и ссылки на производные классы
Множественное наследование
Практическое задание
Дополнительные материалы
Используемая литература



Константные объекты классов
По аналогии с фундаментальными типами данных (int, float, char) объекты классов также могут быть константными. Для таких объектов запрещается изменять переменные-члены, а также вызывать их напрямую (даже если они public). Но есть способ получить значение переменной: использовать константный метод, который также должен быть объявлен в классе (например, константная get-функция-член). Константный метод гарантирует, что объект не будет изменяться. Рассмотрим следующий пример:
class Time
{
public:
    int m_hours;

    Time() { m_hours = 0; }

    void resetHours() { m_hours = 0; }
    void setHours(int value) { m_hours = value; }

    int getHours() const { return m_hours; }
    // ключевое слово const находится после списка параметров, но перед телом функции
};

В данном примере мы можем вызвать метод getHours() через любой константный объект.
Старайтесь делать все методы, которые не изменяют данные объекта, константными.

Если нужно передать внешней функции объект, сделаем это по ссылке, так как по значению будет нерационально. Передадим константную ссылку, чтобы функция случайно не изменила значение своего параметра.
#include <iostream>

class Date
{
private:
    int m_day;
    int m_month;
    int m_year;

public:
    Date(int day, int month, int year)
    {
        setDate(day, month, year);
    }

    void setDate(int day, int month, int year)
    {
        m_day = day;
        m_month = month;
        m_year = year;
    }

    int getDay() const { return m_day; }
    int getMonth() const { return m_month; }
    int getYear() const { return m_year; }
};

// Мы передаем объект date по константной ссылке, чтобы избежать создания копии объекта date
void printDate(const Date &date)
{
    std::cout << date.getDay() << "." << date.getMonth() << "." << date.getYear() << '\n';
}

int main()
{
    Date date(12, 11, 2018);
    printDate(date);

    return 0;
}

В данном примере передаем функции printDate() константный объект. Через него вызываем методы getDay(), getMonth(), getYear(), которые тоже должны быть константными.
Определение методов вне класса
Функции-члены могут быть определены как внутри класса, так и за его пределами. Первый способ определения мы уже рассматривали — поговорим о втором.
Чтобы функцию-член класса определить вне класса, в нем определяют только прототип самой функции, а ее тело — вне класса, используя в качестве префикса имя класса с оператором разрешения области видимости (::).
class Date
{
private:
    int m_day;
    int m_month;
    int m_year;

public:
    Date(int day, int month, int year);

    void SetDate(int day, int month, int year);

    int getDay() { return m_day; }
    int getMonth() { return m_month; }
    int getYear()  { return m_year; }
};

// Конструктор класса Date
Date::Date(int day, int month, int year)
{
    SetDate(day, month, year);
}

// Метод класса Date
void Date::SetDate(int day, int month, int year)
{
    m_day = day;
    m_month = month;
    m_year = year;
}


Скрытый указатель this
Может возникнуть вопрос: как при вызове метода класса C++ отслеживает, какой объект его вызвал? Ответ: C++ использует скрытый указатель this!
Пусть объект date класса Date вызывает метод setDate(): date.setDate(4, 5, 2019). Хотя кажется, что здесь только три аргумента, на самом деле их четыре. Во время компиляции эта строчка будет конвертирована в следующую: setDate(&date, 4, 5, 2019).
Теперь это всего лишь стандартный вызов функции, а объект date теперь передается по адресу в качестве аргумента функции.
Поскольку в вызове функции теперь четыре аргумента, то и метод нужно изменить соответствующим образом — чтобы он их принимал:
void setDate(Date* const this, int day, int month, int year) {
 this->m_day = day;
this->m_month = month;
this->m_year = year; }

При компиляции обычного метода компилятор неявно добавляет к нему параметр this — это скрытый константный указатель, который содержит адрес объекта, который вызывает метод класса.
Еще одна деталь: внутри метода также необходимо обновить все члены класса (функции и переменные), чтобы они ссылались на объект, который вызывает этот метод. Это легко сделать, добавив префикс this-> к каждому из них. Таким образом, в теле функции setDate(), m_day (переменная-член класса) будет конвертирована в this->m_day и так далее. И когда *this указывает на адрес date, то this->m_day будет указывать на date.m_day.
Указатель *this является скрытым параметром, который неявно добавляется к каждому методу класса. В большинстве случаев нам не нужно обращаться к нему напрямую, но при необходимости это можно сделать. Стоит отметить, что this является константным указателем: вы можете изменить значение исходного объекта, но нельзя заставить this указывать на что-то другое.
class Day {
private:
    int day;
public:
    Day(int day) {
        this->day = day;
    }
};

int main() {
    Day(4);
}


Базовое наследование
Идею наследования в С++ легко понять через аналогию с реальной жизнью. Яблоки и груши — это фрукты, и они унаследовали все свойства, которые имеют такие плоды (цвет, размер и подобное). Но и у яблок, и у груш есть индивидуальные свойства.
Вернемся к программированию. Наследование в С++ происходит между классами. Родительский (базовый) класс — это тот, от которого наследуются свойства и методы. Дочерний (производный) класс — это тот, который наследует.
Определим родительский класс Human():
#include <string>

class Human
{
public:
    std::string m_name;
    int m_age;

    Human(std::string name = "", int age = 0)
    : m_name(name), m_age(age)
    {
    }

    std::string getName() const { return m_name; }
    int getAge() const { return m_age; }

};


В нем определены только общие свойства, которые есть у любого человека: имя и возраст.
Теперь определим дочерний класс Employee():
// Employee открыто наследует Human
class Employee : public Human
{
public:
    string m_employer;
    double m_wage;

    Employee(string employer, double wage)
    : m_employer(employer), m_wage(wage)
    { }
};


В этом классе мы добавили еще две переменные-члена, которые являются специфичными для данного класса. При этом переменные класса Human() также являются переменными-членами класса Employee(). Обратите внимание, что тип наследования public (об этом поговорим дальше), а родительский класс указывается через двоеточие.
int main()
{
    // Создаем нового сотрудника
    Employee anton;
    // Присваиваем ему имя (мы можем делать это напрямую, так как m_name является public)
    anton.m_name = "Anton";
    // Выводим имя сотрудника
    std::cout << anton.getName() << '\n';
    // используем метод getName(), который мы унаследовали от класса Human
    return 0;
}

Результат выполнения этого кода: Anton
От одного класса могут наследовать несколько классов: от Human() может наследовать Employee() и другие.
Также можно создавать цепочки наследований: от класса Employee() может наследовать класс Supervisor(). Для него родительским классом будет Employee().
Построение дочернего класса начинается с самого верхнего родительского класса и заканчивается нижним классом иерархии. По мере построения выполняются и конструкторы: сначала конструктор топового класса, а в конце — дочернего. Деструкторы выполняются в обратном порядке.
Чтобы создать объект дочернего класса, необязательно создавать объект базового. А чтобы передать значения конструктору базового класса, не создавая сам объект, следует вызвать конструктор базового класса с нужными параметрами в списке инициализации производного класса. Пример такого объявления:
#include <string>
using namespace std;
class Human
{
private:
    string m_name;
    int m_age;

public:
    Human(string name = "", int age = 0) : m_name(name), m_age(age )
    { }

    string getName() const { return m_name; }
    int getAge() const { return m_age; }

};
class Employee : public Human
{
private:
    string m_employer;
    double m_wage;
public:
    Employee(string name = "", int age = 0, string employer, double wage)
    : Human(name, age), // вызывается Human(std::string, int) для инициализации членов name и age
m_employer(employer), m_wage(wage)
    { }
    string getEmployer() const { return m_employer; }
    double getWage() const { return m_wage; }
};

Преимущество наследования в том, что не надо переопределять информацию из родительских классов в дочерние. Это эффективный способ разработки сложных программ. Например, все производные классы наследуют изменения родительского.

Дружественные функции
Дружественные функции имеют доступ к закрытым членам класса. Это могут  быть как обычные функции, так и методы других классов. Дружественные функции объявляются с помощью ключевого слова friend перед прототипом функции в том классе, дружественной для которого вы хотите ее сделать. Тело функции может быть объявлено в любом другом месте программы. Рассмотрим пример:
class Cat
{
private:
    int m_age;
    // Делаем функцию resetAge() дружественной классу Cat
    friend void resetAge(Cat &cat);
};

// resetAge() теперь является другом класса Cat
void resetAge(Cat &cat)
{
    // И мы имеем доступ к закрытым членам объектов класса Cat
    cat.m_age = 0;
}

int main()
{
    Cat Frisky;
    resetAge(Frisky);
    return 0;
}

Отметим, что в качестве параметра функция resetAge() принимает объект класса Cat.
Можно создавать дружественные функции для нескольких классов.
class Cat; //это прототип, сам класс определяем позже

class Dog
{
// ...
    friend void getAge(const Cat &cat, const Dog &dog);
};

class Cat
{
// ...
    friend void getAge(const Cat &cat, const Dog &dog);
};

void getAge(const Cat &cat, const Dog &dog)
{
// ...
}

В данном случае необходимо в самом начале объявить прототип класса Cat. Без этой строчки компилятор выдаст ошибку, так как упоминание об этом классе есть в дружественной функции. Обратите внимание, что параметры в функцию передаются по ссылке. Это необходимо для того, чтобы не создавались копии объектов, так как этот процесс может быть неэффективным. Const обеспечивает, что данные классы не будут изменяться в функции.
Дружественные классы
Один класс можно сделать дружественным другому. Это откроет всем членам первого класса доступ к закрытым членам второго:
#include <iostream>
using namespace std;

class Dog
{
private:
    int m_age;
public:
    Dog (int age) : m_age(age)
    { }
    // Делаем класс Cat другом классу Dog
    friend class Cat;
};

class Cat
{
private:
    int m_age;
public:
    Cat (int age) : m_age(age)
    { }
    bool compareAge(Cat &cat, Dog &dog) {
        // у нас есть доступ к private переменным класса Dog
        return dog.m_age<cat.m_age;
    }
};

int main() {
    Cat Frisky(4);
    Dog Spike(3);
    if (Frisky.compareAge(Frisky, Spike))
        cout << "Кот старше собаки";
    else
        cout << "Кот не старше собаки";
    return 0;
}

Поскольку класс Cat — другом класса Dog, то любой из членов Cat имеет доступ к private-членам Dog.
Обратите внимание: Cat — друг Dog, но Cat не имеет прямого доступа к указателю this * объектов Dog. И это не означает, что Dog также является другом Cat. Если хотите сделать оба класса дружественными, то они должны указать друг друга в таком качестве.

Спецификатор доступа protected
Спецификатор protected открывает доступ к члену класса для дружественных функций и дочерних классов.
class Parent
{
public:
    int m_public;           // доступ к этому члену открыт для всех объектов
private:
    int m_private;          // доступ к этому члену открыт только для других членов класса Parent и для дружественных классов/функций (но не для дочерних классов)
protected:
    int m_protected;        // доступ к этому члену открыт для других членов класса Parent, дружественных классов/функций, дочерних классов
};

class Child : public Parent
{
public:
    Child()
    {
        m_public = 1;     // разрешено: доступ к открытым членам родительского класса из дочернего класса
        m_private = 2;    // запрещено: доступ к закрытым членам родительского класса из дочернего класса
        m_protected = 3;  // разрешено: доступ к защищенным членам родительского класса из дочернего класса
    }
};

int main()
{
    Child child;
    child.m_public = 1; // разрешено: доступ к открытым членам класса извне
    child.m_private = 2; // запрещено: доступ к закрытым членам класса извне
    child.m_protected = 3; // запрещено: доступ к защищенным членам класса извне
}

Спецификатор доступа protected имеет смысл применять, только если количество дочерних классов невелико. Если в члене protected появятся изменения, их придется вносить как в родительский класс, так и во все дочерние.

Типы наследования
Тип наследования определяется с помощью спецификатора доступа, который указывается возле наследуемого класса. По умолчанию тип наследования определяется как private.
Всего есть 9 комбинаций наследования для членов класса:
Спецификатор доступа в родительском классе
Спецификатор доступа при наследовании типа public в дочернем классе
Спецификатор доступа при наследовании типа private в дочернем классе
Спецификатор доступа при наследовании типа protected в дочернем классе
Public
Public
Private
Protected
Private
Недоступен
Недоступен
Недоступен
Protected
Protected
Private
Protected



class Parent
{
public:
    int m_public;
private:
    int m_private;
protected:
    int m_protected;
};

class Child: public Parent   // открытое наследование
{
    // Открытое наследование означает, что:
    // члены public остаются public в дочернем классе
    // члены protected остаются protected в дочернем классе
    // члены private остаются недоступными в дочернем классе
public:
    Child()
    {
        m_public = 1;     // разрешено: доступ к m_public открыт
        m_private = 2;    // запрещено: доступ к m_private в дочернем классе из родительского класса закрыт
        m_protected = 3;  // разрешено: доступ к m_protected в дочернем классе из родительского класса открыт
    }
};

int main()
{
    Parent parent;
    parent.m_public = 1;    // разрешено: m_public доступен извне через родительский класс
    parent.m_private = 2;   // запрещено: m_private недоступен извне через родительский класс
    parent.m_protected = 3; // запрещено: m_protected недоступен извне через родительский класс

    Child pub;
    child.m_public = 1;     // разрешено: m_public доступен извне через дочерний класс
    child.m_private = 2; // запрещено: m_private недоступен извне через дочерний класс
    child.m_protected = 3; // запрещено: m_protected недоступен извне через дочерний класс
}


Самое распространенное наследование — открытое, оно же — самое легкое. Когда дочерний класс открыто наследует родительский, унаследованные члены public остаются public, protected — protected, а унаследованные члены private по-прежнему недоступны для дочернего класса. Используйте именно этот тип наследования, если нет острой необходимости делать иначе.
class Parent
{
public:
    int m_public;
private:
    int m_private;
protected:
    int m_protected;
};

class Child: private Parent  // закрытое наследование
{
    // Закрытое наследование означает, что:
    // члены public становятся private (m_public теперь private) в дочернем классе
    // члены protected становятся private (m_protected теперь private) в дочернем классе
    // члены private остаются недоступными (m_private недоступен) в дочернем классе
public:
    Child()
    {
        m_public = 1;        // разрешено: m_public теперь private в Priv
        m_private = 2;       // запрещено: дочерние классы не имеют доступ к закрытым членам родительского класса
        m_protected = 3;     // разрешено: m_protected теперь private в Priv
    }
};

int main()
{
    Parent parent;
    parent.m_public = 1;     // разрешено: m_public доступен извне через родительский класс
    parent.m_private = 2;    // запрещено: m_private недоступен извне через родительский класс
    parent.m_protected = 3;  // запрещено: m_protected недоступен извне через родительский класс

    Child child;
    child.m_public = 1;     // запрещено: m_public недоступен извне через дочерний класс
    child.m_private = 2;    // запрещено: m_private недоступен извне через дочерний класс
    child.m_protected = 3;  // запрещено: m_protected недоступен извне через дочерний класс
}


При закрытом наследовании все члены родительского класса наследуются как закрытые и поэтому невозможно к ним обратиться извне дочернего класса. Данный тип наследования полезен, когда дочерний класс слабо связан с родительским и мы не хотим, чтобы открытые члены были доступны через объекты дочернего класса.
class Parent
{
public:
    int m_public;
private:
    int m_private;
protected:
    int m_protected;
};

class Child: private Parent  // закрытое наследование
{
    // Закрытое наследование означает, что:
    // члены public становятся private (m_public теперь private) в дочернем классе
    // члены protected становятся private (m_protected теперь private) в дочернем классе
    // члены private остаются недоступными (m_private недоступен) в дочернем классе
public:
    Child()
    {
        m_public = 1;    // разрешено: m_public теперь private в Priv
        m_private = 2;   // запрещено: дочерние классы не имеют доступ к закрытым членам родительского класса
        m_protected = 3; // разрешено: m_protected теперь private в Priv
    }
};

int main()
{
    Parent parent;
    parent.m_public = 1;    // разрешено: m_public доступен извне через родительский класс
    parent.m_private = 2;   // запрещено: m_private недоступен извне через родительский класс
    parent.m_protected = 3; // запрещено: m_protected недоступен извне через родительский класс

    Child child;
    child.m_public = 1; // запрещено: m_public недоступен извне через дочерний класс
    child.m_private = 2; // запрещено: m_private недоступен извне через дочерний класс
    child.m_protected = 3; // запрещено: m_protected недоступен извне через дочерний класс
}

Тип наследования protected почти никогда не используется. С защищенным наследованием члены public и protected становятся protected, а члены private остаются недоступными.
Указатели и ссылки на производные классы
Если создан указатель на один тип данных, он не сможет указывать на другой тип. Но в ООП указатель на объект базового класса также может указывать на объект производного. Покажем это на примере:
Animal *p_animal;  		 // указатель на объект типа Animal
Animal animal; 		       // объект типа Animal
Dog dog; 			       // объект типа Dog
                               // Следующие присвоения будут безошибочными
p_animal = &animal;   	       // р_animal указывает на объект типа Animal
p_animal = &dog;    		 // р_animal указывает на объект типа Dog, являющийся объектом, порожденным от Animal

В данном случае указатель p_animal может хранить адрес как объекта класса Animal, так и объекта класса Dog.
Но указатель р_animal может получить доступ только к членам класса Dog, которые были унаследованы от класса Animal. К специфичным членам класса Dog указатель не имеет доступа.
В следующем примере показывается использование указателя на базовый класс.

#include <iostream>
#include <string.h>
using namespace std;

class Animal {
protected:
    int m_age;
public:
    void set_age(int age) {m_age=age;}
    void show_age() {cout << m_age << endl; }
};

class Dog: public Animal {
    char m_breed[80];             // кличка собаки
public:
    void set_breed(char *breed) {
        strcpy(m_breed, breed);
    };
    void show_breed () {
        cout << m_breed << endl;
    }
};

int main()
{
    Animal *p_animal;
    Animal animal;
    Dog dog;
    p_animal = &animal;           // адрес объекта базового класса
                                  // доступ к Animal через указатель
    p_animal->set_age(5);
                                  // доступ к Dog через указатель
    p_animal = &dog;
    p_animal->set_age(10);
                                  // показать каждое имя соответствующего объекта
    animal.show_age();
    dog.show_age();
                                 // dog.set_breed("poodle");
                                 //((Dog *)p_animal) ->show_breed();

    cout << "\n";
    return 0;
}


p_animal может указывать на члены класса Animal, а также на члены класса Dog, которые были определены в базовом классе. Вместе с этим нужно помнить, что указатель нельзя использовать для доступа к члену show_breed(), пока не выполнено приведение типов:
((Dog *)p_animal) ->show_breed();

Но такую конструкцию употреблять не рекомендуется, так как это может вызвать дополнительные ошибки в коде.
Множественное наследование
В С++ существует множественное наследование: когда у одного дочернего класса несколько родительских. Например, нужно создать класс Teacher. Этот класс может наследовать от классов Employee и School. Синтаксис множественного наследования:
#include <string>
using namespace std;

class School
{
private:
    int m_number;
        string m_type;
public:
    School(int number, string type) : m_number(number), m_type(type)
    { }
};

class Employee
{
private:
    string m_employer;
    double m_wage;
public:
    Employee(string employer, double wage)
    : m_employer(employer), m_wage(wage)
    { }
};

// класс Teacher открыто наследует свойства классов Human и Employee
class Teacher: public School, public Employee
{
private:
    int m_teachesGrade;
public:
    Teacher(int number, string type, string employer, double wage, int teachesGrade)
    : School(number, type), Employee(employer, wage), m_teachesGrade(teachesGrade)
    { }
};

У класса School есть переменные-члены m_number, m_type. Это то, что есть у любой школы. У класса Employee есть переменные-члены m_employeer, m_wage. Эти свойства присущи любому работнику. Поскольку у учителя есть все свойства школы и работника, то класс Teacher наследует свойства классов School и Employee. Но у педагога есть еще своя квалификация, поэтому в классе Teacher есть переменная-член m_teachesGrade.
Множественное наследование — мощное средство языка С++, но оно же может привести к серьезным проблемам:
Когда дочерний класс пытается вызвать метод, который есть в обоих родительских классах. Компилятор сообщит об ошибке, так как не будет знать, какой из методов вызвать. Эту проблему можно устранить путем явного указания класса, которому принадлежит метод.
Когда один класс наследует от двух классов, которые в свою очередь наследуют от одного и того же родительского класса (алмаз смерти). Проблемы заключаются в неоднозначности вызова методов, а также повторном копировании членов базового класса в дочерний класс.
Множественное наследование запрещено использовать в некоторых языках программирования (Java и C#) для обычных классов, но для интерфейсных такое ограничение снято.
Таким образом, множественное наследование следует применять только в случаях крайней необходимости, если другие решения недоступны или слишком сложны.
Практическое задание
Создать класс Person (человек) с полями: имя, возраст, пол и вес. Определить методы переназначения имени, изменения возраста и веса. Создать производный класс Student (студент), имеющий поле года обучения. Определить методы переназначения и увеличения этого значения. Создать счетчик количества созданных студентов. В функции main() создать несколько студентов. По запросу вывести определенного человека.
Создать классы Apple (яблоко) и Banana (банан), которые наследуют класс Fruit (фрукт). У Fruit есть две переменные-члена: name (имя) и color (цвет). Добавить новый класс GrannySmith, который наследует класс Apple.
int main()
{
    Apple a("red");
    Banana b;
    GrannySmith c;

    std::cout << "My " << a.getName() << " is " << a.getColor() << ".\n";
    std::cout << "My " << b.getName() << " is " << b.getColor() << ".\n";
    std::cout << "My " << c.getName() << " is " << c.getColor() << ".\n";

    return 0;
}


Код, приведенный выше, должен давать следующий результат:

      My apple is red.
My banana is yellow.
My Granny Smith apple is green.


Изучить правила игры в Blackjack. Подумать, как написать данную игру на С++, используя объектно-ориентированное программирование. Сколько будет классов в программе? Какие классы будут базовыми, а какие производными? Продумать реализацию игры с помощью классов и записать результаты.
Дополнительные материалы
Бьерн Страуструп. Программирование. Принципы и практика использования С++.
Стивен Прата. Язык программирования С++. Лекции и упражнения.
Роберт Лафоре. Объектно-ориентированное программирование в С++.
Используемая литература
Для подготовки данного методического пособия были использованы следующие ресурсы:
Наследование классов в C++.
Бьерн Страуструп. Программирование. Принципы и практика использования С++.
Ральф Джонсон, Ричард Хелм, Эрих Гамма. Приемы объектно-ориентированного программирования. Паттерны проектирования.

*/


// УРОК №3
//--------



/*
Виртуальные функции и полиморфизм
Основы виртуальных функций. Чистые виртуальные функции и абстрактные классы. Интерфейсные классы. Раннее и позднее связывание. Перегрузка функций и методов.

Указатели и ссылки при наследовании
Виртуальные функции
Виртуальные деструкторы
Абстрактные классы
Интерфейсные классы
Раннее и позднее связывание
Виртуальный базовый класс
Перегрузка операторов
Перегрузка операторов через дружественные функции
Перегрузка операторов через обычные функции
Перегрузка операторов через методы класса
Перегрузка унарных операторов
Создание классов для игры Blackjack
Практические задания
Дополнительные материалы
Используемая литература


Указатели и ссылки при наследовании
Вспомним, как работают указатели и ссылки. Допустим, есть базовый класс Parent и производный Child:
class Parent
{
protected:
    int m_age;
public:
    Parent(int age) : m_age(age)
    { }
    int getAge() { return m_age; }
};

class Child : public Parent
{
public:
    Child(int age) : Parent(age)
    { }
    int getAge() { return m_age / 2; }




Создадим объект класса Child и обратимся к его членам-функциям:
#include <iostream>
using namespace std;

int main()
{
    Child child(40);
    cout << "child has age " << child.getAge() << '\n';

    Child &rChild = child; // ссылка на объект child
    cout << "rChild has age " << rChild.getAge() << '\n';

    Child *pChild = &child; // указатель на объект child
    cout << "pChild has age " << pChild->getAge() << '\n';

    return 0;
}


Результат выполнения программы:
child has age 20
rChild has age 20
pChild has age 20
Обратите внимание, что при вызове члена-функции через указатель pChild был использован оператор -> (стрелка). Теперь, если мы создадим указатель и ссылку типа Parent на объект child, также сможем вызывать члены-функции объекта child. Но при одном условии: если эти функции будут членами класса Parent.

int main()
{
    Child child(40);
    Parent &rParent = child;
    Parent *pParent = &child;

    cout << "child has age " << child.getAge() << '\n';
    cout << "rParent age " << rParent.getAge() << '\n';
    cout << "pParent age " << pParent->getAge() << '\n';

    return 0;
}


Результат выполнения программы:
child has age 20
rParent age 40
pParent age 40
Через rParent и pParent	можно вызвать только члены базового класса, при этом они не видят члены производного класса. Это проблема, решение которой рассмотрим дальше. Можно было бы отказаться от создания ссылок или указателей типа базового класса и сразу создавать их с типом производного класса. Но у такого подхода есть ряд недостатков. Например, есть несколько дочерних классов (Child1, Child2), и нам необходимо создать функцию writeAge(), которая будет выводить на экран значение члена-функции getAge для любого объекта из этих классов (причем эти члены-функции для каждого класса разные). Параметром функции writeAge() может быть объект любого из дочерних классов, поэтому логичнее сделать этот параметр типа базового класса:
void writeAge(Parent &someChild)
{}


Но мы не получим нужного решения, так как доступ к уникальным членам дочерних классов через ссылку закрыт.
Виртуальные функции
Виртуальная функция — это метод класса, который может быть переопределен в дочерних классах так, что конкретная реализация метода для вызова будет определяться во время исполнения. При использовании виртуальной функции вызывается «самый дочерний» метод — при условии, что имя, тип параметров, тип возврата дочернего метода совпадает с методом родительского класса. Если тип параметров, их количество, тип возврата метода не будет совпадать, то реализуется механизм перегрузки. Для создания виртуальной функции перед ее объявлением нужно указать ключевое слово virtual. С помощью виртуальных функций может быть решена проблема, поставленная в предыдущем разделе.

class Parent
{
protected:
    int m_age;
public:
    Parent(int age) : m_age(age)
    { }
    virtual int getAge() { return m_age; }
};
class Child: public Parent
{
public:
    Child(int age) : Parent(age)
    { }
    int getAge() override
{ return m_age / 2; }
};

void writeAge( Parent &someChild)
{
    cout << "rParent age " << someChild.getAge() << '\n';
}

int main()
{
    Child child(40);
    Parent &rParent = child;
    writeAge(rParent);
    return 0;
}


Результат выполнения программы:
rParent age 20
Так как getAge() является виртуальной функцией, компилятор проверяет, есть ли переопределение этой функции в дочерних классах. Если есть, выполняется именно метод из дочернего класса. Обратите внимание, что переопределенная функция имеет идентификатор override, который используется, чтобы явно указать, что функция должна переопределять виртуальную функцию, объявленную в базовом классе. Идентификатор override помогает избегать ошибок в коде, а также лучше понимать текст программы. Применять данный идентификатор не обязательно, поэтому мы его не будем использовать в дальнейшем.
Если функция объявлена как виртуальная, то и все переопределения функции тоже являются виртуальными, даже если это не указано явно в коде. Обратите внимание, что тип возврата виртуальной функции должен совпадать во всех ее переопределениях. Нельзя вызывать виртуальные функции в теле конструктора или деструктора, так как всегда будет вызываться родительская версия метода.
Иногда бывает необходимо проигнорировать вызов переопределений, созданных виртуальными функциями. Для этого перед вызовом функции следует указать имя класса, которому принадлежит нужная версия метода, с использованием оператора разрешения области видимости (::).
Несмотря на явные преимущества виртуальных функций, повсеместное их использование будет неэффективным, так как обработка и вызов виртуального метода занимает больше времени.
Теперь можем поговорить о еще одном принципе ООП — полиморфизме.
Полиморфизм — это возможность применять одноименные методы с одинаковыми или различными наборами параметров в одном классе или в группе классов, связанных отношениями наследования. Другими словами, полиморфизм позволяет переопределять методы для классов-наследников. Он реализуется с помощью виртуальных функций.
Виртуальные деструкторы
Виртуальные деструкторы работают по тому же принципу, что и виртуальные функции. При вызове деструктора базового класса вначале должны вызываться деструкторы производных классов. Это возможно, если деструктор объявлен как виртуальный. Рассмотрим на примере:
#include <iostream>
using namespace std;
class Parent
{
public:
    virtual ~Parent() // Деструктор виртуальный
    {
        cout << "Calling ~Parent()" << endl;
    }
};

class Child: public Parent
{
private:
    int* m_grades;

public:
    Child(int length)
    {
        m_grades = new int[length];
    }

    ~Child() // Деструктор виртуальный
    {
        delete[] m_grades;
    }
};

int main()
{
    Child *child = new Child(7);
    Parent *parent = child;
    delete parent;

    return 0;
}

Если бы деструкторы были не виртуальными, то при удалении указателя parent вызывался бы только деструктор базового класса. При этом член-переменная m_grades не будет удалена. Объявление деструктора виртуальным исправляет эту проблему.
При наследовании создавайте деструкторы виртуальными.
Абстрактные классы
Встречаются задачи, где не нужно определять виртуальную функции внутри базового класса. В таком случае объявляют чисто виртуальную функцию (или абстрактную функцию). Чтобы ее объявить необходимо написать прототип функции и присвоить ей значение 0. Класс, в котором присутствует чисто виртуальная функция, называется абстрактным. При объявлении абстрактной функции должно выполняться два условия:
нельзя создавать объекты абстрактного класса;
все производные классы должны переопределять все чисто виртуальные функции.
Абстрактные классы — крайне полезный инструмент. Их можно применять для создания указателей и использования преимуществ всех полиморфных способностей. Например:
using namespace std;
class Animal
{
public:
    virtual void say()=0;
};
class Cat: public Animal {
public:
    void say()
    {
        cout << “Meow" << endl;
    }
};
class Dog: public Animal
{
public:
    void say() {
        cout << "Woof" << endl;
    }
};

int main() {
    Cat cat;
    Dog dog;
    Animal *animal1 = &cat;
    Animal *animal2 = &dog;

    animal1 -> say();
    animal2 -> say();
}


В данном примере невозможно создать объект класса Animal. Но используя указатель типа Animal, можно вызывать методы нужных классов.
Интерфейсные классы
Интерфейсные классы не имеют переменных-членов, и все их методы — это чисто виртуальные функции. Любой класс-наследник должен предоставлять свою реализацию виртуальных методов. Интерфейсные классы создаются для конструирования «рабочих» классов.
Использование интерфейсных классов снимает большинство проблем, которые могли бы возникнуть при множественном наследовании. Это связано с отсутствием переменных-членов и определений методов.
Один интерфейсный класс может наследовать от нескольких интерфейсных классов. Таким образом создается многоуровневая направленная иерархия.
Обычные классы могут наследовать не от одного интерфейсного класса, но он должен дать определение всем методам, перечисленным в заголовках родительских классов. Если хотя бы один метод будет не переопределен, то новый класс автоматически становится абстрактным.
Интерфейсным классам принято давать названия, начинающиеся с буквы I. Пример такого класса:
class IErrorLog
{
public:
    virtual bool openLog(const char *filename) = 0;
    virtual bool closeLog() = 0;

    virtual bool writeError(const char *errorMessage) = 0;

    virtual ~IErrorLog() {}; // создаём виртуальный деструктор в случае, если удалим указатель на IErrorLog, то чтобы вызывался соответствующий деструктор дочернего класса
};

Любой класс, который наследует IErrorLog, должен предоставить свою реализацию всех трех методов класса IErrorLog. Вы можете создать дочерний класс с именем FileErrorLog, где openLog() открывает файл на диске, closeLog() закрывает файл, а writeError() записывает сообщение в файл. Можно создать еще один дочерний класс с именем ScreenErrorLog, где openLog() и closeLog() ничего не делают, а writeError() выводит сообщение во всплывающем окне на экран.
Раннее и позднее связывание
Связывание — это процесс, во время которого компилятор сопоставляет  с идентификаторами адреса в памяти. Связывание производится как для переменных, так и для функций. Существует два типа связывания: раннее (статическое) или позднее (динамическое). Рассмотрим их на примере функций.
Ранее связывание означает, что компилятор до выполнения кода определяет адрес функции и затем уже просто обращается по этому адресу. До этого мы использовали только раннее связывание.
Механизм позднего связывания представляет выбор реализации нужной функции на этапе выполнения программы. Заранее должен быть известен тип ссылки на функцию, и уже потом выбирается ее нужная реализация. В С++ данный процесс реализуют указатели на функции. Например:
#include <iostream>
using namespace std;
int add(int a, int b)
{
    return a + b;
}

int main()
{
    // Создаем указатель на функцию add
    int (*pF)(int, int) = add;
    cout << pF(4, 5) << endl; // вызов add(4 + 5)

    return 0;
}


Здесь был создан указатель на функцию add(). Позднее связывание обладает большей гибкостью, так как не нужно заранее знать, какую функцию вызывать. Но позднее связывание менее эффективно, так как появляется дополнительный указатель, который хранит адрес вызываемой функции.
Виртуальные функции — это пример использования позднего связывания. Если у дочернего класса существует переопределение виртуальной функции, то выполняется именно это переопределение. В ином случае выполняется функция, определенная в базовом классе. При создании указателя базового класса и вызове виртуальной функции через этот указатель компилятор не знает, виртуальная функция объекта какого класса (базового или производного) будет вызвана. Именно поэтому используется позднее связывание.
Виртуальный базовый класс
Вспомним проблему «алмаз смерти», которая возникает при множественном наследовании. Вкратце: от базового класса А наследуют два класса: В и С, — а от В и С наследует один класс — D. Проблема в том, что при создании объекта класса D непонятно, какой класс создает объект класса A — класс B или C?
Рассмотрим множественное наследование на конкретном примере:








Для решения данной проблемы создаются виртуальные базовые классы. Таким образом компилятор понимает, что за создание базового класса отвечает класс Cartoon (самый дочерний).

#include <iostream>
using namespace std;

class Animal
{
public:
    Animal(char a[]) {
        cout << a << endl;
    }
};

class Cat: virtual public Animal
{
public:
    Cat(char a[], char c[]) : Animal(a)
    {
        cout << c << endl;
    }
};

class Mouse: virtual public Animal
{
public:
    Mouse(char a[], char m[]) : Animal(a)
    {
        cout << m << endl;
    }
};

class Cartoon: public Cat, public Mouse
{
public:
    Cartoon(char a[], char c[], char m[]) :
    Cat(a,c), Mouse(a,m), Animal(a)
    { }
};

int main() {
    Cartoon animal("animal", "cat", "mouse");
}


int main() {
    Cartoon animal("animal", "cat", "mouse");
}


Результат выполнения программы:
animal
cat
mouse
Теперь понятно, что в момент создания объекта класса Cartoon именно этот класс и создает объекты своих родительских классов. Это необходимо учитывать при написании конструктора класса Cartoon.
Перегрузка операторов
Перегрузка функций — это определение нескольких функций с одинаковым именем, но различными параметрами. Наборы параметров перегруженных функций могут отличаться порядком следования, количеством, типом. Таким образом, перегрузка функций нужна для того, чтобы избежать дублирования имен функций, выполняющих сходные действия, но обладающих различной программной логикой.
В С++ оператором называется действие или функция, обозначенная специальным символом. Чтобы распространять эти действия на новые типы данных, сохраняя естественный синтаксис, в С++ была введена возможность перегрузки операторов.
Список операторов:
+ - * / %              //Арифметические операторы
+= -= *= /= %=
+a -a                  //Операторы знака
++a a++ --a a--        //Префиксный и постфиксный инкременты
&& || !                //Логические операторы
& | ~ ^
&= |= ^=
<< >> <<= >>=          //Битовый сдвиг
=                      //Оператор присваивания
== !=                  //Операторы сравнения
< > >= <=


Специальные операторы:
&a  *a  a->  a->*
()  []
(type)
.   ,   (a ? b : c)

Перегрузить можно почти все операторы, кроме тернарного оператора (?:), оператора (sizeof), оператора разрешения области видимости (::), оператора выбора члена (.) и указателя в качестве оператора выбора члена (.*).
Есть ряд правил и ограничений для перегрузки операторов:
Перегружать можно только существующие операторы — нельзя создавать новые или переименовывать существующие.
Хотя бы один операнд перегруженного оператора должен быть пользовательского типа данных — нельзя перегружать операторы только со встроенными типами данных.
Нельзя изменять количество операндов, поддерживаемых операторами — унарный оператор имеет только один операнд, бинарный — два, тернарный — три.
Все операторы сохраняют свой приоритет и ассоциативность по умолчанию.
Перегрузить операторы можно тремя способами:
через дружественные функции;
через обычные функции;
через методы класса.
Перегрузка операторов через дружественные функции
Покажем пример перегрузки оператора +:
#include <iostream>
using namespace std;

class Dollars
{
private:
    int m_dollars;

public:
    Dollars(int dollars) { m_dollars = dollars; }

    // выполняем Dollars + Dollars через дружественную функцию
    friend Dollars operator+ (const Dollars &d1, const Dollars &d2);

    int getDollars() const { return m_dollars; }
};

Dollars operator+(const Dollars &d1, const Dollars &d2)
{
    // используем конструктор Dollars и operator+(int, int)
    // мы имеем доступ к закрытому члену m_dollars, поскольку эта функция является дружественной классу Dollars
    return Dollars(d1.m_dollars + d2.m_dollars);
}

int main()
{
    Dollars dollars1(7);
    Dollars dollars2(9);
    Dollars dollarsSum = dollars1 + dollars2;
    cout << "I have " << dollarsSum.getDollars() << " dollars.";
    return 0;
}

Результат исполнения программы:
I have 16 dollars.
Поскольку перегруженная функция является дружественной для класса Dollars, то она имеет доступ к закрытым членам этого класса. Определять дружественную функцию можно и внутри класса, но лучше записывать определения функций в отдельном .cpp-файле, чтобы разделять интерфейс и реализацию.
Необходимо предусмотреть случай операторов с разными типами операндов. Например, в нашем случае необходим еще добавить operator+(Dollars, int), а также симметричный ему оператор operator+(int, Dollars).
Аналогичным образом можно перегружать операторы -, *, /. Обратите внимание, что операторы - и / не являются ассоциативными, то есть порядок следования операндов имеет значение.
Перегрузка операторов через обычные функции
Если у вас в классе присутствуют get-функции, можно перегружать операторы через обычные функции, которые не являются членами класса.
#include <iostream>
using namespace std;
class Dollars
{
private:
    int m_dollars;

public:
    Dollars(int dollars) { m_dollars = dollars; }

    int getDollars() const { return m_dollars; }
};

// Эта функция не является ни методом класса, ни дружественной классу Dollars!
Dollars operator+(const Dollars &d1, const Dollars &d2)
{
    // используем конструктор Dollars и operator+(int, int)
    // здесь нам не нужен прямой доступ к закрытым членам класса Dollars
    return Dollars(d1.getDollars() + d2.getDollars());
}

int main()
{
    Dollars dollars1(7);
    Dollars dollars2(9);
    Dollars dollarsSum = dollars1 + dollars2;
    cout << "I have " << dollarsSum.getDollars() << " dollars.";

    return 0;
}

В данном примере перегрузка осуществляется через обычную функцию. Данный способ рекомендуется использовать, когда в классе есть get-функции. Если их нет, специально создавать не надо, чтобы не загружать код дополнительными функциями. Поэтому необходимо использовать перегрузку через дружественные функции.
Перегрузка операторов через методы класса
Пример перегрузки оператора через метод класса:
#include <iostream>
using namespace std;
class Dollars
{
private:
    int m_dollars;

public:
    Dollars(int dollars) { m_dollars = dollars; }
    // Эта функция является методом класса!
    // Вместо параметра dollars в перегрузке через дружественную функцию здесь неявный параметр, на который указывает указатель *this
    Dollars operator+(int value)
    {
        return Dollars(m_dollars + value);
    }
    int getDollars() { return m_dollars; }
};

int main()
{
    Dollars dollars1(7);
    Dollars dollars2 = dollars1 + 3;
    cout << "I have " << dollars2.getDollars() << " dollars.\n";
    return 0;
}

В данном примере у оператора только один аргумент. На самом деле, он явный, а есть еще один — неявный, который ссылается с помощью указателя *this на текущий объект. Поэтому в строке return Dollars(m_dollars + value) переменная-член m_dollars является членом того объекта, который вызвал этот метод.
Через методы класса нужно переопределять операторы присваивания (=), индекса ([]), вызова функции (()) и выбора члена (->). Это требование языка С++.
Через методы класса нельзя переопределять операторы ввода (>>) и вывода (<<). Также не получится переопределить бинарный оператор, левый операнд которого не является классом (например, int) или это класс, который мы не можем изменить (например, ostream). Это следует из того, что левый операнд должен обязательно быть членом данного класса.
Каким из трех способов переопределять операторы, решать вам. Но обычно бинарные операторы, которые не изменяют левый операнд, переопределяют через обычные или дружественные функции. Если же левый операнд изменяется, то используют перегрузку через методы класса (например, operator+=). Унарные операторы тоже перегружаются через методы класса, так как в таком случае параметры не используются вовсе.

Операторы
Перегрузка через обычную или дружественную функцию
Перегрузка через метод класса
Унарный оператор
-
+
Бинарный оператор, не изменяющий левый операнд
+
-
Бинарный оператор, изменяющий левый операнд
-
+



Перегрузка унарных операторов
Перегрузим унарный оператор минус (-) и логический оператор НЕ (!).
#include <iostream>
using namespace std;
class Vector
{
private:
    double m_x, m_y, m_z;

public:
    Vector(double x = 0.0, double y = 0.0, double z = 0.0) :
    m_x(x), m_y(y), m_z(z)
    {
    }

    Vector operator- () const
    {
        return Vector(-m_x, -m_y, -m_z);
    }

    bool operator! () const
    {
        return (m_x == 0.0 && m_y == 0.0 && m_z == 0.0);
    }

    double getX() {return m_x;}
    double getY() {return m_y;}
    double getZ() {return m_z;}
};

int main()
{
    Vector v1; // используем конструктор по умолчанию со значениями 0.0, 0.0, 0.0
    if (!v1)
        cout << "Vector_1 is null.\n";
    else
        cout << "Vector_1 is not null.\n";

    Vector v2(1,2,3);
    cout << "Opposite vector_2 is (" << -v2.getX() << ", " << -v2.getY() << ", " << -v2.getZ() << ").";

    return 0;
}


Результат выполнения программы:
Vector_1 is null.
Opposite vector_2 is (-1, -2, -3).
Обратите внимание, что методы класса объявлены константными. Это сделано потому, что оператор не изменяет объект, вызвавший этот метод. При этом константный метод также необходим, если мы используем его для константного объекта этого класса.
Создание классов для игры Blackjack

Начиная с этого урока, будем с использованием полученных знаний по ООП создавать игру Blackjack. Суть проста: раздаются карты, за каждую из которых начисляются очки. Игрок пытается заработать 21 очко, не больше. За каждую карту с числом дается столько очков, сколько на ней указано. За туз — либо 1 очко, либо 11 (что больше подходит игроку), а за валета, даму и короля — по 10 очков.
Компьютер выступает дилером и играет против группы от одного до семи игроков. В начале кона все участники, включая дилера, получают две карты. Игроки могут видеть все свои карты, а также сумму очков. Однако одна из карт дилера скрыта на протяжении всего кона.
Далее каждый игрок может брать дополнительные карты. Если сумма очков у него превысит 21, он проигрывает. Когда все игроки получили возможность набрать дополнительные карты, дилер открывает скрытую карту. Далее он обязан брать новые карты до тех пор, пока сумма его очков не превышает 16. Если у дилера перебор, все игроки, не имеющие перебора, побеждают. В противном случае сумма очков каждого из оставшихся игроков сравнивается с суммой очков дилера. Игрок побеждает, если сумма его очков больше, чем у дилера. В противном случае — проигрывает. Если суммы очков игрока и дилера одинаковы, засчитывается ничья.
Разработаем классы, которые будем использовать в нашей программе:
Класс
Родительский класс
Описание
Card
нет
Карта
Hand
нет
Набор карт, коллекция объектов класса Card
Deck
Hand
Имеет дополнительную функциональность, которая отсутствует в классе Hand, в частности — тасование и раздачу
GenericPlayer
Hand
Обобщенно описывает игрока. Не является полноценным игроком, а лишь содержит элементы, характерные как для игрока-человека, так и для игрока-компьютера
Player
GenericPlayer
Человек-игрок
House
GenericPlayer
Компьютер-игрок
Game
нет
Игра


Обратите внимание: класс GenericPlayer создается для того, чтобы общая функциональность классов Player и House не дублировалась в обоих классах.
Колода карт отделена от дилера, поэтому карты колоды будут раздаваться игрокам-людям и игроку-компьютеру на равных. Это значит, что функция-член, предназначенная для раздачи карт, будет полиморфной.

Приведем иерархию данных классов:

Практические задания
Создать абстрактный класс Figure (фигура). Его наследниками являются классы Parallelogram (параллелограмм) и Circle (круг). Класс Parallelogram — базовый для классов Rectangle (прямоугольник), Square (квадрат), Rhombus (ромб). Для всех классов создать конструкторы. Для класса Figure добавить чисто виртуальную функцию area() (площадь). Во всех остальных классах переопределить эту функцию, исходя из геометрических формул нахождения площади.
Создать класс Car (автомобиль) с полями company (компания) и model (модель). Классы-наследники: PassengerCar (легковой автомобиль) и Bus (автобус). От этих классов наследует класс Minivan (минивэн). Создать конструкторы для каждого из классов, чтобы они выводили данные о классах. Создать объекты для каждого из классов и посмотреть, в какой последовательности выполняются конструкторы. Обратить внимание на проблему «алмаз смерти».
Примечание: если использовать виртуальный базовый класс, то объект самого "верхнего" базового класса создает самый "дочерний" класс.
Создать класс: Fraction (дробь). Дробь имеет числитель и знаменатель (например, 3/7 или 9/2). Предусмотреть, чтобы знаменатель не был равен 0. Перегрузить:
математические бинарные операторы (+, -, *, /) для выполнения действий с дробями
унарный оператор (-)
логические операторы сравнения двух дробей (==, !=, <, >, <=, >=).
Примечание: Поскольку операторы < и >=, > и <= — это логические противоположности, попробуйте перегрузить один через другой.
Продемонстрировать использование перегруженных операторов.
Создать класс Card, описывающий карту в игре БлэкДжек. У этого класса должно быть три поля: масть, значение карты и положение карты (вверх лицом или рубашкой). Сделать поля масть и значение карты типом перечисления (enum). Положение карты - тип bool. Также в этом классе должно быть два метода:
метод Flip(), который переворачивает карту, т.е. если она была рубашкой вверх, то он ее поворачивает лицом вверх, и наоборот.
метод GetValue(), который возвращает значение карты, пока можно считать, что туз = 1.

Дополнительные материалы
Бьерн Страуструп. Программирование. Принципы и практика использования С++.
Стивен Прата. Язык программирования С++. Лекции и упражнения.
Роберт Лафоре. Объектно-ориентированное программирование в С++.
Используемая литература
Для подготовки данного методического пособия были использованы следующие ресурсы:
Онлайн справочник программиста на C и C++. Полиморфизм.
Бьерн Страуструп. Программирование. Принципы и практика использования С++.
Ральф Джонсон, Ричард Хелм, Эрих Гамма. Приемы объектно-ориентированного программирования. Паттерны проектирования.

*/


// УРОК №4
//--------



/*
Отношения между объектами в С++

Композиция. Агрегация. Ассоциация. Зависимость. Контейнерные классы. Операторы приведения типа. Примеры программ на С++.

Отношения между объектами в С++
Композиция
Агрегация
Ассоциация
Зависимость
Контейнерные классы
Стандартная библиотека шаблонов
Введение в std::vector
Итераторы STL
Создание контейнерного класса
Динамическое приведение типов
Написание игры Blackjack
Практические задания
Дополнительные материалы
Используемая литература
Отношения между объектами в С++
Прежде чем изучать основные паттерны программирования, необходимо разобраться в отношениях между классами и объектами в С++. Это позволит понять связи между сущностями при использовании их в паттернах. В данном уроке рассмотрим основные типы отношений:
композицию;
агрегацию;
ассоциацию;
зависимость.
Эти типы отношений имеют аналогии в реальной жизни. Например:
квадрат является геометрической фигурой;
автомобиль имеет руль;
программист использует клавиатуру;
цветок зависит от растения;
ученик является членом класса;
мозг существует как часть человека.
Здесь мы приводим в пример типы отношений, которые есть и в программировании. Рассмотрим их подробнее.
Композиция
Композиция — это построение сложного объекта из более простых. Например, организм состоит из органов или автомобиль — из двигателя, шасси и других элементов.
Для реализации композиции объект и часть должны иметь следующие отношения:
часть (член) является составляющей объекта (класса);
часть (член) может принадлежать только одному объекту (классу) в каждом конкретном случае;
часть (член) существует под управлением объекта (класса);
часть (член) не знает о существовании объекта (класса).
Рассмотрим пример на языке программирования.
#include <iostream>
#include <string>
using namespace std;

class Human
{
public:
    void Think()
    {
        brain.Think();
    }
private:
    class Brain
    {
    public:
        void Think()
        {
            cout << "Я думаю!" << endl;
        }
    };
    Brain brain;
};

int main()
{
    Human human;
    human.Think();
}

В данном примере метод Think() можно вызвать, только если есть объект класса Human. Иными словами, объект класса Brain существует только тогда, когда существует объект класса Human. Класс Brain находится в private-области класса Human, таким образом достигается инкапсуляция данного класса.
Агрегация
Для реализации агрегации целое и его части должны соответствовать следующим отношениям:
часть (член) является составляющей целого (класса);
часть (член) может принадлежать более чем одному целому (классу) в каждом конкретном случае;
часть (член) существует не под управлением целого (класса);
часть (член) не знает о существовании целого (класса).
Как и в случае с композицией, отношения в агрегации однонаправленные и представлены в формате «часть — целое». Но в отличие от композиции, части могут принадлежать более чем одному целому, и оно не управляет существованием и временем жизни частей. При создании и уничтожении агрегации целое не несет ответственности за создание и уничтожение своих частей.
Приведем наглядный пример. Комната является частью квартиры, следовательно здесь подходит композиция, потому что комната без квартиры существовать не может. А вот мебель не является неотъемлемой частью квартиры. Но в то же время квартира содержит мебель, поэтому следует использовать агрегацию.
Рассмотрим классы Human и Cap. В реальной жизни кепка является частью одежды человека. И хотя кепка принадлежит человеку, она может принадлежать и другим объектам — например, манекену в магазине. Человек не несет ответственность за создание и уничтожение кепки. При этом человек знает, что у  него есть кепка, но сама она не в курсе, что является частью человека.
class Cap {
public:
    string getColor() {
        return color;
    }
private:
    // Пусть все кепки будут красными.
    string color = "красный";
};

class Human
{
public:
    void InspectTheCap () {
        cout << "Моя кепка имеет " << cap.getColor() << " цвет.";
    }
private:
    Cap cap;
};

int main()
{
    Human human;
    human.InspectTheCap();
}


В данном примере реализована агрегация.

Рассмотрим более сложный пример с сотрудником и отделом, где он работает:
class Worker
{
private:
    string m_name;

public:
    Worker(string name) : m_name(name)
    { }
    string getName() { return m_name; }
};

class Department
{
private:
    // Для простоты добавим только одного работника
    Worker *m_worker;
public:
    Department(Worker *worker = nullptr) : m_worker(worker)
    {  }
};

int main()
{
    // Создаем нового работника
    Worker *worker = new Worker("Anton");
    {
        // Создаем Отдел и передаем Работника в Отдел через параметр конструктора
        Department department(worker);
    } // department выходит из области видимости и уничтожается здесь

    // worker продолжает существовать
    cout << worker->getName() << " still exists!";
    delete worker;

    return 0;
}

Здесь Работник создается независимо от Отдела, а затем переходит в параметр конструктора класса Отдела. Когда department уничтожается, указатель m_worker уничтожается также, но сам Работник не удаляется — он существует до тех пор, пока не будет уничтожен в main().
При решении задачи определяйте тип отношений в зависимости от того, какой из них будет самым простым и соответствующим потребностям вашей программы.
Ассоциация
В ассоциации два несвязанных объекта должны соответствовать следующим отношениям:
первый объект (член) не связан со вторым объектом (классом);
первый объект (член) может принадлежать одновременно сразу нескольким объектам (классам);
первый объект (член) существует не под управлением второго объекта (класса);
первый объект (член) может знать или не знать о существовании второго объекта (класса).
В отличие от композиции или агрегации, где объект является частью целого, в ассоциации объекты между собой не связаны. Подобно тому, как происходит при агрегации, первый объект может принадлежать нескольким объектам одновременно и не управляться ими. Но в отличие от агрегации, где отношения однонаправленные, в ассоциации они могут быть и двунаправленными — когда оба объекта знают о существовании друг друга.
Ассоциации реализовываются по-разному. Чаще всего для этого используют указатели, где классы указывают на объекты друг друга. Покажем пример, как класс Водитель может иметь однонаправленную связь с классом Автомобиль без переменной-члена в виде указателя на объект этого класса:
#include <iostream>
#include <string>
using namespace std;

class Car
{
private:
    string m_name;
    int m_id;

public:
    Car(string name, int id) : m_name(name), m_id(id)
    { }

    string getName() { return m_name; }
    int getId() { return m_id;  }
};


// Данный класс содержит автомобили и имеет функцию для "выдачи" автомобиля
class CarLot
{
private:
    static Car s_carLot[4];

public:
    // Удаляем конструктор по умолчанию, чтобы нельзя было создать объект этого класса
    CarLot() = delete;

    static Car* getCar(int id)
    {
        for (int count = 0; count < 4; ++count)
            if (s_carLot[count].getId() == id)
                return &(s_carLot[count]);

        return nullptr;
    }
};

Car CarLot::s_carLot[4] = { Car("Camry", 5), Car("Focus", 14), Car("Vito", 73), Car("Levante", 58) };

class Driver
{
private:
    string m_name;
    int m_carId; // для связывания классов используется эта переменная

public:
    Driver(string name, int carId) : m_name(name), m_carId(carId)
    {  }
    string getName() { return m_name; }
    int getCarId() { return m_carId; }

};

int main()
{
    Driver d("Ivan", 14); // Ivan ведет машину с ID 14

    Car *car = CarLot::getCar(d.getCarId()); // Получаем этот Автомобиль из CarLot

    if (car)
        cout << d.getName() << " is driving a " << car->getName() << '\n';
    else
        cout << d.getName() << " couldn't find his car\n";

    return 0;
}

Car CarLot::s_carLot[4] = { Car("Camry", 5), Car("Focus", 14), Car("Vito", 73), Car("Levante", 58) };

class Driver
{
private:
    string m_name;
    int m_carId; // для связывания классов используется эта переменная

public:
    Driver(string name, int carId) : m_name(name), m_carId(carId)
    {  }
    string getName() { return m_name; }
    int getCarId() { return m_carId; }

};



int main()
{
    Driver d("Ivan", 14); // Ivan ведет машину с ID 14

    Car *car = CarLot::getCar(d.getCarId()); // Получаем этот Автомобиль из CarLot

    if (car)
        cout << d.getName() << " is driving a " << car->getName() << '\n';
    else
        cout << d.getName() << " couldn't find his car\n";

    return 0;
}

Результат выполнения программы:
Ivan is driving a Focus
В примере выше у нас есть CarLot (Гараж), в котором находятся наши автомобили. У Водителя, которому нужен Автомобиль, нет на него указателя, но есть Идентификатор Автомобиля, который он может использовать, чтобы получить Автомобиль из Гаража, когда ему это нужно.
Зависимость
Зависимость возникает, когда один объект обращается к функциональности другого, чтобы выполнить задание. Эти отношения слабее ассоциации, но все же любое изменение объекта, который предоставляет свою функциональность зависимому объекту, может стать причиной сбоя в его работе. Зависимость всегда однонаправленная.
Хорошим примером зависимости, которую вы уже видели много раз, является std::cout. Классы используют std::cout для вывода в консоль, но не наоборот.
Часто путают, чем зависимость отличается от ассоциации.
В C++ ассоциации — это отношения между двумя классами на уровне классов. То есть первый класс сохраняет прямую или косвенную связь со вторым через переменную-член. Например, в классе Врач есть массив указателей на объекты класса Пациент в виде переменной-члена. Вы всегда можете спросить у Врача, кто его Пациенты. Класс Водитель содержит идентификатор Автомобиля в виде целочисленной переменной-члена. Водитель знает, к чему привязан Автомобиль и как получить к нему доступ.
Зависимости обычно не представлены на уровне классов, то есть зависимый объект не связан со вторым объектом через переменную-член. Зависимый объект создается при необходимости (например, при открытии файла для записи данных) или передается в функцию в качестве параметра.
Контейнерные классы
Контейнерный класс в C++ — это класс, предназначенный для хранения и организации нескольких объектов определенного типа данных (пользовательских или фундаментальных). Есть много разных контейнерных классов, у каждого из которых свои преимущества, недостатки или ограничения. Наиболее часто используемым контейнером в программировании является массив. Хотя в C++ есть стандартные массивы, большинство программистов используют контейнерные классы-массивы — например, vector.
Обычно функциональность классов-контейнеров в C++ следующая:
создание пустого контейнера (через конструктор);
добавление нового объекта в контейнер;
удаление объекта из контейнера;
просмотр количества объектов, находящихся на данный момент в контейнере;
очистка контейнера от всех объектов;
доступ к сохраненным объектам;
сортировка объектов/элементов (не всегда).
Функциональность контейнерных классов может быть меньше, чем указанная в этом перечне.
В С++ есть стандартные контейнерные классы. Эта библиотека называется Стандартной библиотекой шаблонов (STL).
Стандартная библиотека шаблонов
STL — это часть Стандартной библиотеки С++, которая содержит набор шаблонов контейнерных классов, алгоритмов и итераторов. Преимущество STL в том, что эти классы можно использовать без необходимости писать и отлаживать их самостоятельно. Плюс вы получаете их эффективные версии.
Контейнеры STL делятся на три основные категории:
последовательные;
ассоциативные;
адаптеры.
Рассмотрим их более подробно.
Последовательные контейнеры (или контейнеры последовательности) — это контейнерные классы, элементы которых находятся в последовательности. Их определяющей характеристикой является то, что вы можете вставить свой элемент куда угодно в контейнере. Наиболее распространенным примером последовательного контейнера является массив: при вставке четырех элементов в массив они будут находиться в таком же порядке, как вы их вставляли.
STL содержит 6 контейнеров последовательности:
   std::vector;
   std::deque;
   std::array;
   std::list;
   std::forward_list;
   std::basic_string.
Класс vector рассмотрим более подробно.
Ассоциативные контейнеры — это контейнерные классы, которые автоматически сортируют все свои элементы. По умолчанию ассоциативные контейнеры выполняют сортировку элементов, используя оператор сравнения.
set — это контейнер, в котором хранятся только уникальные элементы, повторения запрещены. Элементы сортируются в соответствии с их значениями.
multiset — это set, но в котором допускаются повторяющиеся элементы.
map — это set, в котором каждый элемент является парой «ключ — значение». Ключ используется для сортировки и индексации данных и должен быть уникальным. А значение — это фактические данные.
multimap — это map, который допускает дублирование ключей. Все ключи отсортированы в порядке возрастания, и вы можете посмотреть значение по ключу.
Адаптеры — это специальные предопределенные контейнерные классы, которые адаптированы для выполнения конкретных заданий. Самое интересное заключается в том, что вы сами можете выбрать, какой последовательный контейнер должен использовать адаптер.
stack (стек) — это контейнерный класс, элементы которого работают по принципу LIFO («Last In, First Out» — «последним пришел, первым ушел»), то есть элементы вставляются (вталкиваются) в конец контейнера и удаляются (выталкиваются) оттуда же (из конца контейнера).
queue (очередь) — это контейнерный класс, элементы которого работают по принципу FIFO («First In, First Out» — «первым пришел, первым ушел»), то есть элементы вставляются (вталкиваются) в конец контейнера, но удаляются (выталкиваются) из начала контейнера.
priority_queue (очередь с приоритетом) — это тип очереди, в которой все элементы отсортированы. При вставке элемента он автоматически сортируется. Элемент с наивысшим приоритетом (самый большой) находится в самом начале очереди с приоритетом. Удаление элементов из такой очереди выполняется с самого начала очереди с приоритетом.
Введение в std::vector
Для хранения однотипных данных в С++ используются массивы. Существуют массивы с фиксированной длиной и динамические, длина которых может изменяться по ходу исполнения программы. Динамические массивы очень популярны, так как зачастую мы не знаем заранее, сколько элементов будет в массиве. Для реализации динамических массив в С++ можно использовать операторы new и delete.
#include <iostream>
using namespace std;

int main()
{
    int num;                     // размер массива
    cin >> num;                  // получение от пользователя размера массива
    int *p_array = new int[num]; // Выделение памяти для массива
    for (int i = 0; i < num; i++) {
                                 // Заполнение массива
        cin >> p_array[i];
    }
    // ....
    delete [] p_array;           // очистка памяти
    return 0;
}

Но существует более удобная версия динамических массивов — std::vector. С его помощью можно создавать массивы, длина которых задается во время выполнения, не используя операторы new и delete, то есть явно не указывая выделение и освобождение памяти. std::vector находится в заголовочном файле <vector>.
Создание динамического массива целых чисел следующее:
#include <vector>
using namespace std;
// нет необходимости указывать длину при инициализации
vector<int> array;
vector<int> array2 = { 10, 8, 6, 4, 2, 1 };
vector<int> array3 { 10, 8, 6, 4, 2, 1 };

Доступ к элементам динамического массива выполняется так же, как и в обычном массиве, — через оператор []:
array2[0] = 3;
Векторы отслеживают свою длину с помощью функции size():
array2.size();

Можно изменить длину вектора с помощью функции resize():
#include <vector>
#include <iostream>
using namespace std;

void print(vector<int> &a) {
    cout << "The length is: " << a.size() << '\n';

    for (int i=0; i<a.size(); i++)
        cout << a[i] << ' ';

    cout << endl;
}

int main()
{
    vector<int> array { 0, 1, 2, 3 };

    array.resize(7); // изменяем длину array на 7
    print(array);

    array.resize(2);
    print(array);

    return 0;
}

Результат выполнения программы:
The length is: 7
0 1 2 3 0 0 0
The length is: 2
0 1
Как видно из результата, можно увеличивать длину вектора, при этом пустые элементы будут инициализироваться начальными значениями (для типа int — 0). Или уменьшать — при этом часть элементов будет теряться.
Для добавления нового элемента в вектор существует функция push_back(). Для удаления последнего элемента вектора используйте функцию pop_back(), а для удаления всех элементов массива — clear(). Функция empty() проверяет вектор на пустоту.
#include <vector>
#include <iostream>
using namespace std;

void print(vector<int> &a) {
    cout << "The length is: " << a.size() << '\n';

    for (int i=0; i<a.size(); i++)
        cout << a[i] << ' ';

    cout << endl;
}

int main()
{
    vector<int> array { 0, 1, 2, 3 };

    array.push_back(4);
    print(array);

    array.pop_back();
    print(array);

    array.clear();
    print(array);

    if (array.empty())
        cout << "Vector is empty.\n";
    else
        cout << "Vector is not empty.\n";

    return 0;
}

Результат выполнения программы:
The length is: 5
0 1 2 3 4
The length is: 4
0 1 2 3
The length is: 0

Vector is empty.
Итераторы STL
Итератор — это объект, который способен перебирать элементы контейнерного класса, а пользователю при этом не обязательно знать, как реализован этот контейнерный класс. Во многих контейнерах (особенно в списке и ассоциативных контейнерах set, map и т.д.) итераторы являются основным способом доступа к элементам.
Об итераторе можно думать как об указателе на определенный элемент контейнерного класса с дополнительным набором перегруженных операторов для выполнения четко определенных функций:
Оператор * возвращает элемент, на который в данный момент указывает итератор.
Оператор ++ перемещает итератор к следующему элементу контейнера. Большинство итераторов также предоставляют оператор −− для перехода к предыдущему элементу.
Операторы == и != используются для определения того, указывают ли два итератора на один и тот же элемент. Для сравнения значений, на которые указывают два итератора, нужно сначала разыменовать их, а затем использовать оператор == или !=.
Оператор = присваивает итератору новую позицию (обычно начало или конец элементов контейнера). Чтобы присвоить другому объекту значение элемента, на который указывает итератор, нужно сначала разыменовать итератор, а затем использовать оператор =.
Каждый контейнерный класс имеет 4 основных метода для работы с оператором =:
begin() возвращает итератор, представляющий начало элементов контейнера.
end() возвращает итератор, представляющий элемент, который находится после последнего элемента в контейнере.
cbegin() возвращает константный (только для чтения) итератор, представляющий начало элементов контейнера.
cend() возвращает константный (только для чтения) итератор, представляющий элемент, который находится после последнего элемента в контейнере.
Наконец, все контейнеры предоставляют (как минимум) два типа итераторов:
container::iterator — итератор для чтения/записи;
container::const_iterator — итератор только для чтения.
Рассмотрим пример использования итераторов для вектора.
Заполним вектор пятью числами и, с помощью итераторов, выведем значения вектора:
#include <iostream>
#include <vector>
using namespace std;

int main()
{
    vector<int> myVector;
    for (int count=0; count < 5; ++count)
        myVector.push_back(count);

    vector<int>::const_iterator it; // объявляем итератор только для чтения
    it = myVector.begin(); // присваиваем ему начало вектора
    while (it != myVector.end()) // пока итератор не достигнет конца
    {
        cout << *it << " "; // выводим значение элемента, на который указывает итератор
        ++it; // и переходим к следующему элементу
    }
    cout << '\n';
}

Результат выполнения программы выше:
0 1 2 3 4

Создание контейнерного класса
Создадим контейнерный класс-массив, который будет реализовывать функциональность векторов. Но наш класс-массив будет только целочисленным.
Создадим файл ArrayInt.h и в нем объявим класс ArrayInt. В этом классе будет две переменные — данные массива (реализовано через указатель) и длина массива. Создадим два конструктора: один для пустого массива, другой для массива с заданной длиной и значениями. Также потребуется деструктор, который выполняет очистку памяти.
#ifndef ARRAYINT_H
#define ARRAYINT_H

#include <cassert> // для assert()

class ArrayInt
{
private:
    int m_length;
    int *m_data;

public:
    ArrayInt(): m_length(0), m_data(nullptr)
    { }

    ArrayInt(int length):
    m_length(length)
    {
        assert(length >= 0);

        if (length > 0)
            m_data = new int[length];
        else
            m_data = nullptr;
    }

    ~ArrayInt()
    {
        delete[] m_data;
    }
};

#endif


Теперь напишем функцию erase(), которая будет выполнять очитку массива и сбрасывать его длину на 0 (аналог функции clear() в векторах) и функцию для возврата длины массива (аналог size()):
    void erase()
    {
        delete[] m_data;

        // Здесь нам нужно указать m_data значение nullptr, чтобы на выходе не было висячего указателя
        m_data = nullptr;
        m_length = 0;
    }
    int getLength() { return m_length; }


Перегрузим оператор индексации [], чтобы иметь доступ к элементам массива:
        int& operator[](int index)
    {
        assert(index >= 0 && index < m_length);
        return m_data[index];
    }

Перегрузка осуществляется через метод класса. Функция перегрузки оператора [] всегда будет принимать один параметр: значение индекса. В случае с IntArray нужно, чтобы пользователь просто указал в квадратных скобках индекс для возврата значения элемента по нему. Обратите внимание, что оператор индексации использует возврат по ссылке. Если мы захотим изменить значение элемента массива, то выражение array[k] (где k — номер элемента массива) будет стоять слева от оператора присваивания =. Это означает, что array[k] должно быть l-value (переменной с адресом памяти). Поэтому перегруженная функция должна возвращать ссылку на элемент, а не просто его значение.

Напишем функцию, которая реализует возможность изменять размер массива (аналог resize()):
    // Функция resize изменяет размер массива. Все существующие элементы сохраняются. Процесс медленный
    void resize(int newLength)
    {
        // Если массив уже нужной длины — return
        if (newLength == m_length)
            return;

        // Если нужно сделать массив пустым — делаем это и затем return
        if (newLength <= 0)
        {
            erase();
            return;
        }

        // Теперь знаем, что newLength >0
        // Выделяем новый массив
        int *data = new int[newLength];

        // Затем нужно разобраться с количеством копируемых элементов в новый массив
        // Нужно скопировать столько элементов, сколько их есть в меньшем из массивов
        if (m_length > 0)
        {
            int elementsToCopy = (newLength > m_length) ? m_length : newLength;

            // Поочередно копируем элементы
            for (int index=0; index < elementsToCopy ; ++index)
                data[index] = m_data[index];
        }

        // Удаляем старый массив, так как он нам уже не нужен
        delete[] m_data;

        // И используем вместо старого массива новый! Обратите внимание, m_data указывает
        // на тот же адрес, на который указывает наш новый динамически выделенный массив. Поскольку
        // данные были динамически выделенные — они не будут уничтожены, когда выйдут из области видимости
        m_data = data;
        m_length = newLength;
    }


Напишем функцию insertBefore() для добавления нового элемента в массив (в реализации эта функция очень похожа на resize()):
    void insertBefore(int value, int index)
    {
        // Проверка корректности передаваемого индекса
        assert(index >= 0 && index <= m_length);

        // Создаем новый массив на один элемент больше старого массива
        int *data = new int[m_length+1];

        // Копируем все элементы до index-а
        for (int before=0; before < index; ++before)
            data[before] = m_data[before];

        // Вставляем новый элемент в новый массив
        data [index] = value;

        // Копируем все значения после вставляемого элемента
        for (int after=index; after < m_length; ++after)
            data[after+1] = m_data[after];

        // Удаляем старый массив и используем вместо него новый
        delete[] m_data;
        m_data = data;
        ++m_length;
    }


Теперь легко реализовать аналог функции push_back() в векторах:
void push_back(int value) { insertBefore(value, m_length); }

Динамическое приведение типов
В C++ есть 5 типов cast:
C-style_cast,
static_cast,
const_cast,
dynamic_cast
reinterpret_cast.
Сейчас рассмотрим dynamic_cast.
Применяя полиморфизм на практике, вы часто будете сталкиваться с ситуациями, когда у вас есть указатель на родительский класс, но нужно получить доступ к данным, которые есть только в дочернем.

#include <iostream>
#include <string>
using namespace std;
class Parent
{
protected:
    string m_name;

public:
    Parent(string name) : m_name(name)
    { }
    virtual ~Parent() {}
};

class Child: public Parent
{
protected:
     string m_ patronymic;

public:
    Child(string name, string patronymic) :
    Parent(name), m_ patronymic (patronymic)
    { }
    const string& getName() { return m_name; }
};

Parent* Create()
{
        return new Child("Alex", "Mike");
}

int main()
{
    Parent *p = Create();

    // как мы выведем имя объекта класса Child здесь, имея лишь один указатель класса Parent?

    delete p;
    return 0;
}



В этой программе функция Create() всегда возвращает указатель класса Parent, но он может указывать либо на объект класса Parent, либо на объект класса Child — в этом случае будем вызывать Child::getName()?
Один из способов — добавить виртуальную функцию getName() в класс Parent. Но, используя этот вариант, будем загрязнять класс Parent тем, что должно быть заботой только класса Child.
C++ позволяет неявно преобразовать указатель класса Child в указатель класса Parent — фактически, это и делает Create(). Эта конвертация называется приведением к базовому типу, или повышающим приведением типа. Но как конвертировать указатель класса Parent обратно в указатель класса Child?
В C++ оператор dynamic_cast используется именно для этого. Хотя динамическое приведение позволяет выполнять не только конвертацию указателей родительского класса в указатели дочернего класса, это наиболее распространенное применение dynamic_cast. Этот процесс называется приведением к дочернему типу, или понижающим приведением типа. Вот пример его использования:
int main()
{
    Parent *p = Create();
    // используем dynamic_cast для конвертации указателя класса Parent в указатель класса Child
    Child *ch = dynamic_cast<Child*>(p);

    cout << "The name of the Child is: " << ch->getName() << '\n';
    delete p;
    return 0;
}

Пример выше работает только из-за того, что указатель p на самом деле указывает на объект класса Child, поэтому конвертация успешна. Если бы он изначально указывал на объект класса Parent, то конвертация была бы невозможна и dynamic_cast вернул бы нулевой указатель. Именно поэтому после использования dynamic_cast необходимо выполнять проверку на нулевой указатель.
Также обратите внимание на случаи, в которых понижающее приведение с использованием dynamic_cast не работает:
Наследование типа private или protected.
Классы, которые не объявляют или не наследуют классы с какими-либо виртуальными функциями. Если бы в примере выше мы удалили виртуальный деструктор класса Parent, то преобразование через dynamic_cast не выполнилось бы.
Хотя в последнем примере мы использовали динамическое приведение с указателем (наиболее распространенная практика), dynamic_cast также может использоваться и со ссылками. Поскольку в C++ не существует «нулевой ссылки», то dynamic_cast не может вернуть «нулевую ссылку» при сбое. Вместо этого dynamic_cast генерирует исключение типа std::bad_cast (об исключениях — в следующем уроке).
В общем, лучше использовать виртуальные функции, чем понижающее приведение. Кроме ряда случаев, когда понижающее приведение предпочтительнее:
Если вы не можете изменить родительский класс, чтобы добавить в него свою виртуальную функцию (например, если он является частью стандартной библиотеки С++). При этом, чтобы использовать понижающее приведение, в родительском классе должны уже присутствовать виртуальные функции.
Если вам нужен доступ к чему-либо, что есть только в дочернем классе — например, к функции доступа.
Если добавление виртуальной функции в родительский класс не имеет смысла. Если при этом вам не нужно создавать объект родительского класса, можете использовать чистую виртуальную функцию.
Написание игры Blackjack
В прошлый раз мы создали иерархию классов игры Blackjack. В данном уроке рассмотрим функциональность каждого класса, а также напишем функцию main().
Класс Card
Член класса
Описание
rank m_Rank
Значение карты (туз, двойка, тройка и так долее). rank — это перечисление, куда входят все 13 значений
suit m_Suit
Масть карты (трефы, бубны, червы и пики). suit — это перечисление, содержащее четыре возможные масти
bool m_IsFaceUp
Указывает, как расположена карта — вверх лицом или рубашкой. Влияет на то, отображается она или нет
int GetValue()
Возвращает значение карты
void Flip()
Переворачивает карту. Может использоваться для того, чтобы перевернуть карту лицом вверх или вниз


Класс Hand
Член класса
Описание
vector<Card*> m_Cards
Коллекция карт. Хранит указатели на объекты типа Сard
void Add(Card* pCard)
Добавляет карту в руку. Добавляет указатель на объект типа Сard в вектор m_Сards
void Clear()
Очищает руку от карт. Удаляет все указатели из вектора m_Сards, устраняя все связанные с ними объекты в куче
int GetTotal()
Возвращает сумму очков карт руки


Класс GenericPlayer
Член класса
Описание
string m_Name
Имя игрока
virtual bool IsHitting() const = 0
Указывает, нужна ли игроку еще одна карта. Чистая виртуальная функция
bool IsBoosted() const
Указывает, что у игрока перебор
void Bust() const
Объявляет, что у игрока перебор



Класс Player:
Член класса
Описание
virtual bool IsHitting() const
Указывает, нужна ли игроку еще одна карта
void Win() const
Объявляет, что игрок выиграл
void Lose() const
Объявляет, что игрок проиграл
void Push() const
Объявляет, что игрок сыграл вничью


Класс House
Член класса
Описание
virtual bool IsHitting() const
Указывает, нужна ли игроку еще одна карта
void FlipFirstCard()
Переворачивает первую карту


Класс Deck
Член класса
Описание
vold Populate()
Создает стандартную колоду из 52 карт
void Shuffle()
Тасует карты
vold Deal (Hand& aHand)
Раздает в руку одну карту
void AddltionalCards (GenericPlayer& aGenerlcPlayer)
Раздает игроку дополнительные карты до тех пор, пока он может и хочет их получать


Класс Game:
Член класса
Описание
Deck m_Deck
Колода карт
House m_House
Рука дилера
vector<Player> m_Players
Группа игроков-людей. Вектор, содержащий объекты типа Player
void Play()
Проводит кон игры Blackjack


В функции main() пользователь должен будет ввести количество игроков и их имена. После этого начнется игровой цикл: создание объекта класса Game и вызов метода play(). Вот реализация функции main():
#include <vector>
using namespace std;
int main()
{
    cout << "\t\tWelcome to Blackjack!\n\n";

    int numPlayers = 0;
    while (numPlayers < 1 || numPlayers > 7)
    {
        cout << "How many players? (1 - 7): ";
        cin >> numPlayers;
    }

    vector<string> names;
    string name;
    for (int i = 0; i < numPlayers; ++i)
    {
        cout << "Enter player name: ";
        cin >> name;
        names.push_back(name);
    }
    cout << endl;

    // игровой цикл
    Game aGame(names);
    char again = 'y';
    while (again != 'n' && again != 'N')
    {
        aGame.Play();
        cout << "\nDo you want to play again? (Y/N): ";
        cin >> again;
    }

    return 0;
}


В функции main() имена игроков помещаются в вектор, поскольку мы не знаем заранее, сколько человек будет играть. Этот вектор передается в качестве параметра конструктору класса Game.
Практические задания
Добавить в контейнерный класс, который был написан в этом уроке, методы:
для удаления последнего элемента массива (аналог функции pop_back() в векторах)
для удаления первого элемента массива (аналог pop_front() в векторах)
для сортировки массива
для вывода на экран элементов.
Дан вектор чисел, требуется выяснить, сколько среди них различных. Постараться использовать максимально быстрый алгоритм.
Реализовать класс Hand, который представляет собой коллекцию карт. В классе будет одно поле: вектор указателей карт (удобно использовать вектор, т.к. это по сути динамический массив, а тип его элементов должен быть - указатель на объекты класса Card). Также в классе Hand должно быть 3 метода:
метод Add, который добавляет в коллекцию карт новую карту, соответственно он принимает в качестве параметра указатель на новую карту
метод Clear, который очищает руку от карт
метод GetValue, который возвращает сумму очков карт руки (здесь предусмотреть возможность того, что туз может быть равен 11).

Дополнительные материалы
Бьерн Страуструп. Программирование. Принципы и практика использования С++.
Стивен Прата. Язык программирования С++. Лекции и упражнения.
Роберт Лафоре. Объектно-ориентированное программирование в С++.
Используемая литература
Для подготовки данного методического пособия были использованы следующие ресурсы:
Объектно-ориентированный анализ и проектирование с примерами приложений на С++. Отношения между классами.
Бьерн Страуструп. Программирование. Принципы и практика использования С++.
Ральф Джонсон, Ричард Хелм, Эрих Гамма. Приемы объектно-ориентированного программирования. Паттерны проектирования.

*/


// УРОК №5
//--------



/*
Совместное использование функций и методов
Перегрузка операторов. Шаблоны функций и классов. Явная и частичная специализация шаблонов. Примеры простых программ.

Перегрузка операторов инкремента и декремента
Перегрузка операторов инкремента и декремента версии постфикс
Шаблоны функций
Шаблоны классов
Параметр non-type шаблона
Явная специализация шаблона функции
Явная специализация шаблона класса
Частичная специализация шаблона
Частичная специализация шаблонов и указатели
Написание игры Blackjack
Практическое задание
Дополнительные материалы
Используемая литература
Перегрузка операторов инкремента и декремента
Перегрузка операторов инкремента (++) и декремента (−−) довольно проста, но есть нюанс. Есть две версии операторов инкремента и декремента: префикс (++x, --y) и постфикс (x++, y--).
Поскольку операторы инкремента и декремента являются унарными и изменяют свои операнды, то перегрузку следует выполнять через методы класса.
Перегрузка операторов инкремента и декремента версии префикс.
#include <iostream>
using namespace std;

class Day
{
private:
    int m_day;
public:
    Day(int day=1) : m_day(day)
    { }
    Day& operator++();
    Day& operator--();
    void getDay() { cout << m_day << endl;}
};

Day& Day::operator++()
{
    // Если значением переменной m_day является 32, то выполняем сброс на 1
    if (m_day == 32)
        m_day = 1;
    // в противном случае просто увеличиваем m_day на единицу
    else
        ++m_day;

    return *this;
}

Day& Day::operator--()
{
    // Если значением переменной m_day является 0, то присваиваем m_day значение 31
    if (m_day == 0)
        m_day = 8;
    // в противном случае просто уменьшаем m_day на единицу
    else
        --m_day;
    return *this;
}

int main()
{
    Number number(8);
    number.getNumber();
    (++number).getNumber();
    (--number).getNumber();
    return 0;
}
Day& Day::operator--()
{
    // Если значением переменной m_day является 0, то присваиваем m_day значение 31
    if (m_day == 0)
        m_day = 31;
    // в противном случае просто уменьшаем m_day на единицу
    else
        --m_day;
    return *this;
}

int main()
{
    Day day(31);
    day.getDay();
    (++day).getDay();
    (--day).getDay();
    return 0;
}

Результат выполнения программы:
31
1
31
Здесь класс Day содержит число от 1 до 31. Мы перегрузили операторы инкремента/декремента таким образом, чтобы они увеличивали/уменьшали m_day в соответствии с заданным диапазоном.
Обратите внимание, мы возвращаем скрытый указатель *this в функциях перегрузки операторов (то есть текущий объект класса Day). Таким образом мы можем связать выполнение нескольких операторов в одну «цепочку».
Перегрузка операторов инкремента и декремента версии постфикс
Операторы инкремента и декремента версии префикс и постфикс имеют одно имя, оба унарные и принимают один параметр одного и того же типа данных. Как же их различать при перегрузке?
C++ использует фиктивную переменную или фиктивный параметр для операторов версии постфикс. Этот фиктивный целочисленный параметр используется с одной целью: отличить версию постфикс операторов инкремента/декремента от версии префикс. Перегрузим префиксную и постфиксную версию операторов инкремента/декремента в том же классе:
#include <iostream>
using namespace std;

class Day
{
private:
    int m_day;
public:
    Day(int day=1) : m_day (day)
    { }

    Day& operator++();   // версия префикс
    Day & operator--();  // версия префикс

    Day operator++(int); // версия постфикс
    Day operator--(int); // версия постфикс

    void getDay() { cout << m_day << endl;}
};

//префиксная версия инкремента
Day & Day::operator++()
{
    if (m_day == 32)
        m_day = 1;
    else
        ++m_day;

    return *this;
}

//префиксная версия декремента
Day & Day::operator--()
{
    if (m_number == 0)
        m_number = 31;
    else
        --m_number;

    return *this;
}

// постфиксная версия инкремента
Day Day::operator++(int)
{
    // Создаем временный объект класса Day с текущим значением переменной m_day
    Day temp(m_day);

    // Используем оператор инкремента версии префикс для реализации перегрузки оператора инкремента версии постфикс
    ++(*this); // реализация перегрузки

    // возвращаем временный объект
    return temp;
}

// постфиксная версия декремента
Day Day::operator--(int)
{
    // Создаем временный объект класса Day с текущим значением переменной m_day
    Day temp(m_day);

    // Используем оператор декремента версии префикс для реализации перегрузки оператора декремента версии постфикс
    --(*this); // реализация перегрузки

    // возвращаем временный объект
    return temp;
}

int main()
{
    Day day(31);

    (day++).getDay();
    (day).getDay();
    (day--).getDay();
    (day).getDay();

    return 0;
}



Результат выполнения программы:
31
1
1
31
В данном коде:
Отделили версию постфикс от версии префикс, используя целочисленый фиктивный параметр в версии постфикс.
Поскольку фиктивный параметр не используется в реализации самой перегрузки, то мы даже не даем ему имя. Так что компилятор будет рассматривать эту переменную как простую заглушку (заполнитель места) и даже не будет предупреждать нас, что мы объявили переменную, но никогда ее не использовали.
Операторы версий префикс и постфикс выполняют одно задание — оба увеличивают/уменьшают значение переменной объекта. Разница между ними только в значении, которое они возвращают. Операторы версии префикс возвращают объект после того, как он был увеличен или уменьшен. В версии постфикс нам нужно возвращать объект до того, как он будет увеличен или уменьшен.
Поэтому мы использовали временный объект с текущим значением переменной-члена. Тогда можно будет увеличить/уменьшить исходный объект, а возвратить обратно временный.
Обратите внимание: это означает, что возврат значения по ссылке невозможен, так как мы не можем возвратить ссылку на локальную переменную, которая будет уничтожена после завершения выполнения тела функции. Также это означает, что операторы версии постфикс обычно менее эффективны, чем операторы версии префикс — из-за дополнительных расходов ресурсов на создание временного объекта и выполнения возврата по значению вместо возврата по ссылке
Наконец, мы реализовали перегрузку операторов версии постфикс через уже перегруженные операторы версии префикс. Таким образом сократили дублированный код и упростили внесение будущих изменений в класс, то есть поддержку кода.
Шаблоны функций
Шаблоны функций — это инструкции, согласно которым создаются локальные версии функции для определенного набора параметров и типов данных. Это мощный инструмент в С++, который упрощает разработку.
Например, нам нужно запрограммировать функцию, которая выводила бы на экран элементы массива. Задача несложная, но чтобы написать такую функцию, надо знать тип данных массива, который будем выводить на экран. А если тип данных не один? Мы хотим, чтобы функция выводила массивы типа int, double, float и char. Можно, конечно, перегрузить функцию, но тогда появится 4 версии одной функции, только с другими типами параметра. Есть способ решить эту проблему проще — использовать шаблоны.
Создадим шаблон функции, определяющий максимальное из двух чисел:
template <typename T>
T max(T a, T b)
{
    return (a > b) ? a : b;
}


Для объявления шаблона функции сначала пишется ключевое слово template, которое сообщает компилятору, что дальше мы будем объявлять параметры шаблона. Они указываются в угловых скобках (<>). Для создания типов параметров шаблона используются ключевые слова typename и class. В базовых случаях использования шаблонов функций разницы между typename и class нет, поэтому можете выбрать любое. Если используете ключевое слово class, то фактический тип параметров не обязательно должен быть классом. Затем называем тип параметра шаблона (обычно «T», сокращенно от Type, что говорит о том, что это может быть любой тип данных). Если требуется несколько типов параметров шаблона, то они разделяются запятыми: template <typename T1, typename T2>.
Поскольку тип аргумента функции, передаваемый в тип T, может быть классом, а классы, как правило, не рекомендуется передавать по значению, то лучше сделать параметры и возвращаемое значение нашего шаблона функции константными ссылками. Тогда предыдущая функция перепишется следующим образом:
#include <iostream>
using namespace std;

template <typename T>
const T& t_max(const T& a, const T& b)
{
    return (a > b) ? a : b;
}


Использовать шаблоны функций можно так же, как и обычные функции:
int main()
{
    int i = t_max(4, 8);
    cout << i << '\n';

    double d = t_max(7.56, 21.434);
    cout << d << '\n';

    char ch = t_max('b', '9');
    cout << ch << '\n';

    return 0;
}

Результат выполнения программы:
8
21.434
B
Поскольку все три вызова функции t_max() имеют параметры разных типов, то компилятор создаст 3 экземпляра шаблона функции для каждого типа данных. Шаблоны функций работают как с фундаментальными типами данных (char, int, double и другими), так и с классами. Экземпляр шаблона компилируется как обычная функция. В обычной функции любые операторы или вызовы других функций, которые используются в ней, должны быть определены/перегружены — иначе вы получите ошибку компиляции. Аналогично, любые операторы или вызовы других функций, которые присутствуют в шаблоне функции, должны быть определены/перегружены для работы с передаваемыми типами данных.

Рассмотрим пример:
#include <iostream>
using namespace std;

template <typename T>
const T& t_max(const T& a, const T& b)
{
    return (a > b) ? a : b;
}

class Day
{
private:
    int m_day;
public:
    Day(int day) : m_day(day)
    { }
    // перегружаем оператор >
    friend bool operator>(const Day &d1, const Day &d2)
    {
        return (d1.m_day > d2.m_day);
    }
};
int main()
{
    Day seven(7);
    Day twelve(12);

    Day bigger = t_max(seven, twelve);

    return 0;
}


Чтобы использовать шаблон функции, необходимо перегрузить оператор сравнения для класса Dollars. После перегрузки можем спокойно использовать шаблон функции.
Обратите внимание: стандартная библиотека C++ имеет в своем арсенале шаблон функции max(), который находится в заголовочном файле algorithm. Поэтому вы можете не реализовывать эту функцию вручную в будущем. Данный шаблон функции находится в стандартном пространстве имен (namespace std;) — именно поэтому мы создали функцию t_max(), а не просто max().
Шаблоны классов
На предыдущем уроке мы создавали динамический массив-класс целых чисел. Чтобы реализовать такой класс для вещественных чисел типа float или double, идеальным решением будет добавить шаблон класса.
template <class T> // шаблон класса
class Array
{
private:
    int m_length;
    T *m_data;

public:
    Array()
    {
        m_length = 0;
        m_data = nullptr;
    }

    Array(int length)
    {
        m_data = new T[length];
        m_length = length;
    }

    ~Array()
    {
        delete[] m_data;
    }

    void Erase()
    {
        delete[] m_data;
        // Указываем m_data значение nullptr, чтобы на выходе не получить висячий указатель!
        m_data = nullptr;
        m_length = 0;
    }


    T& operator[](int index)
    {
        assert(index >= 0 && index < m_length);
        return m_data[index];
    }

    int getLength(); // определяем метод и шаблон метода getLength() ниже
};

// метод, определенный вне тела класса, нуждается в собственном определении шаблона метода
template <typename T>
int Array<T>::getLength() { return m_length; }
// обратите внимание, имя класса - Array<T>, а не просто Array


Эта версия почти идентична версии ArrayInt, за исключением того, что мы добавили объявление параметра шаблона класса и изменили тип данных на T.
Обратите внимание: мы определили функцию getLength() вне тела класса. Это необязательно, просто привели для примера — так как каждый метод шаблона класса, объявленный вне тела класса, нуждается в собственном объявлении шаблона. Имя шаблона класса — Array<T>.
Создавать экземпляры шаблона класса нужно таким образом:
Array<int> intArray(10);
Array<double> doubleArray(10);
Шаблоны классов работают так же, как и шаблоны функций: компилятор копирует шаблон класса, заменяя типы параметров шаблона класса на фактические (передаваемые) типы данных, а затем компилирует эту копию. Если у вас есть шаблон класса, но вы его не используете, то компилятор не будет его даже компилировать.
Шаблоны классов идеально подходят для реализации контейнерных классов, так как очень часто таким классам приходится работать с разными типами данных, а шаблоны позволяют это организовать в минимальном количестве кода. Рассмотренный на прошлом уроке std::vector — это шаблон класса. В стандартной библиотеке С++ много предопределенных шаблонов классов, доступных для использования.
Параметр non-type шаблона
Параметр non-type шаблона — это специальный параметр шаблона, который заменяется не типом данных, а конкретным значением. Этим значением может быть:
целочисленное значение или перечисление;
указатель или ссылка на объект класса;
указатель или ссылка на функцию;
указатель или ссылка на метод класса.
Например, для создания статического массива-класса необходим еще один параметр — длина массива. Этот параметр передается в шаблон класса:
template <class T, int size> // size является параметром non-type шаблона класса
class StaticArray
{
private:
    // параметр non-type шаблона класса отвечает за размер выделяемого массива
    T m_array[size];
    ...
}

Экземпляр класса будет создаваться следующим выражением:
StaticArray<int, 10>.
Данный класс известен из стандартной библиотеки С++ - std::array.
Явная специализация шаблона функции
При создании экземпляра шаблона функции для определенного типа данных компилятор копирует шаблон функции и заменяет параметр типа шаблона функции на передаваемый тип данных. Это означает, что все экземпляры функции имеют одну реализацию, но разные типы данных. Хотя в большинстве случаев это именно то, что требуется, иногда может понадобиться, чтобы реализация шаблона функции для одного типа данных отличалась от реализации для другого.
Специализация шаблонов именно для этого и предназначена.
Рассмотрим следующий шаблон класса:
#include <iostream>
using namespace std;

template <class T>
class Day
{
private:
    T m_day;
public:
    Day(T day)
    {
        m_day = day;
    }

    ~Day()
    { }

    void print()
    {
        cout << m_day << '\n';
    }
};


Теоретически данный класс может работать со многими типами данных (хотя этого может и не требоваться). Но что, если мы попытаемся использовать шаблон класса с типом данных char*? При создании экземпляра шаблона для типа char*, конструктор Day<char*> присвоит переменной m_day указатель day. Тогда функция print() выведет на экран значение указателя, а не сам текст. Чтобы решить эту проблему, используем явную специализацию шаблона класса:
template <>
Day<char*>::Day(char* day)
{
    // Определяем длину day
    int length=0;
    while (day[length] != '\0')
        ++length;
    ++length; // +1, учитывая нуль-терминатор

    // Выделяем память для хранения значения day
    m_day = new char[length];

    // Копируем фактическое значение day в m_day
    for (int count=0; count < length; ++count)
        m_day[count] = day[count];
}

template <>
Repository<char*>::~Repository()
{
    delete[] m_day;
}


Теперь при выделении переменной типа Day<char*> именно этот конструктор будет использоваться вместо стандартного. Чтобы избежать утечки памяти для типа char* используем деструктор, поскольку m_day не будет удален, когда переменная day выйдет из области видимости. Теперь, когда переменные типа Day<char*> выйдут из области видимости, память, выделенная в специальном конструкторе, будет удалена в специальном деструкторе.
Хотя во всех примерах выше мы работаем с методами класса, вы также можете аналогично выполнять явную специализацию шаблонов обычных функций.
Явная специализация шаблона класса
Специализация шаблона класса позволяет специализировать шаблон класса для работы с определенным типом данных (или сразу несколькими, если описано несколько параметров шаблона).
Специализация шаблона класса рассматривается компилятором как полностью отдельный и независимый класс, хотя и выделяется как обычный шаблон класса. Это означает, что мы можем изменить в классе что угодно, включая его реализацию, методы, спецификаторы доступа.
Рассмотрим класс-массив, который может хранить 8 дней:
template <class T>
class Day
{
private:
    T m_day[8];

public:
    void set(int index, const T &day)
    {
        m_day[index] = day;
    }

    const T& get(int index)
    {
        return m_day[index];
    }
};


Существуют классы, в которых переменная-член имеет тип данных bool. Для него эффективнее реализовать хранение переменных не в массиве (на что будет потрачено 8 байт), а в переменной типа unsigned char. Тогда на каждое значение bool-переменной будет уходить только по одному биту. В связи с вышесказанным потребуется отдельная специализация для типа данных bool.
Частичная специализация шаблона
Частичная специализация шаблона позволяет выполнить специализацию шаблона класса (но не функции), где некоторые параметры шаблона явно определены. Это называется частичной специализацией, потому что специализация шаблона происходит не по всем аргументам. Рассмотрим шаблон класса и его частичную специализацию:
// шаблон класса
template< typename T, typename S > class B {};
// его частичная специализация
template< typename U > class B< int, U > {};


В данном примере шаблонный класс с двумя параметрами специализируется только по одному из них. Специализация будет работать, когда первый аргумент, T, будет указан как int. При этом второй аргумент может быть любым — для этого в частичной специализации введен новый параметр U и указан в списке аргументов для специализации.
Чтобы выполнить частичную специализацию метода класса, можно сделать частичную специализация шаблона всего класса:
template <class T, int size>
class StaticArray
{
// реализация класса StaticArray
};

// частичная специализация шаблона класса
template <int size>
class StaticArray<double, size>
{
// реализация частично специализированного шаблона класса
};


Но в данном случае частично специализированный шаблон класса будет во многом дублировать код основного шаблона класса. Это проблема, которую можно решить путем наследования. Для это необходимо создать общий родительский класс:
// шаблон базового класса
template <class T, int size>
class StaticArray_Base
{
// реализация класса StaticArray_Base
};

// шаблон производного класса
template <class T, int size>
class StaticArray: public StaticArray_Base<T, size>
{
// полностью наследует функционал StaticArray_Base,
// собственные методы не нужны
};

// частично специализированный шаблон класса для типа double
template <int size>
class StaticArray<double, size>: public StaticArray_Base<double, size>
{
// реализация частично специализированного шаблона класса
};

В данном примере дублирование кода не происходит, а функционал остается прежним.
Отметим, что частичная специализация шаблонов нашла свое применение в основном при создании библиотек: stl, boost, loki и других. В библиотеках частичная специализация позволяет относительно просто реализовывать делегаты, события, сложные контейнеры и другие нужные и полезные вещи.
Частичная специализация шаблонов и указатели
В предыдущей части урока мы рассматривали пример с шаблоном класса Day и создавали полную специализацию этого шаблона для указателя типа char*. Но что, если потребуется использовать указатели и на другие типы — например, int*? Если не написать полную специализацию шаблона и для других типов указателей, программа не будет работать правильно, но получится много дублирующего кода. Выход из этой ситуации — объявить частичную специализацию шаблона класса Day, которая работала бы со всеми типами указателей.
#include <iostream>
using namespace std;

// Общий шаблон класса Day
template <class T>
class Day
{
private:
    T m_day;
public:
    Day(T day)
    {
        m_day = day;
    }

    ~Day()
    { }

    void print()
    {
        cout << m_day << '\n';
    }
};

// частичная специализация шаблона класса Day для работы с типами указателей
template <typename T>
class Day<T*>
{
private:
    T* m_day;
public:
    Day(T* day) // T - тип указателя
    {
        // Выполняем глубокое копирование
        m_day = new T(*day); // здесь копируется только одно отдельное значение
    }
    ~Day()
    {
        delete m_day; // а здесь выполняется удаление этого значения
    }

    void print()
    {
        cout << *m_day << '\n';
    }
};


Поскольку в нашей частичной специализации копируется только одно значение, то при работе со строками C-style копироваться будет только первый символ (так как строка — это массив, а указатель на массив указывает только на первый его элемент). Если же нужно скопировать целую строку, то специализация конструктора (и деструктора) для типа char* должна быть полной. В таком случае полная специализация будет иметь приоритет выше, чем частичная. Рассмотрим программу, в которой используется как частичная специализация для работы с типами указателей, так и полная специализация для работы с типом char*:
#include <iostream>
#include <cstring>
using namespace std;
// Общий шаблон класса Day для работы не с указателями
template <class T>
class Day
{
private:
    T m_day;
public:
    Repository(T day)
    {
        m_day = day;
    }

    ~Day()
    { }

    void print()
    {
        cout << m_day << '\n';
    }
};

// Частичная специализация шаблона класса Day для работы с указателями
template <class T>
class Day<T*>
{
private:
    T* m_day;
public:
    Day(T* day)
    {
        m_day = new T(*day);
    }

    ~Day ()
    {
        delete m_day;
    }

    void print()
    {
        cout << *m_day << '\n';
    }
};
}
// Полная специализация шаблона конструктора класса Day для работы с типом char*
template <>
Day<char*>::Day(char* day)
{
    // Определяем длину day
    int length = 0;
    while (day[length] != '\0')
        ++length;
    ++length; // +1, учитывая нуль-терминатор

    // Выделяем память для хранения значения day
    m_day = new char[length];



    // Копируем фактическое значение day в m_day
    for (int count = 0; count < length; ++count)
        m_day[count] = day[count];
}

// Полная специализация шаблона деструктора класса Day для работы с типом char*
template<>
/day<char*>::~Day()
{
    delete[] m_day;
}

// Полная специализация шаблона метода print для работы с типом char*
// Без этого вывод Day<char*> привел бы к вызову Day<T*>::print(), которое выводит только одно значение (в случае со строкой C-style - только первый символ)
template<>
void Day<char*>::print()
{
    cout << m_day;
}

int main()
{
    // Объявляем целочисленный объект для проверки работы общего шаблона класса
    Day<int> myDay(6);
    myDay.print();

    // Объявляем объект с типом указателя для проверки работы частичной специализации шаблона
    int x = 8;
    Dy<int*> myintptr(&x);

    // Если бы в myintptr выполнилось поверхностное копирование (присваивание указателя),
    // то изменение значения x изменило бы и значение myintptr
    x = 10;
    myintptr.print();

    // Динамически выделяем временную строку
    char *day = new char[40]{ "First" };

    // Сохраняем число
    Day<char*> myDay(day);

    // Удаляем временную строку
    delete[] name;

    // Выводим имя
    myname.print();
}
    // Удаляем временную строку
    delete[] day;

    // Выводим имя
    myDay.print();
}


Результат выполнения программы:
6
8
First
Таким образом, использование частичной специализации шаблона класса для работы с типами указателей особенно полезно, так как позволяет предусмотреть все возможные варианты использования программы на практике.
Написание игры Blackjack
На этом уроке создадим карту и колоду карт. Предлагаем масти карт и их достоинства оформить в виде перечисления, чтобы легче с ними работать:
enum rank {
        ACE = 1, TWO, THREE, FOUR, FIVE, SIX, SEVEN, EIGHT, NINE, TEN,
        JACK, QUEEN, KING
    };
enum suit { CLUBS, DIAMONDS, HEARTS, SPADES };


У класса Card есть метод, который переворачивает карту. В программе это будет реализовано с помощью переменной типа bool, где значению false соответствует карта, перевернутая рубашкой вверх, а  значению true — рубашкой вниз.
void Card::Flip()
{
    m_IsFaceUp = !(m_IsFaceUp);
}


У класса Card также есть метод, который возвращает значение карты. Но оно доступно только в том случае, когда карта перевернута лицом вверх:
int Card::GetValue() const
{
    //если карта перевернута лицом вниз, ее значение равно О
    int value = 0;
    if (m_IsFaceUp)
    {
        // значение - это число, указанное на карте
        value = m_Rank;
        // значение равно 10 для JACK, QUEEN и KING
        if (value > 10)
        {
            value = 10;
        }
    }
    return value;
}


Класс Card:
class Card
{
public:
    enum rank {
        ACE = 1, TWO, THREE, FOUR, FIVE, SIX, SEVEN, EIGHT, NINE, TEN,
        JACK, QUEEN, KING
    };
    enum suit { CLUBS, DIAMONDS, HEARTS, SPADES };

    Card(rank r = ACE, suit s = SPADES, bool ifu = true);
    int GetValue() const;
    void Flip();

private:
    rank m_Rank;
    suit m_Suit;
    bool m_IsFaceUp;
};

Card::Card(rank r, suit s, bool ifu) : m_Rank(r), m_Suit(s), m_IsFaceUp(ifu)
{}

int Card::GetValue() const
{
    int value = 0;
    if (m_IsFaceUp)
    {
        value = m_Rank;
        if (value > 10)
        {
            value = 10;
        }
    }
    return value;
}

void Card::Flip()
{
    m_IsFaceUp = !(m_IsFaceUp);
}


Теперь займемся классом Hand. Этот класс представляет собой коллекцию карт. Его конструктор резервирует в векторе m_Cards место в памяти под 7 элементов. Метод Add() добавляет новую карту в вектор. А метод Clear() очищает всю память, занятую вектором.
class Hand
{
public:
    Hand();
    // виртуальный деструктор
    virtual ~Hand();

    // добавляет карту в руку
    void Add(Card* pCard);

    // очищает руку от карт
    void Clear();

    //получает сумму очков карт в руке, присваивая тузу
    // значение 1 или 11 в зависимости от ситуации
    int GetTotal() const;

protected:
    vector<Card*> m_Cards;
};

Hand::Hand()
{
    m_Cards.reserve(7);
}
// деструктор по-прежнему виртуальный
// это уже можно не обозначать
Hand::~Hand()
{
    Clear();
}

void Hand::Add(Card* pCard)
{
    m_Cards.push_back(pCard);
}

void Hand::Clear()
{
    // проходит по вектору, освобождая всю память в куче
    vector<Card*>::iterator iter = m_Cards.begin();
    for (iter = m_Cards.begin(); iter != m_Cards.end(); ++iter)
    {
        delete *iter;
        *iter = 0;
    }
    // очищает вектор указателей
    m_Cards.clear();
}

Метод Clear() удаляет не только все указатели из вектора m_Cards, но и связанные объекты типа Card и освобождает занятую ими память. Это работает так же, как в реальном мире, когда в конце кона карты сбрасываются. Виртуальный деструктор вызывает этот метод.
Обратите внимание: хотя деструктор виртуальный, ключевое слово virtual не используется за пределами класса, а только внутри его определения.

Теперь представим реализацию метода GetTotal():
int Hand::GetTotal() const
{
    // если карт в руке нет, возвращает значение 0
    if (m_Cards.empty())
    {
        return 0;
    }

    //если первая карта имеет значение 0, то она лежит рубашкой вверх:
    // вернуть значение 0
    if (m_Cards[0]->GetValue() == 0)
    {
        return 0;
    }

    // находит сумму очков всех карт, каждый туз дает 1 очко
    int total = 0;
    vector<Card*>::const_iterator iter;
    for (iter = m_Cards.begin(); iter != m_Cards.end(); ++iter)
    {
        total += (*iter)->GetValue();
    }

    // определяет, держит ли рука туз
    bool containsAce = false;
    for (iter = m_Cards.begin(); iter != m_Cards.end(); ++iter)
    {
        if ((*iter)->GetValue() == Card::ACE)
        {
            containsAce = true;
        }
    }

    // если рука держит туз и сумма довольно маленькая, туз дает 11 очков
    if (containsAce && total <= 11)
    {
        // добавляем только 10 очков, поскольку мы уже добавили
        // за каждый туз по одному очку
        total += 10;
    }

    return total;
}

Данный метод возвращает сумму очков для карт в руке. Если рука держит туз, он считается за 1 или 11 очков в зависимости от остальных карт. Количество очков, которое дает туз, определяется так: если в руке есть туз, он дает 11 очков; затем выполняется проверка, превышает ли сумма очков карт в руке число 21. Если нет — количество очков, которое дает туз, не изменяется. В противном случае туз даст 1 очко.
Практическое задание
Реализовать шаблон класса Pair1, который позволяет пользователю передавать данные одного типа парами.
Следующий код:
int main()
{
    Pair1<int> p1(6, 9);
    cout << "Pair: " << p1.first() << ' ' << p1.second() << '\n';

    const Pair1<double> p2(3.4, 7.8);
    cout << "Pair: " << p2.first() << ' ' << p2.second() << '\n';

    return 0;
}


… должен производить результат:
Pair: 6 9
Pair: 3.4 7.8
Реализовать класс Pair, который позволяет использовать разные типы данных в передаваемых парах.
Следующий код:
int main()
{
    Pair<int, double> p1(6, 7.8);
    cout << "Pair: " << p1.first() << ' ' << p1.second() << '\n';

    const Pair<double, int> p2(3.4, 5);
    cout << "Pair: " << p2.first() << ' ' << p2.second() << '\n';

    return 0;
}


… должен производить следующий результат:
Pair: 6 7.8
Pair: 3.4 5
Подсказка: чтобы определить шаблон с использованием двух разных типов, просто разделите параметры типа шаблона запятой.
Написать шаблон класса StringValuePair, в котором первое значение всегда типа string, а второе — любого типа. Этот шаблон класса должен наследовать частично специализированный класс Pair, в котором первый параметр — string, а второй — любого типа данных.

Следующий код:
int main()
{
    StringValuePair<int> svp("Amazing", 7);
    std::cout << "Pair: " << svp.first() << ' ' << svp.second() << '\n';
    return 0;
}


… должен производить следующий результат:
Pair: Amazing 7
Подсказка: при вызове конструктора класса Pair из конструктора класса StringValuePair не забудьте указать, что параметры относятся к классу Pair.

Согласно иерархии классов, которая представлена в методичке к уроку 3, от класса Hand наследует класс GenericPlayer, который обобщенно представляет игрока, ведь у нас будет два типа игроков - человек и компьютер. Создать класс GenericPlayer, в который добавить поле name - имя игрока. Также добавить 3 метода:
IsHitting() - чисто виртуальная функция, возвращает информацию, нужна ли игроку еще одна карта.
IsBoosted() - возвращает bool значение, есть ли у игрока перебор
Bust() - выводит на экран имя игрока и объявляет, что у него перебор.


Дополнительные материалы
Бьерн Страуструп. Программирование. Принципы и практика использования С++.
Стивен Прата. Язык программирования С++. Лекции и упражнения.
Роберт Лафоре. Объектно-ориентированное программирование в С++.
Используемая литература
Для подготовки данного методического пособия были использованы следующие ресурсы:
Онлайн-справочник программиста на C и C++. Перегрузка.
Бьерн Страуструп. Программирование. Принципы и практика использования С++.
Ральф Джонсон, Ричард Хелм, Эрих Гамма. Приемы объектно-ориентированного программирования. Паттерны проектирования.

*/


// УРОК №6
//--------



/*
Потоки ввода-вывода
Иерархия потоковых классов. Операции ввода-вывода для стандартных типов. Организация ввода-вывода для пользовательских типов. Работа с файлами и буферами в памяти. Средства форматирование вывода. Манипуляторы.

Старая и новая системы ввода-вывода
Потоки в С++
Потоковые классы
Функциональность класса istream
Функциональность класса ostream
Потоковые классы и строки
Перегрузка оператора вывода
Перегрузка оператора ввода
Написание игры Blackjack
Практическое задание
Дополнительные материалы
Используемая литература


Старая и новая системы ввода-вывода
Есть две версии объектно-ориентированной библиотеки ввода-вывода С++. Старая библиотека поддерживается заголовочным файлом <iostream.h>. Новая —заголовком <iostream>. Библиотеки с точки зрения программиста в целом одинаковые, просто новая — модернизированная и улучшенная версия старой. Большая часть различий лежит под поверхностью и определяется тем, как библиотека реализована.
Новая библиотека является надмножеством старой, и все программы, написанные для старой библиотеки, будут компилироваться без существенных изменений, если использовать новую библиотеку. Она находится в пространстве имен std, в то время как старая — в глобальном пространстве имен.
Потоки в С++
Система ввода-вывода С++ оперирует над потоками. Поток является абстрактным объектом, который либо создает, либо поглощает информацию. Поток связывается с физическим устройством посредством системы ввода-вывода. Все потоки ведут себя одинаково, одни и те же функции и операторы ввода-вывода применимы практически ко всем типам устройств. Например, метод, с помощью которого выводятся данные на экран, можно использовать для записей данных на диск или печати на принтере.
В наиболее общей форме поток — это логический интерфейс с файлом. Согласно определению в С++, термин «файл» может относиться к клавиатуре, порту, файлу и так далее. Поток в данном случае обеспечивает единообразный интерфейс.
Чтение данных из потока называется извлечением, вывод в поток — помещением или включением. Поток определяется как последовательность байтов и не зависит от конкретного устройства, с которым производится обмен. Обмен с потоком для увеличения скорости передачи данных происходит, как правило, через специальную область данных — буфер.
По направлению обмена потоки можно разделить на входные, где данные вводятся в память, и двунаправленные, допускающие как извлечение, так и включение.
По виду устройств, с которыми работает поток, можно выделить:
стандартные потоки — предназначены для передачи данных от клавиатуры и на экран;
файловые потоки — для обмена информацией с файлами на внешних устройствах;
строковые потоки — для работы с массивами символов.
Потоковые классы
Библиотека потоковых классов С++ построена на основе двух базовых классов: ios и streambuf .
Класс streambuf обеспечивает организацию и взаимосвязь буферов ввода-вывода, размещаемых в памяти, с физическими устройствами ввода-вывода. Методы и данные класса streambuf программист явно обычно не использует. Этот класс нужен другим классам библиотеки ввода-вывода. Он доступен и программисту для создания новых классов на основе уже существующих.

Класс ios содержит средства для форматированного ввода-вывода и проверки ошибок.

Стандартные потоки (istream, ostream, iostream) служат для работы с терминалом. Строковые потоки (istrstream, ostrstream, strstream) служат для ввода-вывода из строковых буферов, размещенных в памяти. Файловые потоки (ifstream, ofstream, fstream ) служат для работы с файлами.
Рассмотрим их более подробно:
ios — базовый потоковый класс;
streambuf — буферизация потоков;
istream — потоки ввода;
ostream — потоки вывода;
iostream — двунаправленные потоки;
istrstream — строковые потоки ввода;
ostrstream — строковые потоки вывода;
strstream — двунаправленные строковые потоки;
ifstream — файловые потоки ввода;
ofstream — файловые потоки вывода;
fstream — двунаправленные файловые потоки.
Хотя класс ios является дочерним классу ios_base. Часто именно он будет наиболее родительским классом, с которым вы будете работать напрямую. Класс ios определяет много разных вещей, которые являются общими для потоков ввода/вывода.
Класс istream используется для работы с входными потоками. Оператор извлечения >> используется для получения значений из потока. Это имеет смысл, когда пользователь нажимает на клавишу клавиатуры, код этой клавиши помещается во входной поток. Затем программа извлекает это значение из потока и использует его.
Класс ostream используется для работы с выходными потоками. Оператор вставки << используется для помещения значений в поток, а затем потребитель данных (например, монитор) использует их.
Класс iostream может обрабатывать как ввод, так и вывод данных, что позволяет ему осуществлять двунаправленный ввод/вывод.
Стандартный поток — это предварительно подключенный поток, который предоставляется программе ее окружением. C++ поставляется с четырьмя предварительно определенными стандартными объектами потоков, которые вы можете использовать.
Следующие объекты-потоки заранее определены и открыты в программе перед вызовом функции main:
extern istream cin;  // Стандартный поток ввода с клавиатуры
extern ostream cout; // Стандартный поток вывода на экран
extern ostream cerr; // Стандартный небуферизованный поток вывода сообщений об ошибках (экран)
extern ostream clog; // Стандартный буферизованный поток вывода
// сообщений об ошибках (экран)

Небуферизованный вывод обычно обрабатывается сразу же, а буферизованный сохраняется и выводится как блок. Поскольку clog используется редко, то его обычно игнорируют.
Приведем пример их использования:
#include <iostream>
#include <cstdlib> // для exit()
using namespace std;

int main()
{
    // Сначала мы используем оператор вставки с объектом cout для вывода текста на монитор
    cout << "Enter your age: " << endl;

    // Затем — оператор извлечения с объектом cin для получения пользовательского ввода
    int age;
    cin >> age;
    if (age <= 0)
    {
    // В этом случае мы используем оператор вставки с объектом cerr для вывода сообщения об ошибке
        cerr << "Oops, you entered an invalid age!" << endl;
        exit(1);
    }
    // А здесь мы используем оператор вставки с объектом cout для вывода результата
    cout << "You entered " << age << " years old" << endl;
    return 0;
}

Потоковые классы, их методы и данные становятся доступными в программе, если в нее включен нужный заголовочный файл:
iostream.h — для ios, ostream, istream .
strstream.h — для strstream, istrstream, ostrstream .
fstream.h — для fstream, ifstream, ofstream.
Функциональность класса istream
Библиотека iostream довольно сложная, поэтому мы не сможем охватить ее полностью на уроках. Рассмотрим ее основную функциональность. В этом уроке разберемся с классом istream.
Одной из наиболее распространенных проблем при считывании строк из входного потока является переполнение — например, если мы выделили символьный массив на 10 символов, а пользователь введет 20, произойдет переполнение. Чтобы избежать этой ситуации, используют манипуляторы.  Это объекты, которые применяются для изменения потока данных с использованием операторов извлечения (>>) или вставки (<<).
Мы уже работали с одним из манипуляторов — endl, который одновременно выводит символ новой строки и удаляет текущие данные из буфера. C++ предоставляет еще один манипулятор — setw (из заголовочного файла iomanip), который используется для ограничения количества символов, считываемых из потока. Для использования setw() вам нужно просто передать в качестве параметра максимальное количество символов для извлечения и вставить вызов этого манипулятора следующим образом:
#include <iostream>
#include <iomanip>
using namespace std;

int main()
{
    char name[12];
    cin >> setw(12) >> name;
}

Эта программа теперь прочитает только первые 11 символов из входного потока (+ один символ для нуль-терминатора). Все остальные символы останутся в потоке до следующего извлечения.
Важный момент — оператор извлечения работает с «отформатированными» данными, то есть он игнорирует все пробелы, символы табуляции и новой строки.
Часто пользовательский ввод все же нужен со всеми его пробелами. Для этого класс istream предоставляет множество функций. Одной из наиболее полезных является функция get(), которая извлекает символ из входного потока.
#include <iostream>
using namespace std;

int main()
{
    char fio;
    while (cin.get(fio))
        cout << fio;
    return 0;
}


Функция get() также имеет строковую версию, в которой можно указать максимальное количество символов для извлечения.
#include <iostream>
using namespace std;
int main()
{
    char fio[30];
    cin.get(fio, 30);
    cout << fio << endl;
    return 0;
}

Один важный нюанс: get() не считывает символ новой строки! Для решения этой проблемы класс istream предоставляет функцию getline(), которая работает так же, как get(), но при этом может считывать символы новой строки.
Если вам нужно узнать количество символов, извлеченных последним getline(), используйте функцию gcount(). Для вывода количества символов после использования cin.getline() можно применять следующую строчку:
cout << cin.gcount();
Есть специальная версия getline(), которая находится вне класса istream и используется для считывания переменных типа std::string. Эта специальная версия getline() не является членом ни ostream, ни istream, а подключается заголовочным файлом string. Например:
#include <iostream>
#include <string>
using namespace std;

int main()
{
    string fio;
    getline(cin, fio);
    cout << fio << endl;
    return 0;
}


Есть еще несколько полезных функций класса istream, которые вы можете использовать:
Метод
Описание
ignore()
Метод извлекает один символ из потока istream и игнорирует его
ignore(streamsize  count)
Метод извлекает count-символ из потока istream и игнорирует его
ignore(streamsize  count, char  delim)
Метод извлекает count-символ из потока istream и игнорирует его. Метод прекращает работу, если в потоке встречается символ delim
peek()
Метод возвращает следующий символ потока без реального чтения его из потока istream
unget()
Метод помещает в поток последний считанный символ таким образом, что его можно прочитать следующей операцией чтения


Функциональность класса ostream
Оператор вставки (вывода) << используется для помещения информации в выходной поток. Классы istream и ostream — дочерние классу ios. Одной из задач ios (и ios_base) является управление параметрами форматирования вывода.
Есть два способа управления параметрами форматирования вывода:
флаги — это логические переменные, которые можно включать/выключать;
манипуляторы — это объекты, которые помещаются в поток и влияют на способ ввода/вывода данных.
В классе ios содержится состояние формата, которое управляется функциями flags() и setf(). По сути, эти функции нужны, чтобы установить или отменить следующие флаги:

Конкретные значения флагов зависят от реализации и даны здесь только для того, чтобы избежать синтаксически неверных конструкций. Определение интерфейса как набора флагов и операций для их установки или отмены — это прошедший проверку временем, хотя и устаревший прием.
Чтобы включить флаг, используйте функцию setf() с соответствующим флагом в качестве параметра. Например, по умолчанию C++ не выводит знак + перед положительными числами. Но используя флаг std::showpos, мы можем это изменить:
#include <iostream>
using namespace std;
int main()
{
    cout.setf(ios::showpos); // включаем флаг showpos
    cout << 30;
}

Результат работы программы: +30.
Чтобы отключить флаг, используйте функцию unsetf().
Многие флаги принадлежат к определенным группам форматирования — группам флагов, выполняющих аналогичные (иногда взаимоисключающие) параметры форматирования вывода.
Флаги группы форматирования basefield:
oct («octal» = «восьмеричный») — восьмеричная система счисления;
dec («decimal» = «десятичный») — десятичная система счисления;
hex («hexadecimal» = «шестнадцатеричный») — шестнадцатеричная система счисления.
Эти флаги управляют выводом целочисленных значений. По умолчанию установлен флаг dec, то есть значения выводятся в десятичной системе счисления. Чтобы число вывести в шестнадцатеричной системе, нужно сначала отключить флаг dec, а затем включить флаг hex. Есть и другой способ: можно функции setf() передать два параметра: первый — это флаг, который нужно включить/выключить, второй — группа форматирования, к которой принадлежит флаг.
Запись будет выглядеть так:
cout.setf(ios::hex, ios::basefield);


Помимо флагов можно использовать и манипуляторы:
cout << hex << 30;

Применять манипуляторы гораздо проще, нежели включать/выключать флаги. Многие параметры форматирования можно изменять как через флаги, так и через манипуляторы. Но есть и такие параметры, которые изменить можно либо только через флаги, либо только через манипуляторы.
Рассмотрим список наиболее полезных флагов, манипуляторов и методов. Флаги находятся в классе ios, манипуляторы — в пространстве имен std, а методы — в классе ostream.
Флаг
Манипулятор
boolalpha — если включен, то логические значения выводятся как «true/false». Если выключен, то как «0/1».


boolalpha — логические значения выводятся как «true/false».
noboolalpha — логические значения выводятся как «0/1».
showpos — если включен, то к положительным числам прибавляется знак +.


showpos — к положительным числам прибавляется знак +.
noshowpos — к положительным числам не прибавляется знак +.
uppercase — если включен, то используются заглавные буквы.
uppercase — используются заглавные буквы.
nouppercase — используются строчные буквы.
dec — значения выводятся в десятичной системе счисления.
hex — значения выводятся в шестнадцатеричной системе счисления.
oct — значения выводятся в восьмеричной системе счисления.
dec — значения выводятся в десятичной системе счисления.
hex — значения выводятся в шестнадцатеричной системе счисления.
oct — значения выводятся в восьмеричной системе счисления.
fixed — используется десятичная запись чисел типа с плавающей запятой.
scientific — используется экспоненциальная запись чисел типа с плавающей запятой.
showpoint — всегда отображается десятичная точка и конечные нули для чисел типа с плавающей запятой.
fixed — используется десятичная запись значений.
scientific — используется экспоненциальная запись значений.
showpoint — отображается десятичная точка и конечные нули чисел типа с плавающей запятой.
noshowpoint — не отображаются десятичная точка и конечные нули чисел типа с плавающей запятой.
setprecision(int) — задаем точность для чисел типа с плавающей запятой.
internal — знак значения выравнивается по левому краю, а само значение — по правому краю.
left — значение и его знак выравниваются по левому краю.
right — значение и его знак выравниваются по правому краю.
internal — знак значения выравнивается по левому краю, а само значение — по правому краю.
left — значение и его знак выравниваются по левому краю.
right — значение и его знак выравниваются по правому краю.
setfill(char) — задаем символ-заполнитель.
setw(int) — задаем ширину поля.

Попробуйте использовать данные флаги и манипуляторы.
Для использования манипуляторов необходимо подключить заголовочный файл <iomanip>.
Потоковые классы и строки
В стандартной библиотеке С++ есть отдельный набор классов, которые позволяют использовать операторы вставки (<<) и извлечения (>>) со строками. Как istream и ostream, потоковые классы для строк предоставляют буфер для хранения данных. Но в отличие от cin и cout, эти потоковые классы не подключены к каналу ввода/вывода (то есть к клавиатуре, монитору и так далее).
Есть 6 потоковых классов, которые используются для чтения и записи строк:
   istringstream (дочерний классу istream);
   ostringstream (дочерний классу ostream);
   stringstream (дочерний классу iostream);
   wistringstream;
   wostringstream;
   wstringstream.
Чтобы использовать stringstream, нужно подключить заголовочный файл sstream.
Чтобы занести данные в stringstream, мы можем использовать оператор вставки (<<), либо функцию str(string). Аналогично, чтобы получить данные обратно из stringstream, можем использовать функцию str() или оператор извлечения (>>).
Можно применять операторы вставки и извлечения со строками для их конвертации в числа и наоборот.
Например, конвертация чисел в строки:
#include <iostream>
#include <sstream> // для stringstream
using namespace std;

int main()
{
    stringstream myString;
    int nValue = 336000;
    double dValue = 12.14;
    myString << nValue << " " << dValue;

    string strValue1, strValue2;
    myString >> strValue1 >> strValue2;

    cout << strValue1 << " " << strValue2 << endl;
}

Результат работы программы:
336000 12.14
А теперь конвертация (числовой) строки обратно в числа:
#include <iostream>
#include <sstream>              // для stringstream
using namespace std;

int main()
{
    stringstream myString;
    myString << "336000 12.14"; // вставляем (числовую) строку в поток
    int nValue;
    double dValue;
    myString >> nValue >> dValue;
    cout << nValue << " " << dValue << endl;
}

Результат работы программы:
336000 12.14
Чтобы очистить stringstream для повторного использования, можно применить функцию str() с пустой строкой: myString.str(""); или функцию clear(), сбрасывающую все флаги ошибок, которые были установлены, и возвращающую поток обратно в его прежнее безошибочное состояние.
Перегрузка оператора вывода
Для вывода информации об объекте класса удобно использовать стандартный метод. Для этого необходимо перегрузить оператор ввода <<. Правым операндом данного оператора является объект класса, а левым операндом — объект std::cout, который имеет тип std::ostream. Перегружать оператор будем через дружественную функцию (а не через метод класса или обычную функцию):

#include <iostream>
using namespace std;

class Date
{
private:
    int m_day, m_month, m_year;

public:
    Date(int d=1, int m=1, int y=2019): m_day(d), m_month(m), m_year(y)
    { }

    friend ostream& operator<< (ostream &out, const Date &date);
};

ostream& operator<< (ostream &out, const Date &date)
{
    out << "Date: " << date.m_day << ". " << date.m_month << ". " << date.m_year << "\n";
    return out;
}

int main()
{
    Date date(5, 4, 2019);

    cout << date;

    return 0;
}

Обратите внимание на тип возврата оператора. Результат возвращается по ссылке, так как по значению возврат запрещен из-за невозможности копирования std::ostream. Возврат по ссылке не только предотвращает копирование класса std::ostream, но и позволяет связать выражения вывода — например, cout << date << endl.
Каждый раз, когда мы хотим, чтобы перегруженные бинарные операторы были связаны таким образом, левый операнд должен быть возвращен по ссылке. Возврат левого параметра по ссылке в этом случае работает, так как он передается в функцию самим ее вызовом, и должен оставаться даже после выполнения и возврата этой функции. Так что мы можем не беспокоиться о том, что ссылаемся на что-то, что выйдет из области видимости и уничтожится после выполнения функции.
Перегрузка оператора ввода
Перегрузки операторов ввода и вывода очень похожи. Единственное отличие состоит в том, что std::cin является объектом типа std::istream. Перегрузим оператор ввода для предыдущего примера:
istream& operator>> (istream &in, Date &date)
{
    // обратите внимание, параметр date (объект класса Date) должен быть не константным, чтобы мы имели возможность изменить члены класса
    in >> date.m_day;
    in >> date.m_month;
    in >> date.m_year;

    return in;
}

Перегрузка осуществляется также через дружественную функцию, которая имеет доступ к приватным переменным класса. Для использования данного оператора в функции main() достаточно написать:
Date date;
cin >> date;
Написание игры Blackjack
Напишем перегрузку оператора вывода для класса Card:
// перегружает оператор <<, чтобы получить возможность отправить
// объект типа Card в поток cout
ostream& operator<<(ostream& os, const Card& aCard)
{
    const string RANKS[] = { "0", "A", "2", "3", "4", "5", "6", "7", "8", "9","10", "J", "Q", "K" };
    const string SUITS[] = { "c", "d", "h", "s" };

    if (aCard.m_IsFaceUp)
    {
        os << RANKS[aCard.m_Rank] << SUITS[aCard.m_Suit];
    }
    else
    {
        os << "XX";
    }

    return os;
}


Перегружать будем через дружественную функцию, поэтому в самом классе объявим ее:
friend ostream& operator<<(ostream& os, const Card& aCard);


Теперь разберемся с классом GenericPlayer, который обобщенно представляет игрока в Blackjack. Он представляет не полноценного игрока, а общие элементы игрока-человека и игрока-компьютера.
// абстрактный класс
class GenericPlayer : public Hand
{
    friend ostream& operator<<(ostream& os, const GenericPlayer& aGenericPlayer);

public:
    GenericPlayer(const string& name = "");

    virtual ~GenericPlayer();

    // показывает, хочет ли игрок продолжать брать карты
    // Для класса GenericPlayer функция не имеет своей реализации,
    // т.к. для игрока и дилера это будут разные функции
    virtual bool IsHitting() const = 0;

    // возвращает значение, если у игрока перебор -
    // сумму очков большую 21
    // данная функция не виртуальная, т.к. имеет одинаковую реализацию
    // для игрока и дилера
    bool IsBusted() const;

    // объявляет, что игрок имеет перебор
    // функция одинакова как для игрока, так и для дилера
    void Bust() const;

protected:
    string m_Name;
};


Конструктор данного класса принимает строку, представляющую собой имя игрока. Деструктор автоматически становится виртуальным, поскольку наследует это свойство от класса Hand.
GenericPlayer::GenericPlayer(const string& name) :
m_Name(name)
{}
GenericPlayer::~GenericPlayer()
{}

Функция-член IsHitting() показывает, хочет ли игрок взять еще одну карту. Поскольку эта функция-член не имеет реального значения для обобщенного класса GenericPlayer, она является чисто виртуальной. Благодаря этому класс становится абстрактным. Соответственно, в классах Player и House должны быть реализованы собственные версии этой функции.
Функция-член IsBoosted() показывает, есть ли у игрока перебор. Поскольку перебор у дилера и игроков одинаков — сумма очков их карт превосходит 21, — функция размещена внутри этого класса.

bool GenericPlayer::IsBusted() const
{
    return (GetTotal() > 21);
}


Функция-член Bust() объявляет, что у игрока перебор. Поскольку перебор для игроков и дилера объявляется одинаковым образом, функция-член размещена внутри данного класса.
void GenericPlayer::Bust() const
{
    cout << m_Name << " busts.\n";
}


Для класса GenericPlayer существует перегрузка оператора вывода <<. Функция отображает имя игрока и его карты, а также общую сумму очков его карт.
ostream& operator<<(ostream& os, const GenericPlayer& aGenericPlayer)
{
    os << aGenericPlayer.m_Name << ":\t";

    vector<Card*>::const_iterator pCard;
    if (!aGenericPlayer.m_Cards.empty())
    {
        for (pCard = aGenericPlayer.m_Cards.begin();
             pCard != aGenericPlayer.m_Cards.end();
             ++pCard)
        {
            os << *(*pCard) << "\t";
        }


        if (aGenericPlayer.GetTotal() != 0)
        {
            cout << "(" << aGenericPlayer.GetTotal() << ")";
        }
    }
    else
    {
        os << "<empty>";
    }

    return os;
}


Теперь рассмотрим класс игрока-человека Player. Он наследует от класса GenericPlayer.
class Player : public GenericPlayer
{
public:
    Player(const string& name = "");

    virtual ~Player();

    // показывает, хочет ли игрок продолжать брать карты
    virtual bool IsHitting() const;

    // объявляет, что игрок победил
    void Win() const;

    // объявляет, что игрок проиграл
    void Lose() const;

    // объявляет ничью
    void Push() const;
};


Этот класс реализует функцию-член IsHitting(), которая унаследована от класса GenericPlayer. Поэтому класс Player не является абстрактным. Класс реализует функцию-член, спрашивая у человека, хочет ли он взять еще одну карту. Если игрок вводит символ y или Y в ответ, функция-член возвращает true, что показывает — игрок хочет взять еще одну карту. Если же игрок вводит любой другой символ, эта функция возвращает false, и это означает, что игрок больше не хочет брать карту.
bool Player::IsHitting() const
{
    cout << m_Name << ", do you want a hit? (Y/N): ";
    char response;
    cin >> response;
    return (response == 'y' || response == 'Y');
}


Функции-члены Win(), Lose() и Push() просто объявляют, что игрок выиграл, проиграл и сыграл вничью соответственно.
void Player::Win() const
{
    cout << m_Name << " wins.\n";
}

void Player::Lose() const
{
    cout << m_Name << " loses.\n";
}

void Player::Push() const
{
    cout << m_Name << " pushes.\n";
}


Класс House представляет дилера. Он наследует от класса GenericPlayer.
class House : public GenericPlayer
{
public:
    House(const string& name = "House");

    virtual ~House();

    // показывает, хочет ли дилер продолжать брать карты
    virtual bool IsHitting() const;

    // переворачивает первую карту
    void FlipFirstCard();
};


Это класс реализует функцию-члн IsHitting(), которая унаследована от класса GenericPlayer. Поэтому класс House не является абстрактным.
bool House::IsHitting() const
{
    return (GetTotal() <= 16);
}


Класс реализует эту функцию-член, вызывая функцию GetTotal(). Если возвращенное значение меньше или равно 16, функция-член возвращает значение true, что показывает: дилер хочет взять еще одну карту. В противном случае функция возвращает значение false, и это означает, что дилеру карты больше не нужны.
bool House::IsHitting() const
{
    return (GetTotal() <= 16);
}


Функция-член FlipFirstCard() переворачивает первую карту дилера. Она необходима, поскольку дилер скрывает свою первую карту в начале кона, а затем показывает ее после того, как все игроки взяли дополнительные карты.
void House::FlipFirstCard()
{
    if (!(m_Cards.empty()))
    {
        m_Cards[0]->Flip();
    }
    else
    {
        cout << "No card to flip!\n";
    }
}

Практическое задание
Создать программу, которая считывает целое число типа int. И поставить «защиту от дурака»: если пользователь вводит что-то кроме одного целочисленного значения, нужно вывести сообщение об ошибке и предложить ввести число еще раз. Пример неправильных введенных строк:
rbtrb
nj34njkn
1n
Создать собственный манипулятор endll для стандартного потока вывода, который выводит два перевода строки и сбрасывает буфер.

Реализовать класс Player, который наследует от класса GenericPlayer. У этого класса будет 4 метода:
virtual bool IsHitting() const - реализация чисто виртуальной функции базового класса. Метод спрашивает у пользователя, нужна ли ему еще одна карта и возвращает ответ пользователя в виде true или false.
void Win() const - выводит на экран имя игрока и сообщение, что он выиграл.
void Lose() const - выводит на экран имя игрока и сообщение, что он проиграл.
void Push() const - выводит на экран имя игрока и сообщение, что он сыграл вничью.

Реализовать класс House, который представляет дилера. Этот класс наследует от класса GenericPlayer. У него есть 2 метода:
virtual bool IsHitting() const - метод указывает, нужна ли дилеру еще одна карта. Если у дилера не больше 16 очков, то он берет еще одну карту.
void FlipFirstCard() - метод переворачивает первую карту дилера.

Написать перегрузку оператора вывода для класса Card. Если карта перевернута рубашкой вверх (мы ее не видим), вывести ХХ, если мы ее видим, вывести масть и номинал карты. Также для класса GenericPlayer написать перегрузку оператора вывода, который должен отображать имя игрока и его карты, а также общую сумму очков его карт.

Дополнительные материалы
Бьерн Страуструп. Программирование. Принципы и практика использования С++.
Стивен Прата. Язык программирования С++. Лекции и упражнения.
Роберт Лафоре. Объектно-ориентированное программирование в С++.
Используемая литература
Для подготовки данного методического пособия были использованы следующие ресурсы:
Поточный ввод-вывод в C++.
Бьерн Страуструп. Программирование. Принципы и практика использования С++.
Ральф Джонсон, Ричард Хелм, Эрих Гамма. Приемы объектно-ориентированного программирования. Паттерны проектирования.

*/


// УРОК №7
//--------



/*
Поддержка модульности. Написание игры Blackjack

Единицы компиляции. Разделение на файлы заголовков и реализации. Директивы препроцессора. Макросы и условная компиляция. Написание игры Blackjack.

Термины
От исходного кода к исполняемому модулю
Разделение текста программы на модули
Интерфейс и реализация
Практический пример
Типичные ошибки
Разработка игры Blackjack
Практическое задание
Дополнительные материалы
Используемая литература
Термины
Прежде чем приступить к изучению данной главы, вспомним ряд определений, связанных с программированием.
Исходный код — программа, написанная на языке программирования, но в текстовом формате. А также текстовый файл, содержащий исходный код.
Компилятор — программа, выполняющая компиляцию. На данный момент среди начинающих наиболее популярными компиляторами C/C++ являются GNU g++ (и его порты под различные ОС) и версии MS Visual Studio C++.
Компиляция — преобразование исходного кода в объектный модуль.
Объектный модуль — двоичный файл, который содержит особым образом подготовленный исполняемый код, который может быть объединен с другими объектными файлами при помощи редактора связей (компоновщика), чтобы получить готовый исполняемый модуль или библиотеку.
Компоновщик (редактор связей, линкер, сборщик) — это программа, которая производит компоновку (линковку, сборку): принимает на вход один или несколько объектных модулей и собирает по ним исполняемый модуль.
Исполняемый модуль (исполняемый файл) — файл, который может быть запущен на исполнение процессором под управлением операционной системы.
Препроцессор — программа для обработки текста. Может существовать отдельно или интегрироваться в компилятор. В любом случае входные и выходные данные для препроцессора имеют текстовый формат. Препроцессор преобразует текст в соответствии с директивами препроцессора. Если текст не содержит так директив, то остается без изменений.
IDE (англ. Integrated Development Environment) — интегрированная среда разработки. Программа (или их комплекс), упрощающая написание исходного кода, отладку, управление проектом, установку параметров компилятора, линкера, отладчика. Важно не путать IDE и компилятор. Как правило, компилятор самодостаточен и может не входить в состав IDE. С другой стороны, с некоторыми IDE можно использовать различные компиляторы.
Объявление — описание сущности: сигнатура функции, определение типа, описание внешней переменной, шаблон. Объявление уведомляет компилятор о ее существовании и свойствах.
Определение — реализация сущности: переменная, функция, метод класса и подобное. При обработке определения компилятор генерирует информацию для объектного модуля: исполняемый код, резервирование памяти под переменную и так далее.
От исходного кода к исполняемому модулю
Классическая схема создания исполняемого файла подразумевает три этапа:
Обработка исходного кода препроцессором.
Компиляция в объектный код.
Компоновка объектных модулей, включая модули из объектных библиотек, в исполняемый файл.
Это классическая схема для компилируемых языков, хотя сейчас уже используются и другие подходы.
Компиляция — это сборка программы, включающая трансляцию всех ее модулей, написанных на языке программирования, в эквивалентные программные модули на машинном языке и последующую сборку исполняемой машиной программы.
IDE обычно скрывают три отдельных этапа создания исполняемого модуля. Они проявляются только в тех случаях, когда на этапе препроцессинга или компоновки обнаруживаются ошибки.
Допустим, у нас есть программа на C++ «Hello, World!»:
#include <iostream>
using namespace std;

int main() {
    cout << "Hello, World!\n";
}

Сначала исходный код обрабатывается препроцессором. Он находит директиву #include <iostream>, ищет файл iostream и заменяет директиву текстом из этого файла, попутно обрабатывая все директивы препроцессора во включаемом тексте.
Файл, указанный в директиве #include, в данном случае является заголовочным файлом. Это обычный текстовый файл, содержащий объявления (объявления типов, прототипы функций, шаблоны, директивы препроцессора и подобное). После текстуального включения заголовочного файла в текст программы (или модуля) можно использовать в тексте программы все то, что описано в этом заголовочном файле.
Затем результат работы препроцессора передается компилятору. Он производит весь положенный комплекс работ: от синтаксического разбора и поиска ошибок до создания объектного файла (понятно, что если есть синтаксические ошибки, то объектный файл не создается). В объектном файле обычно есть таблица внешних ссылок — в которой, в частности, перечислены имена подпрограмм, которые используются в объектном модуле, но код которых отсутствует в данном объектном модуле. Эти подпрограммы внешние по отношению к модулю.
Исходный код, который может быть откомпилирован, называется единицей компиляции. Наша программа содержит одну единицу компиляции.
Чтобы получить нормальный исполняемый модуль, необходимо «разрешить» внешние ссылки. То есть добавить в исполняемый модуль код отсутствующих подпрограмм и настроить все ссылки на этот код. Этим занимается компоновщик. Он анализирует таблицу внешних ссылок объектного модуля, ищет в объектных библиотеках недостающие модули, копирует их в исполняемый модуль и настраивает ссылки. После этого исполняемый модуль готов.
Библиотека (объектная библиотека) — это набор откомпилированных подпрограмм, собранных в единый структурированный файл. Подключение библиотеки происходит на этапе компоновки исполняемого файла из объектных файлов (то есть из тех файлов, которые получаются в результате компиляции исходного текста программы).
Необходимые объектные библиотеки входят в комплект поставки компилятора. В комплект поставки библиотек (любых) входит набор заголовочных файлов, которые содержат объявления, необходимые компилятору.
Если исходный код программы разделен на несколько файлов, то процесс компиляции и сборки происходит аналогично. Сначала все единицы компиляции по отдельности компилируются, а затем компоновщик собирает полученные объектные модули (с подключением библиотек) в исполняемый файл. Такой процесс называется раздельной компиляцией.
Разделение текста программы на модули
Помимо того, что с большим текстом просто неудобно работать, для разделения исходного текста программы на несколько файлов есть такие основания:
Разделение на отдельные модули по функциональному признаку.
Разделение согласно паттерну DRY (Don’t repeat yourself), который подразумевает повторное использование модулей в программах.
Реализация паттерна MVC, предусматривающего разделение интерфейсной и функциональной частей приложения.
Как только мы решаем разделить исходный текст программы на несколько файлов, возникают две проблемы:
Необходимо от простой компиляции программы перейти к раздельной. Для этого надо внести соответствующие изменения:
либо в последовательность действий при построении приложения вручную;
либо в командные или make-файлы, автоматизирующие процесс построения;
либо в проект IDE.
Надо решить, каким образом разбить текст программы на отдельные файлы.
Первая проблема — чисто техническая. Она решается чтением руководств по компилятору и/или линкеру, утилите make или IDE. В самом худшем случае просто придется проштудировать все эти руководства.
Вторая проблема требует более творческого подхода. Хотя и здесь существуют рекомендации, несоблюдение которых приводит либо к невозможности собрать проект, либо к трудностям в его дальнейшем развитии.
Нужно определить, какие части программы выделить в отдельные модули. Чтобы это получилось просто и естественно, программа должна быть правильно спроектирована. О том, как правильно спроектировать программу, написано много книг по методологии программирования. Краткая рекомендация: вся программа должна состоять из слабо связанных фрагментов. Приведем пример из реальной жизни. Периферия компьютера — мышка, клавиатура, монитор — это в некотором роде «черные ящики». Каждый элемент выполняет свою функцию и может быть заменен любым подобным ему объектом, главное — подходящим.
В программировании каждый такой «независимый» фрагмент может быть естественным образом преобразован в отдельный модуль (единицу компиляции). Обратите внимание, что под «фрагментом» подразумевается не просто произвольный кусок кода, а функция, или группа логически связанных функций, или класс, или несколько тесно взаимодействующих классов.
Еще нужно определить интерфейсы для модулей — для этого есть четкие правила.
Интерфейс и реализация
Когда фрагмент программы выделяется в модуль (единицу компиляции), остальной ее части (а точнее компилятору, который будет ее обрабатывать) надо объяснить, что имеется в этом модуле. Для этого служат заголовочные файлы.
Таким образом, модуль состоит из двух файлов: заголовочного (интерфейса) и файла реализации.
Заголовочный файл, как правило, имеет расширение .h или .hpp, а файл реализации — .cpp для программ на C++ и .c — на языке C. Хотя в STL включаемые файлы вообще без расширений, но по сути они являются заголовочными файлами.
Заголовочный файл должен содержать все объявления, которые должны быть видны снаружи. Другие объявления делаются в файле реализации.
Что может быть в заголовочном файле?
Заголовочный файл может содержать только объявления и не должен содержать определения.
Разделение программы позволяет скрыть реализацию, предоставив “клиентам” лишь интерфейс.
То есть, при обработке содержимого заголовочного файла компилятор не должен генерировать информацию для объектного модуля.
Исключение из этого правила — написание шаблона функции или класса внутри заголовочного файла.
Заголовочный файл должен иметь механизм защиты от повторного включения.
Защита от повторного включения реализуется директивами препроцессора:
#ifndef SYMBOL // если SYMBOL не объявлен
#define SYMBOL // объявить SYMBOL

// набор объявлений

#endif // конец #ifndef

Для препроцессора при первом включении заголовочного файла это выглядит так: поскольку условие «символ SYMBOL не определен» истинно, определить символ SYMBOL и обработать все строки до директивы #endif. При повторном включении — так: поскольку условие «символ SYMBOL не определен» (#ifndef SYMBOL) ложно (символ был определен при первом включении), то пропустить все до директивы #endif.
В качестве SYMBOL обычно применяют имя самого заголовочного файла в верхнем регистре, обрамленное одинарными или сдвоенными подчеркиваниями. Например, для файла header.h традиционно используется #define __HEADER_H__. Впрочем, символ может быть любым, но обязательно уникальным в рамках проекта.
В качестве альтернативного способа может применяться директива #pragma once. Однако преимущество первого способа в том, что он работает на любых компиляторах.
Заголовочный файл сам по себе не является единицей компиляции.
Что может быть в файле реализации?
Файл реализации может содержать как определения, так и объявления. Объявления, сделанные в файле реализации, будут лексически локальны для этого файла — то есть будут действовать только для этой единицы компиляции.
В файле реализации должна быть директива включения соответствующего заголовочного файла.
Понятно, что объявления, которые видны снаружи модуля, должны быть доступны и внутри. Данное правило также гарантирует соответствие между описанием и реализацией. При несовпадении, допустим, сигнатуры функции в объявлении и определении компилятор выдаст ошибку.
В файле реализации не должно быть объявлений, дублирующих объявления в соответствующем заголовочном файле.
Практический пример
Рассмотрим программу:
#include <iostream>
using namespace std;

const int dayDefault = 10;    // глобальная константа
int celebration = 0;          // глобальная переменная
int holiday = 0;              // глобальная переменная для increase и decrease

int increase() {
    ++celebration;
    return ++holiday;
}

int decrease() {
    --celebration;
    return --holiday;
}

class Date {
public:
    Date() : day(dayDefault) { ++number; }
    ~Date() { --number; }
    void changeDay(int arg);
    int get_day() const;
    int get_number() const;
private:
    int day;
    static int number;
};

int Date::number = 0;

void Date::changeDay(int arg) {
    day = arg;
}

int Date::get_day() const {
    return day;
}

int Date::get_number() const {
    return number;
}

int main()
{
    int days;
    days = increase();
    days = decrease();
    cout << "Days: " << days << " number: " << celebration << endl;

    Date d1, d2;
    if (d1.get_day() == dayDefault)
        cout << "Ok" << endl;
    cout << d2.get_number() << endl;
    return 0;
}

Мы имеем:
глобальную константу dayDefault, которая используется и в классе, и в main;
глобальную переменную celebration, которая используется в функциях increase(), decrease() и main;
глобальную переменную holiday, которая используется только в функциях increase() и decrease();
функцию increase() и decrease();
класс Date;
функцию main.
Теперь пробуем разделить программу на модули.
Сначала как наиболее связанные сущности (используются во многих местах программы) выносим в отдельную единицу компиляции глобальную константу dayDefault и глобальную переменную celebration.
Файл globals.h:
#ifndef __GLOBALS_H__
#define __GLOBALS_H__

const int dayDefault = 10;            // глобальная константа
extern int celebration;               // глобальная переменная

#endif // __GLOBALS_H__


Файл globals.cpp
#include "globals.h"

int celebration = 0;                 // глобальная переменная

Обратите внимание, что глобальная переменная в заголовочном файле имеет спецификатор extern. В файле globals.h мы только объявляем переменную, а определяем ее в другом файле. Такое описание означает, что где-то существует переменная с таким именем и указанным типом. А определение этой переменной (с инициализацией) помещено в файл реализации. Константа описана в заголовочном файле.
Если константа тривиального типа, то ее можно объявить в заголовочном файле. В противном случае она должна быть определена в файле реализации, а в заголовочном должно быть ее объявление (как для переменной).
Также обратите внимание на защиту от повторного включения заголовочного файла и на включение заголовочного файла в файле реализации.
Затем выносим в отдельный модуль функции increase() и decrease() с глобальной переменной holiday. Получаем еще два файла:
Файл funcs.h
#ifndef __FUNCS_H__
#define __FUNCS_H__

int increase();
int decrease();
#endif // __FUNCS_H__


Файл funcs.cpp
#include "funcs.h"
#include "globals.h"

int holiday = 0;         // глобальная переменная для increase и decrease

int increase() {
    ++celebration;
    return ++holiday;
}

int decrease() {
    ++celebration;
    return --holiday;
}

Поскольку переменная holiday используется только этими двумя функциями, ее объявление в заголовочном файле отсутствует. Из этого модуля «на экспорт» идут только две функции.
В функциях используется переменная из другого модуля, поэтому необходимо добавить #include "globals.h".
Наконец, выносим в отдельный модуль класс Date:
Файл Date.h
#ifndef __Date_H__
#define __Date_H__

class Date {
public:
    Date();
    ~Date();
    void changeDay(int arg);
    int get_day() const;
    int get_number() const;
private:
    int day;
    static int number;
};
#endif // __Date_H__

Файл Date.cpp
#include "Date.h"
#include "globals.h"

int Date::number = 0;

Date::Date() : day(dayDefault) {
    ++number;
}

Date::~Date() {
    --number;
}

void Date::changeDay(int arg) {
    day = arg;
}

int Date::get_day() const {
    return day;
}

int Date::get_number() const {
    return number;
}

Обратите внимание на следующие моменты.
Из объявления класса убрали определения методов, так как интерфейс и реализация должны быть разделены.
Класс имеет статический член класса, то есть для всех экземпляров класса эта переменная будет общей. Ее инициализация выполняется не в конструкторе, а в глобальной области модуля.
В файл реализации добавлена директивам #include "globals.h" для доступа к константе cint.
Классы практически всегда выделяются в отдельные единицы компиляции.
В файле main.cpp оставляем только функцию main. И добавляем необходимые директивы включения заголовочных файлов.

Файл main.cpp
#include <iostream>
#include "funcs.h"
#include "Date.h"
#include "globals.h"

using namespace std;

int main()
{
    int days;
    days = increase();
    days = decrease();
    cout << "days: " << days << " number: " << celebration << endl;

    Date d1, d2;
    if (d1.get_day() == dayDefault)
        cout << "Ok" << endl;
    cout << d2.get_number() << endl;
    return 0;
}

Типичные ошибки
Ошибка 1. Определение в заголовочном файле.
Эта ошибка в ряде случаев может себя не проявлять. Например, когда заголовочный файл с этой ошибкой включается только один раз. Но как только этот заголовочный файл будет включен более одного раза, получим либо ошибку компиляции «многократное определение символа ...», либо ошибку компоновщика (аналогичного содержания), если второе включение было сделано в другой единице компиляции.
Ошибка 2. Отсутствие защиты от повторного включения заголовочного файла.
Тоже проявляет себя при определенных обстоятельствах. Может вызывать ошибку компиляции «многократное определение символа ...».
Ошибка 3. Несовпадение объявления в заголовочном файле и определения в файле реализации.
Обычно возникает в процессе редактирования исходного кода, когда в файл реализации вносятся изменения, а про заголовочный файл забывают.
Ошибка 4. Отсутствие необходимой директивы #include.
Если необходимый заголовочный файл не включен, то все сущности, которые в нем объявлены, останутся неизвестными компилятору. Вызывает ошибку компиляции «не определен символ ...».
Ошибка 5. Отсутствие необходимого модуля в проекте построения программы.
Вызывает ошибку компоновки «не определен символ ...». Обратите внимание, что имя символа в сообщении компоновщика почти всегда отличается от того, которое определено в программе: оно дополнено другими буквами, цифрами или знаками.
Ошибка 6. Зависимость от порядка включения заголовочных файлов.
Не совсем ошибка, но таких ситуаций следует избегать. Обычно сигнализирует об ошибках либо в проектировании программы, либо при разделении исходного кода на модули.
Разработка игры Blackjack
 Класс Deck представляет колоду карт и наследует от класса Hand.
class Deck : public Hand
{
public:
    Deck();

    virtual ~Deck();

    // создает стандартную колоду из 52 карт
    void Populate();

    // тасует карты
    void Shuffle();

    // раздает одну карту в руку
    void Deal(Hand& aHand);

    // дает дополнительные карты игроку
    void AdditionalCards(GenericPlayer& aGenericPlayer);
};

Deck::Deck()
{
    m_Cards.reserve(52);
    Populate();
}

Deck::~Deck()
{}


Функция Populate() создает стандартную колоду из 52 карт. Функция-член проходит по всем возможным комбинациям значений перечислений Card::suit и Card::rank. Она использует static_cast, чтобы преобразовать целочисленные переменные в значения перечислений, определенных в классе Card.
void Deck::Populate()
{
    Clear();
    // создает стандартную колоду
    for (int s = Card::CLUBS; s <= Card::SPADES; ++s)
    {
        for (int r = Card::ACE; r <= Card::KING; ++r)
        {
            Add(new Card(static_cast<Card::rank>(r),
                         static_cast<Card::suit>(s)));
        }
    }
}


Функция Shuffle() тасует колоду карт. Она в случайном порядке переставляет указатели, расположенные в векторе m_Cards с помощью функции random_shuffle() стандартной библиотеки шаблонов. Именно поэтому нужно подключить заголовочный файл <algorithm>.
void Deck::Shuffle()
{
    random_shuffle(m_Cards.begin(), m_Cards.end());
}


Функция Deal() выдает одну карту из колоды в руку. Она добавляет копию указателя в конец вектора m_Cards с помощью функции-члена Add(). Далее она удаляет указатель из конца вектора m_Cards, что, по сути, является перемещением карты. Функция Deal() мощная, поскольку она принимает ссылку на объект типа Hand — и это означает, что она может работать также с объектами классов Player и House. Благодаря полиморфизму функция Deal() может вызывать функцию-член Add() любого объекта из этих классов, не зная его конкретный тип.
void Deck::Deal(Hand& aHand)
{
    if (!m_Cards.empty())
    {
        aHand.Add(m_Cards.back());
        m_Cards.pop_back();
    }
    else
    {
        cout << "Out of cards. Unable to deal.";
    }
}


Функция AdditionalCards() дает дополнительные карты игроку до тех пор, пока он этого хочет или у него не образуется перебор. Функция-член принимает ссылку на объект типа GenericPlayer, поэтому вы можете передать ей объект типа Player или House. Благодаря полиморфизму функция AdditionalCards() может не знать, с объектом какого типа она работает. Она может вызывать функции-члены IsBusted() и IsHitting(), не зная типа объекта, и при этом будет выполнен корректный код.
void Deck::AdditionalCards(GenericPlayer& aGenericPlayer)
{
    cout << endl;
    // продолжает раздавать карты до тех пор, пока у игрока не случается
    // перебор или пока он хочет взять еще одну карту
    while (!(aGenericPlayer.IsBusted()) && aGenericPlayer.IsHitting())
    {
        Deal(aGenericPlayer);
        cout << aGenericPlayer << endl;

        if (aGenericPlayer.IsBusted())
        {
            aGenericPlayer.Bust();
        }
    }
}


Класс Game представляет игру Blackjack.
class Game
{
public:
    Game(const vector<string>& names);

    ~Game();

    // проводит игру в Blackjack
    void Play();

private:
    Deck m_Deck;
    House m_House;
    vector<Player> m_Players;
};

// Конструктор этого класса принимает ссылку на вектор строк, представляющих
// имена игроков-людей. Конструктор создает объект класса Player для каждого имени
Game::Game(const vector<string>& names)
{
    // создает вектор игроков из вектора с именами
    vector<string>::const_iterator pName;
    for (pName = names.begin(); pName != names.end(); ++pName)
    {
        m_Players.push_back(Player(*pName));
    }

    // запускает генератор случайных чисел
    srand(static_cast<unsigned int>(time(0)));
    m_Deck.Populate();
    m_Deck.Shuffle();
}

Game::~Game()
{}

void Game::Play()
{
    // раздает каждому по две стартовые карты
    vector<Player>::iterator pPlayer;
    for (int i = 0; i < 2; ++i)
    {
        for (pPlayer = m_Players.begin(); pPlayer != m_Players.end(); ++pPlayer)
        {
            m_Deck.Deal(*pPlayer);
        }
        m_Deck.Deal(m_House);
    }

    // прячет первую карту дилера
    m_House.FlipFirstCard();

    // открывает руки всех игроков
    for (pPlayer = m_Players.begin(); pPlayer != m_Players.end(); ++pPlayer)
    {
        cout << *pPlayer << endl;
    }
    cout << m_House << endl;

    // раздает игрокам дополнительные карты
    for (pPlayer = m_Players.begin(); pPlayer != m_Players.end(); ++pPlayer)
    {
        m_Deck.AdditionalCards(*pPlayer);
    }

    // показывает первую карту дилера
    m_House.FlipFirstCard();
    cout << endl << m_House;

    // раздает дилеру дополнительные карты
    m_Deck.AdditionalCards(m_House);

    if (m_House.IsBusted())
    {
        // все, кто остался в игре, побеждают
        for (pPlayer = m_Players.begin(); pPlayer != m_Players.end(); ++pPlayer)
        {
            if (!(pPlayer->IsBusted()))
            {
                pPlayer->Win();
            }
        }
    }
    else
    {
        // сравнивает суммы очков всех оставшихся игроков с суммой очков дилера
        for (pPlayer = m_Players.begin(); pPlayer != m_Players.end();
             ++pPlayer)
        {
            if (!(pPlayer->IsBusted()))
            {
                if (pPlayer->GetTotal() > m_House.GetTotal())
                {
                    pPlayer->Win();
                }
                else if (pPlayer->GetTotal() < m_House.GetTotal())
                {
                    pPlayer->Lose();
                }
                else
                {
                    pPlayer->Push();
                }
            }
        }

    }

    // очищает руки всех игроков
    for (pPlayer = m_Players.begin(); pPlayer != m_Players.end(); ++pPlayer)
    {
        pPlayer->Clear();
    }
    m_House.Clear();
}

Конструктор этого класса принимает ссылку на вектор строк, представляющих имена игроков-людей. Конструктор создает объект класса Player для каждого имени.
Код игры Blackjack приведен в отдельном файле (Blackjack.cpp). В тексте кода даны краткие пояснения по используемым функциям и классам.
Практическое задание
1. Создайте класс Date с полями день, месяц, год и методами доступа к этим полям. Перегрузите оператор вывода для данного класса. Создайте два "умных" указателя today и date. Первому присвойте значение сегодняшней даты. Для него вызовите по отдельности методы доступа к полям класса Date, а также выведите на экран данные всего объекта с помощью перегруженного оператора вывода. Затем переместите ресурс, которым владеет указатель today в указатель date. Проверьте, являются ли нулевыми указатели today и date и выведите соответствующую информацию об этом в консоль.
2. По условию предыдущей задачи создайте два умных указателя date1 и date2.
Создайте функцию, которая принимает в качестве параметра два умных указателя типа Date и сравнивает их между собой (сравнение происходит по датам). Функция должна вернуть более позднюю дату.
Создайте функцию, которая обменивает ресурсами (датами) два умных указателя, переданных в функцию в качестве параметров.
Примечание: обратите внимание, что первая функция не должна уничтожать объекты, переданные ей в качестве параметров.
3. Создать класс Deck, который наследует от класса Hand и представляет собой колоду карт. Класс Deck имеет 4 метода:
vold Populate() - Создает стандартную колоду из 52 карт, вызывается из конструктора.
void Shuffle() - Метод, который тасует карты, можно использовать функцию из алгоритмов STL random_shuffle
vold Deal (Hand& aHand) - метод, который раздает в руку одну карту
void AddltionalCards (GenericPlayer& aGenerlcPlayer) - раздает игроку дополнительные карты до тех пор, пока он может и хочет их получать
Обратите внимание на применение полиморфизма. В каких методах применяется этот принцип ООП?
4. Реализовать класс Game, который представляет собой основной процесс игры. У этого класса будет 3 поля:
колода карт
рука дилера
вектор игроков.
Конструктор класса принимает в качестве параметра вектор имен игроков и создает объекты самих игроков. В конструкторе создается колода карт и затем перемешивается.
Также класс имеет один метод play(). В этом методе раздаются каждому игроку по две стартовые карты, а первая карта дилера прячется. Далее выводится на экран информация о картах каждого игра, в т.ч. и для дилера. Затем раздаются игрокам дополнительные карты. Потом показывается первая карта дилера и дилер набирает карты, если ему надо. После этого выводится сообщение, кто победил, а кто проиграл. В конце руки всех игроков очищаются.
5. Написать функцию main() к игре Блекджек. В этой функции вводятся имена игроков. Создается объект класса Game и запускается игровой процесс. Предусмотреть возможность повторной игры.

Дополнительные материалы
Бьерн Страуструп. Программирование. Принципы и практика использования С++.
Стивен Прата. Язык программирования С++. Лекции и упражнения.
Роберт Лафоре. Объектно-ориентированное программирование в С++.
Используемая литература
Для подготовки данного методического пособия были использованы следующие ресурсы:
Модульное программирование.
Бьерн Страуструп. Программирование. Принципы и практика использования С++.
Ральф Джонсон, Ричард Хелм, Эрих Гамма. Приемы объектно-ориентированного программирования. Паттерны проектирования.

*/



// УРОК №8
//--------



/*
Механизм исключительных ситуаций
Возбуждение и обработка ситуаций. Свертка стека. Исполнение конструкторов и деструкторов. Поддержка иерархии классов. Стандартные классы исключительных ситуаций. Примеры программ с использованием исключительных ситуаций.

Введение в исключения
Обработка исключений
Генерация исключений за пределами блока try
Обработчик catch-all
Класс-исключение
Исключения и наследования
std::exception
Повторная генерация исключений
Функциональный try-блок
Недостатки и опасности использования исключений
Практическое задание
Дополнительные материалы
Используемая литература
Введение в исключения
Встречаются ситуации, которые препятствуют дальнейшей нормальной работе программ. К примеру, при делении числа на ноль программа просто закроется — несмотря на то, сколько пользователь работал в ней и какой объем данных внес. И представьте: пользователь вносил в программу данные несколько часов и проводил расчеты, а при аварийном закрытии все они пропадут.
Или другой случай: программа пытается открыть недоступный в этот момент файл или запросить больше памяти, чем доступно. Такого рода ситуации программистам надо стараться предвидеть и строить программы так, чтобы они могли гибко реагировать, а не аварийно закрываться.
Исключение — это реакция на нештатную ситуацию, возникшую на время выполнения программы. Исключения позволяют передать управление из одной части программы в другую.
Исключения в C++ реализованы с помощью трех ключевых слов, которые работают в связке друг с другом: throw, try и catch.
Обработка исключений
В C++ оператор throw используется, чтобы сигнализировать о возникновении исключения или ошибки — это называется генерацией исключения.
Для применения оператора throw используется ключевое слово throw, за которым указывается значение любого типа данных, которое вы хотите использовать, чтобы сигнализировать об ошибке. Как правило, этим значением является код ошибки, описание проблемы или настраиваемый класс-исключение (класс Exception). Например:
throw -1;
// генерация исключения типа int

throw ENUM_INVALID_INDEX;
// генерация исключения типа enum

throw "Cannot take square root of negative number";
// генерация исключения типа const char* (строка C-style)

throw dX;
// генерация исключения типа double (переменная типа double, которая была определена ранее)

throw MyException("Fatal Error");
// генерация исключения с использованием объекта класса MyException

В C++ мы используем ключевое слово try для определения блока операторов и команд — так называемый блок try. Он действует как наблюдатель, отслеживая возникновение исключений, которые были выброшены каким-либо оператором в этом же блоке try.
Например:
try
{
               // Здесь мы пишем стейтменты, которые будут генерировать следующее исключение
    throw -1; // типичный стейтмент throw
}


Фактически, обработка исключений — это работа блоков catch. Ключевое слово catch используется для определения блока кода (блока catch), который обрабатывает исключения определенного типа данных.
Вот пример блока catch, который обрабатывает (ловит) исключения типа int:
catch (int a)
{
    // Обрабатываем исключение типа int
    cerr << "We caught an int exception with value" << a << '\n';
}

Блоки try и catch работают вместе. Блок try обнаруживает любые исключения, которые были выброшены в нем, и направляет их в соответствующий блок catch для обработки. Блок try должен иметь по крайней мере один блок catch, который находится сразу за ним, но также может иметь и несколько блоков catch, размещенных последовательно, друг за другом.
Как только исключение было поймано блоком try и направлено в блок catch для обработки, оно считается обработанным (после выполнения кода блока catch), и выполнение программы возобновляется.
Параметры catch работают так же, как и параметры функции, причем параметры одного блока catch могут быть доступны и в другом блоке catch, который находится за ним. Исключения фундаментальных типов данных могут быть пойманы по значению (параметром блока catch является значение). Но исключения не фундаментальных типов данных должны быть пойманы по константной ссылке (параметром блока catch является константная ссылка), чтобы избежать ненужного копирования.
Если исключение направлено в блок catch, оно считается обработанным, даже если блок catch пуст. Но хочется, чтобы ваши блоки catch делали что-то полезное. Есть три распространенные вещи, которые выполняют блоки catch, когда они поймали исключение:
Выводят сообщение об ошибке.
Возвращают значение или код ошибки обратно в caller (тот оператор, который вызвал исполняемый блок).
Генерируют другое исключения. Поскольку блок catch не находится внутри блока try, новое сгенерированное исключение будет обрабатываться следующим блоком try.

Генерация исключений за пределами блока try
Благодаря выполнению операции раскручивания стека операторы throw вовсе не обязаны находиться непосредственно в блоке try. Это дает нам необходимую гибкость в разделении общего потока выполнения кода программы и обработки исключений. Продемонстрируем это, написав программу вычисления квадратного корня:
#include <cmath> // для sqrt()
#include <iostream>
using namespace std;

// Отдельная функция вычисления квадратного корня
double mySqrt(double a)
{
    // Если пользователь ввёл отрицательное число, то выбрасываем исключение
    if (a < 0.0)
        throw "Can not take sqrt of negative number"; // выбрасывается исключение типа const char*

    return sqrt(a);
}

int main()
{
    cout << "Enter a number: ";
    double a;
    cin >> a;

    try // ищем исключения, которые выбрасываются в блоке try, и отправляем их для обработки в блок(и) catch
    {
        double d = mySqrt(a);
        cout << "The sqrt of " << a << " is " << d << '\n';
    }
    catch (const char* exception) // обработка исключений типа const char*
    {
        cerr << "Error: " << exception << endl;
    }

    return 0;
}


Результат работы программы:
Enter a number: -3
Error: Cannot take sqrt of negative number
При генерации исключения компилятор смотрит, можно ли сразу же обработать его. Поскольку точка выполнения не находится внутри блока try, то и обработать исключение немедленно не получится. Выполнение функции mySqrt() приостанавливается, и программа смотрит, может ли caller (который и вызывает mySqrt()) обработать это исключение. Если нет, то компилятор завершает выполнение caller’а и переходит на уровень выше: к caller’у, который вызывает текущего caller’а, чтобы проверить, сможет ли тот обработать исключение. И так последовательно до тех пор, пока не будет найден соответствующий обработчик исключения или main() не завершится без обработки исключения. Этот процесс называется раскручиванием стека.
Теперь рассмотрим детальнее. Сначала компилятор проверяет, генерируется ли исключение внутри блока try. В нашем случае — нет, поэтому стек начинает раскручиваться. При этом функция mySqrt() завершает свое выполнение, и точка выполнения перемещается обратно в main(). Теперь компилятор проверяет снова, находимся ли мы внутри блока try. Поскольку вызов mySqrt() был выполнен из блока try, то компилятор начинает искать соответствующий обработчик catch. Он находит обработчик типа const char*, и исключение обрабатывается блоком catch внутри main().
Передача обработки исключения в caller необходима потому, что программы обрабатывают ошибки/исключения по-разному. Консольная программа выводит сообщение об ошибке, а приложение Windows — диалоговое окно с ошибкой.
Рассмотрим пример посложнее:
#include <iostream>
using namespace std;

void last() // вызывается функцией three()
{
    cout << "Start last\n";
    cout << "last throwing int exception\n";
    throw -1;
    cout << "End last\n";

}

void three() // вызывается функцией two()
{
    cout << "Start three\n";
    last();
    cout << "End three\n";
}

void two() // вызывается функцией one()
{
    cout << "Start two\n";
    try
    {
        three();
    }
    catch(double)
    {
        cerr << "two caught double exception\n";
    }
    cout << "End two\n";
}

void one() // вызывается функцией main()
{
    cout << "Start one\n";
    try
    {
        two();
    }
    catch (int)
    {
        cerr << "one caught int exception\n";
    }
    catch (double)
    {
        cerr << "one caught double exception\n";
    }
    cout << "End one\n";
}

int main()
{
    cout << "Start main\n";
    try
    {
        one();
    }
    catch (int)
    {
        cerr << "main caught int exception\n";
    }
    cout << "End main\n";

    return 0;
}
int main()
{
    cout << "Start main\n";
    try
    {
        one();
    }
    catch (int)
    {
        cerr << "main caught int exception\n";
    }
    cout << "End main\n";

    return 0;
}

Результат работы программы:
Start main
Start one
Start two
Start three
Start last
last throwing int exception
one caught int exception
End one
End main
Поскольку last() не обрабатывает исключения самостоятельно, стек начинает раскручиваться. Функция last() немедленно завершает свое выполнение, и точка выполнения возвращается обратно в caller (в функцию three()).
Функция three() не обрабатывает исключения, поэтому стек раскручивается дальше, выполнение функции three() прекращается и точка выполнения возвращается в two().
Функция two() имеет блок try, в котором находится вызов three(), поэтому компилятор пытается найти обработчик исключений типа int, но так как его не находит, точка выполнения возвращается в one(). Обратите внимание: компилятор не выполняет неявного преобразования, чтобы сопоставить исключение типа int с обработчиком типа double.
Функция one() также имеет блок try с вызовом two() внутри, поэтому компилятор смотрит, есть ли подходящий обработчик catch. Есть! Функция one() обрабатывает исключение и выводит one caught int exception.
Поскольку исключение было обработано, точка выполнения перемещается в конец блока catch внутри one(). Это означает, что one() выводит End one, а затем завершает свое выполнение как обычно.
Точка выполнения возвращается обратно в main(). Хотя main() имеет обработчик исключений типа int, наше исключение уже было обработано функцией one(), поэтому блок catch внутри main() не выполняется. main() выводит End main, а затем завершает свое выполнение.
Раскручивание стека — очень полезный механизм, так как позволяет функциям не обрабатывать исключения, если они этого не хотят. Раскручивание выполняется до тех пор, пока не будет обнаружен соответствующий блок catch! Таким образом мы можем сами решать, где следует обрабатывать исключения.
Обработчик catch-all
Функции могут генерировать исключения любого типа данных, и если исключение не поймано, это приведет к раскручиванию стека и потенциальному завершению выполнения целой программы. C++ предоставляет механизм обнаружения/обработки всех типов исключений — обработчик catch-all. Он работает так же, как и обычный блок catch, но вместо обработки исключений определенного типа данных использует эллипсис (…) в качестве типа данных.
Вот простой пример:
#include <iostream>
using namespace std;

int main()
{
    try
    {
        throw 7; // выбрасывается исключение типа int
    }
    catch (double a)
    {
        cout << "We caught an exception of type double: " << a << '\n';
    }
    catch (...) // обработчик catch-all
    {
        cout << "We caught an exception of an undetermined type!\n";
    }
}

Поскольку для типа int не существует специального обработчика catch, обработчик catch-all ловит это исключение. Следовательно, результат:
We caught an exception of an undetermined type!
Обработчик catch-all должен быть последним в цепочке блоков catch.
Класс-исключение
Класс-исключение — это обычный класс, который выбрасывается в качестве исключения. Создадим простой класс-исключение:
#include <string>
using namespace std;

class classException
{
private:
    string m_error;

public:
    classException(string error) : m_error(error)
    { }
    const char* getError() { return m_error.c_str(); }
};

Используя такой класс, мы можем генерировать исключение, возвращающее описание возникшей проблемы. Это даст точно понять, что именно пошло не так. И поскольку исключение classException — уникального типа, мы можем обрабатывать его соответствующим образом. В обработчиках исключений объекты класса-исключения нужно принимать по ссылке, а не по значению. Это предотвратит затратную операцию — создание копии исключения компилятором.
Исключения и наследования
Обработчики могут обрабатывать исключения не только одного определенного класса, но и исключения дочерних ему классов. Рассмотрим следующий пример:
#include <iostream>
using namespace std;
class Parent
{
public:
    Parent() {}
};

class Child: public Parent
{
public:
    Child() {}
};

int main()
{
    try
    {
        throw Child();
    }
    catch (Parent &parent)
    {
        cerr << "caught Parent";
    }
    catch (Child &child)
    {
        cerr << "caught Child";
    }

    return 0;
}


Здесь выбрасывается исключение типа Child. Но результат выполнения этой программы:
caught Parent
Чтобы обработчик Child ловил исключения класса Child, нужно просто поменять последовательность блоков catch.
Обработчики исключений дочерних классов должны находиться перед обработчиками исключений родительского класса.
std::exception
Многие классы и операторы из стандартной библиотеки С++ выбрасывают классы-исключения при сбое. Например, оператор new и std::string могут выбрасывать std::bad_alloc при нехватке памяти. Неудачное динамическое приведение типов с помощью dynamic_cast выбрасывает исключение std::bad_cast и так далее. Начиная с C++14, существует 21 класс-исключение, которые могут быть выброшены, в C++17 их еще больше.
Хорошая новость: все эти классы-исключения являются дочерними классу std::exception. Это небольшой интерфейсный класс, который используется в качестве родительского для любого исключения, которое выбрасывается в стандартной библиотеке C++.
В большинстве случаев, если исключение выбрасывается стандартной библиотекой С++, нам все равно, будет ли это неудачное выделение, конвертирование или что-либо другое. Достаточно знать, что случилось что-то катастрофическое, из-за чего в программе произошел сбой. Благодаря std::exception мы можем настроить обработчик исключений типа std::exception, который будет ловить и обрабатывать как std::exception, так и все (21+) дочерние ему классы-исключения!
В std::exception есть виртуальный метод what(), который возвращает строку C-style с описанием исключения. Большинство дочерних классов переопределяют функцию what(), изменяя это сообщение. Обратите внимание: эта строка C-style предназначена для использования только в качестве описания.
Иногда нужно обрабатывать определенный тип исключений соответствующим ему образом. В таком случае мы можем добавить обработчик исключений для этого конкретного типа, а все остальные исключения «перенаправлять» в родительский обработчик. Например:
try
{
    // Здесь код с использованием стандартной библиотеки С++
}
// Этот обработчик ловит bad_alloc и все дочерние ему классы-исключения
catch (bad_alloc &exception)
{
    cerr << "You ran out of memory!" << '\n';
    }
    // Этот обработчик ловит exception и все дочерние ему классы-исключения
    catch (exception &exception)
    {
        cerr << "Standard exception: " << exception.what() << '\n';
    }
}

В этом примере исключения типа std::bad_alloc перехватываются и обрабатываются первым обработчиком. Исключения типа std::exception и всех других дочерних ему классов-исключений обрабатываются вторым обработчиком.
Повторная генерация исключений
Бывает, что нужно поймать исключение, но обрабатывать его сразу не хочется или нет возможности. Тогда вы можете записать ошибку в лог-файл, а затем передать ее обратно в caller для выполнения фактической обработки. Есть и другой вариант — генерация нового исключения. Можно в блоке catch сгенерировать новое исключение в блоке throw. Помните, что только исключения, сгенерированные в блоке try, могут быть перехвачены блоком catch. Это означает, что исключение, сгенерированное в блоке catch, не будет перехвачено этим же блоком catch, в котором оно находится. Вместо этого стек начнет раскручиваться и исключение будет передано caller’у, который находится на уровне выше в стеке вызовов.
C++ предоставляет способ повторной генерации исключения. Для этого нужно просто использовать ключевое слово throw внутри блока catch без указания идентификатора. Например:
#include <iostream>
using namespace std;

class Parent
{
public:
    Parent() {}
    virtual void print() { cout << "Parent"; }
};

class Child: public Parent
{
public:
    Child() {}
    virtual void print() { cout << "Child"; }
};

int main()
{
    try
    {
        try
        {
            throw Child();
        }
        catch (Parent& p)
        {
            cout << "Caught Parent p, which is actually a ";
            p.print();
            cout << "\n";
            throw; // Мы здесь повторно выбрасываем исключение
        }
    }
    catch (Parent& p)
    {
        cout << "Caught Parent p, which is actually a ";
        p.print();
        cout << "\n";
    }

    return 0;
}


Результат выполнения программы:
Caught Parent p, which is actually a Child
Caught Parent p, which is actually a Child
Ключевое слово throw в блоке catch на первый взгляд не генерирует что-либо конкретное, а на самом деле генерирует точно такое же исключение, которое было только что обработано блоком catch. Не выполняется копирования исключения и, следовательно, обрезки объекта.
При повторной генерации исключения используйте ключевое слово throw без указания идентификатора.
Функциональный try-блок
Функциональности блоков try и catch достаточно в большинстве случаев, но есть одна ситуация, в которой это не так. Рассмотрим следующий код:
#include <iostream>
using namespace std;

class Parent
{
private:
    int m_age;
public:
    Parent(int age) : m_age(age)
    {
        if (age <= 0)
            throw 1;
    }
};

class Child : public Parent
{
public:
    Child(int age) : Parent(age)
    {
        // Что произойдет, если создать Parent не удастся, а исключение нужно обрабатывать здесь?
    }
};

int main()
{
    try
    {
        Child child(0);
    }
    catch (int)
    {
        cout << "Oops!\n";
    }
}

В этой программе дочерний класс Child вызывает конструктор родительского класса Parent, который генерирует исключение при успешном выполнении условия. Поскольку объект child создается в блоке try функции main(), если Parent выбросит исключение, блок try функции main() поймает его и передаст обработчику catch (int). Следовательно, результат выполнения этой программы будет таким:
Oops!
Но что, если нужно обрабатывать исключение внутри класса Child? Вызов конструктора родительского класса Parent происходит через список инициализации членов, перед выполнением тела конструктора класса Child. Поэтому использовать стандартный блок try здесь не получится.
В этой ситуации мы должны использовать слегка модифицированный блок try — функциональный try-блок.
Функциональный try-блок используется для установления обработчика исключений вокруг тела всей функции, а не ее части (блока кода). Рассмотрим на примере:
#include <iostream>
using namespace std;

class Parent
{
private:
    int m_age;
public:
    Parent(int age) : m_age(age)
    {
        if (age <= 0)
            throw 1;
    }
};

class Child : public Parent
{
public:
    Child(int age) try : Parent(age) // обратите внимание на ключевое слово try здесь
    {
    }
    catch (...) // Этот блок находится на том же уровне отступа, что и конструктор
    {
        // Исключения из списка инициализации членов класса Child или тела конструктора обрабатываются здесь

        cerr << "Construction of Parent failed\n";
        // Если мы здесь не будем явно выбрасывать исключение, то текущее (пойманное) исключение будет повторно сгенерировано и отправлено в стек вызовов
    }
};

int main()
{
    try
    {
        Child child(0);
    }
    catch (int)
    {
        cout << "Oops!\n";
    }
}


Результат выполнения программы:
Construction of Parent failed
Oops!
Рассмотрим эту программу более подробно.
Обратите внимание на добавление ключевого слова try перед списком инициализации членов класса класса Child. Это означает, что все, что находится после этого ключевого слова (вплоть до конца функции), рассматривается как часть блока try.
Блок catch находится на том же уровне отступа, что и вся функция. Любое исключение, выброшенное между ключевым словом try и концом тела конструктора, будет обработано этим же блоком catch.
Обычные блоки catch либо обрабатывают исключения, либо выбрасывают новое, либо повторно генерируют пойманное исключение. Но при использовании функциональных блоков try вы должны либо выбросить новое исключение, либо повторно сгенерировать пойманное. Если этого не сделать, пойманное исключение будет повторно сгенерировано и стек начнет раскручиваться.
Так как в программе выше мы явно не генерируем исключение внутри блока catch, исключение повторно генерируется и передается caller’у на уровень выше, то есть функции main(). Блок catch функции main() ловит и обрабатывает исключение.
Функциональные try-блоки также могут использоваться и с обычными функциями, которые не являются методами класса. Но это не распространенная практика, так как случаев, где они могут быть полезны, очень мало. Они почти всегда используются только с конструкторами!
Недостатки и опасности использования исключений
Начинающие программисты, используя исключения, сталкиваются с проблемой очистки выделенных ресурсов после генерации исключения. Рассмотрим следующий пример:
try
{
    openFile(filename);
    writeFile(filename, data);
    closeFile(filename);
}
catch (FileException &exception)
{
    cerr << "Failed to write to file: " << exception.what() << endl;
}

Что произойдет, если writeFile() не сработает и выбросит объект класса-ислючения FileException? К этому моменту мы уже открыли файл, и точка выполнения перейдет к обработчику catch, который выведет ошибку и завершит свое выполнение. Обратите внимание: операция закрытия файла closeFile(filename) никогда не выполнится! Чтобы этого избежать, нужно добавить перед выводом сообщения об ошибке команду на закрытие файла.
Такой же тип ошибок возникает и при выделении динамической памяти.
В отличие от конструкторов, где генерация исключений может быть полезным способом указать, что создать объект не удалось, исключения никогда не должны генерироваться в деструкторах.
Проблема возникает, когда исключение генерируется в деструкторе во время раскручивания стека. Если это происходит, компилятор оказывается в ситуации, когда он не знает, продолжать ли процесс раскручивания стека или обработать новое исключение. Программа немедленно прекратит выполнение.
Лучше вообще воздержаться от использования исключений в деструкторах. Лучше вместо этого записать ошибку в лог-файл.
У производительности исключений есть своя небольшая цена. Они увеличивают размер исполняемого файла и могут заставить его выполняться медленнее из-за дополнительной проверки. Тем не менее основное снижение производительности происходит при выбрасывании исключения. В этот момент стек начинает раскручиваться и выполняется поиск соответствующего обработчика исключений, что само по себе затратная операция.
Исключения и их обработку лучше всего использовать, если выполняются все следующие условия:
Обрабатываемая ошибка возникает редко.
Ошибка является серьезной, и выполнение программы не может продолжаться без ее обработки.
Ошибка не может быть обработана в том месте, где она возникает.
Нет хорошего альтернативного способа вернуть код ошибки обратно в caller.
Практическое задание
Написать шаблонную функцию div, которая должна вычислять результат деления двух параметров и запускать исключение DivisionByZero, если второй параметр равен 0. В функции main выводить результат вызова функции div в консоль, а также ловить исключения.
Написать класс Ex, хранящий вещественное число x и имеющий конструктор по вещественному числу, инициализирующий x значением параметра. Написать класс Bar, хранящий вещественное число y (конструктор по умолчанию инициализирует его нулем) и имеющий метод set с единственным вещественным параметром a. Если y + a > 100, возбуждается исключение типа Ex с данными a*y, иначе в y заносится значение a. В функции main завести переменную класса Bar и в цикле в блоке try вводить с клавиатуры целое n. Использовать его в качестве параметра метода set до тех пор, пока не будет введено 0. В обработчике исключения выводить сообщение об ошибке, содержащее данные объекта исключения.
Написать класс «робот», моделирующий перемещения робота по сетке 10x10, у которого есть метод, означающий задание переместиться на соседнюю позицию. Эти методы должны запускать классы-исключения OffTheField, если робот должен уйти с сетки, и IllegalCommand, если подана неверная команда (направление не находится в нужном диапазоне). Объект исключения должен содержать всю необходимую информацию — текущую позицию и направление движения. Написать функцию main, пользующуюся этим классом и перехватывающую все исключения от его методов, а также выводящую подробную информацию о всех возникающих ошибках.
Дополнительные материалы
Бьерн Страуструп. Программирование. Принципы и практика использования С++.
Стивен Прата. Язык программирования С++. Лекции и упражнения.
Роберт Лафоре. Объектно-ориентированное программирование в С++.
Используемая литература
Для подготовки данного методического пособия были использованы следующие ресурсы:
Исключения в С++ (exception).
Бьерн Страуструп. Программирование. Принципы и практика использования С++.
Ральф Джонсон, Ричард Хелм, Эрих Гамма. Приемы объектно-ориентированного программирования. Паттерны проектирования.

*/

void Metoda()
{
    cout << "METODA" << endl;
    cout << "------------------" << endl;
}