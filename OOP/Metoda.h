#pragma once

// МЕТОДИЧКА
// ------------------


// УРОК №1
//--------


/*
Основные понятия ООП.Инкапсуляция

История и причины возникновения ООП.
Классы и объекты.Методы классов.Инкапсуляция данных и методы доступа.
Средства ограничения доступа.Список инициализации членов класса.
Конструкторы и деструкторы.

Введение в ООП
Классы и объекты
Методы и свойства класса
Спецификаторы доступа public и private
Инкапсуляция
Set - и get - функции
Конструкторы
Список инициализации членов класса
Инициализация членов класса
Деструкторы
Статические переменные - члены класса
Практическое задание
Дополнительные материалы
Используемая литература

Введение в ООП
Объектно - ориентированное программирование — это парадигма программирования, основные концепции которой — понятия объектов и классов.
Ранее вы изучали процедурное программирование, подразумевающее простое последовательное выполнение набора команд.
В ООП все команды также выполняются последовательно, но есть существенное отличие в подходе к архитектуре : программист рассматривает все составные части программы как объекты со свойствами и поведением.
ООП позволяет создавать объекты, которые объединяют несколько разнотипных данных, их свойства и функции.
Чтобы понять концепцию ООП, обратимся к реальной жизни.Вокруг нас находятся объекты : магазины, автомобили, книги, люди.Все они имеют два основных компонента :
список свойств(цвет, размер, вес, форма и другие);
список поведений(делать что - то, открывать и т.д.).
В программировании мы не ориентируемся на написание функций, а сосредотачиваемся на определении объектов, которые имеют поля(свойства) и методы(виды поведения).
Основные причины популярности ООП :
повышение производительности и надежности программ;
создание больших блоков программного кода, пригодных для многократного использования;
упрощение написания и понимания кода.
Принципы ООП не заменяют традиционные методы программирования, а дополняют их.
Основными концепциями ООП являются абстракция, инкапсуляция, наследование и полиморфизм — рассмотрим их на ближайших уроках.
Классы и объекты
Для решения относительно простых задач язык С++ предоставляет ряд примитивных типов данных(int, double, char и другие).Для более сложных их может не хватать, поэтому С++ позволяет создавать пользовательские типы данных — например, перечисления(enum) и структуры(struct).
В следующем коде создается структура для хранения даты :
struct DateStruct
{
    int day;
    int month;
    int year;
};


Создадим перечисления для типа данных, хранящего дни недели :
enum days_of_week { Sun, Mon, Tue, Wed, Thu, Fri, Sat };


Перечисления и структуры — это средства традиционного подхода к программированию, поскольку с их помощью можно только хранить данные.Чтобы с ними можно было работать, необходимо создавать отдельные функции.Для вывода текущей даты напишем соответствующую функцию — вот полный код программы :
#include <iostream>
struct DateStruct
{
    int day;
    int month;
    int year;
} today = { 12, 12, 2018 };

void print(DateStruct& date)
{
    std::cout << date.day << "/" << date.month << "/" << date.year;
}

int main()
{
    today.day = 18; // используем оператор выбора члена для выбора члена структуры
    print(today);

    return 0;
}


Результат выполнения программы : 18 / 12 / 2018.
В парадигме ООП типы данных могут содержать не только данные, но и функции для их обработки.Чтобы определить такой тип данных, используется ключевое слово class.Структуры и классы по своему строению очень похожи, однако у классов больше возможностей.Фактически, следующая структура и класс идентичны :
struct DateStruct
{
    int day;
    int month;
    int year;
};

class DateClass
{
public:
    int m_day;
    int m_month;
    int m_year;
};


Единственное отличие — наличие ключевого слова public, о котором мы поговорим чуть позже.
Объявление класса, как и структуры, не приводит к выделению памяти до тех пор, пока мы не создадим переменную этого типа.Такая переменная называется экземпляром класса или объектом.Следующий фрагмент создает объект класса :
DateClass today{ 12, 11, 2018 }; // объявляем переменную класса DateClass


Для объекта today уже будет выделена память.
Структуры и классы выступают шаблонами, по которым может быть создано несколько объектов.В этом и заключается их главное достоинство — формирование единообразных данных, с которыми можно одинаковым образом работать.
Методы и свойства класса
Переменные, объявленные внутри класса, называются свойствами или переменными - членами.Помимо этого класс может содержать функции : методы или функции - члены.Методы могут быть определены как внутри класса, так и вне него.Программа объявления метода вывода даты, объявленного внутри класса :
class DateClass
{
public:
    int m_day;
    int m_month;
    int m_year;

    void printDate() // определяем функцию-член
    {
        std::cout << m_day << "/" << m_month << "/" << m_year;
    }
    void printYear();
};

// определяем функцию-член вне класса
void DateClass::printYear()
{
    std::cout << m_year << " year";
}



К методам и свойствам класса обращаются с помощью оператора «точка»(.) :
#include <iostream>

    class DateClass
{
public:
    int m_day;
    int m_month;
    int m_year;

    void print()
    {
        std::cout << m_day << "/" << m_month << "/" << m_year;
    }
};

int main()
{
    DateClass today{ 12, 12, 2018 };

    today.m_day = 18;
    today.print(); // используем оператор (.) для вызова метода объекта today класса DateClass

    return 0;
}

Результат выполнения программы : 18 / 12 / 2018.
Вызов функций - членов должен быть связан с объектом класса.Так компилятор может понять, для какого объекта вызывается функция.В определении самой функции мы не указываем, какому объекту принадлежат переменные.В данном примере мы просто обратились к членам - переменным с помощью строчки :
std::cout << m_day << "/" << m_month << "/" << m_year;

Такая запись возможна потому, что компилятор автоматически интерпретирует m_day как today.m_day и т.д.Связанный объект неявно передается функции - члену, поэтому такой объект называется неявным объектом.

Спецификаторы доступа public и private
Рассмотрим следующую программу, в которой нет ошибки :
struct DateStruct // члены структуры являются открытыми по умолчанию
{
    int day; // открыто по умолчанию, доступ имеет любой объект
    int month; // открыто по умолчанию, доступ имеет любой объект
    int year; // открыто по умолчанию, доступ имеет любой объект
};

int main()
{
    DateStruct date;
    date.day = 12;
    date.month = 11;
    date.year = 2018;

    return 0;
}

Данные члены структуры — открытые, или публичные(public - члены).К ним можно получить доступ извне этой структуры.
Теперь рассмотрим следующий код :
class DateClass // члены класса являются закрытыми по умолчанию
{
    int m_day; // закрыто по умолчанию, доступ имеют только другие члены класса
    int m_month; // закрыто по умолчанию, доступ имеют только другие члены класса
    int m_year; // закрыто по умолчанию, доступ имеют только другие члены класса
};

int main()
{
    DateClass date;
    date.m_day = 12; // ошибка
    date.m_month = 11; // ошибка
    date.m_year = 2018; // ошибка

    return 0;
}


Компилятор сообщает об ошибках, так как переменные класса являются закрытыми по умолчанию.Члены private — это члены класса, которые не могут быть изменены извне, и доступ к которым возможен только для других членов класса.

Хотя по умолчанию члены класса являются private, мы можем сделать их открытыми :
class DateClass
{
public: // обратите внимание, ключевое слово public и двоеточие
    int m_day; // открыто, доступ имеет любой объект
    int m_month; // открыто, доступ имеет любой объект
    int m_year; // открыто, доступ имеет любой объект
};

int main()
{
    DateClass date;
    date.m_day = 12; // ок, так как m_day имеет спецификатор доступа public
    date.m_month = 11;  // ок, так как m_month имеет спецификатор доступа public
    date.m_year = 2018;  // ок, так как m_year имеет спецификатор доступа public

    return 0;
}


Ключевое слово public является спецификатором доступа.В С++ есть три уровня доступа : public, private, protected.Спецификаторы доступа указывают, кто имеет доступ к членам класса.Спецификатор доступа protected (защищенный)рассмотрим далее.


В классе можно использовать несколько спецификаторов доступа.Как правило, для переменных - членов устанавливается доступ private, а для функций - членов — public.Порядок написания не имеет значения.
#include <iostream>

class DateClass // члены класса являются закрытыми по умолчанию
{
private:
    int m_day; // закрыто по умолчанию, доступ имеют только другие члены класса
    int m_month; // закрыто по умолчанию, доступ имеют только другие члены класса
    int m_year; // закрыто по умолчанию, доступ имеют только другие члены класса

public:
    void setDate(int day, int month, int year) // открыто, доступ имеет любой объект
    {
        // метод setDate() имеет доступ к закрытым членам класса, так как сам является членом класса
        m_day = day;
        m_month = month;
        m_year = year;
    }

    void print() // открыто, доступ имеет любой объект
    {
        std::cout << m_day << "/" << m_month << "/" << m_year;
    }
};

int main()
{
    DateClass date;
    date.setDate(12, 12, 2018); // ок, так как setDate() имеет спецификатор доступа public
    date.print(); // ок, так как print() имеет спецификатор доступа public

    return 0;
}

Мы не получим напрямую доступ к переменным класса, но можем через public - методы.Это основной механизм, который позволяет скрыть одно и открыть другое.

Следует отметить, что спецификаторы доступа работают на основе класса, то есть public - методы могут работать с private - переменными как данного объекта, так и любого другого :
#include <iostream>

class DateClass // члены класса являются закрытыми по умолчанию
{
private:  // данный спецификатор можно не указывать
    int m_day; // закрыто по умолчанию, доступ имеют только другие члены класса
    int m_month; // закрыто по умолчанию, доступ имеют только другие члены класса
    int m_year; // закрыто по умолчанию, доступ имеют только другие члены класса

public:
    void setDate(int day, int month, int year)
    {
        m_day = day;
        m_month = month;
        m_year = year;
    }
    void print()
    {
        std::cout << m_day << "/" << m_month << "/" << m_year;
    }
    // Обратите внимание на этот дополнительный метод
    void copyFrom(const DateClass& b)
    {
        // Мы имеем прямой доступ к закрытым членам объекта b
        m_day = b.m_day;
        m_month = b.m_month;
        m_year = b.m_year;
    }
};

int main()
{
    DateClass date;
    date.setDate(12, 12, 2018); // ок, так как setDate() имеет спецификатор доступа public

    DateClass copy;
    copy.copyFrom(date); // ок, так как copyFrom() имеет спецификатор доступа public
    copy.print();

    return 0;
}

Функция copyFrom() имеет доступ к private - членам класса m_day, m_month, m_year — так как private - членам класса имеют доступ только функции, принадлежащие этому классу.Это означает, что она может напрямую обращаться как к закрытым членам неявного объекта, так и к членам объекта b(другого).

Инкапсуляция
Инкапсуляция(сокрытие информации) — это процесс скрытого хранения деталей реализации объекта.В С++ инкапсуляция реализована с помощью спецификаторов доступа.Инкапсулированные классы проще в применении и уменьшают сложность программ.Один и тот же класс можно использовать в разных программах, при этом не заботиться о том, как устроен класс изнутри : достаточно просто знать его методы.Также инкапсуляция защищает ваши данные и предотвращает неправильное использование.Рассмотрим класс с public - переменной - массивом :
    class IntArray
{
public:
    int m_array[10];
};


Если бы пользователи напрямую обращались к массиву, могли бы использовать недопустимый индекс :
int main()
{
    IntArray array;
    array.m_array[16] = 2; // некорректный индекс
}


Но если мы сделаем массив закрытым, сможем заставить пользователя вызывать функцию, которая первым делом проверяет корректность индекса :
class IntArray
{
private:
    int m_array[10]; // пользователь не имеет прямой доступ к этому члену

public:
    void setValue(int index, int value)
    {
        // Если индекс недействителен, то не делаем ничего
        if (index < 0 || index >= 10)
            return;

        m_array[index] = value;
    }
};

Таким образом защитим программу от ошибок.
Инкапсулированные классы легче изменять и отлаживать, они проще в использовании, позволяют избегать ошибок и уменьшают сложность программы.
Set - и get - функции
В некоторых программах есть необходимость получать и изменять private - значения.Для этого разработчики пишут специальные public - функции для доступа к закрытым значениям.Для получения значения private - переменной(члена класса) используют get - функцию.Чтобы изменить ее значение — set - функцию.
class Date
{
private:
    int m_day;
    int m_month;
    int m_year;

public:
    int getDay() { return m_day; } // get-функция для day
    void setDay(int day) { m_day = day; } // set-функция для day

    int getMonth() { return m_month; } // get-функция для month
    void setMonth(int month) { m_month = month; } // set-функция для month

    const int& getYear() { return m_year; } // get-функция для year,возвращает значение по константной ссылке
    void setYear(int year) { m_year = year; } // set-функция для year
};


Пишите set - и get - функции только для тех классов, для которых это необходимо;
Get - функции должны возвращать значения по значению или по константной ссылке, которая не дает права изменять значение переменной в функции get().Не используйте неконстантные ссылки.Таким образом мы страхуемся от изменения значений.
Конструкторы
Конструктор — это особый тип метода класса, который автоматически вызывается при создании объекта этого класса.Конструкторы обычно используются для инициализации переменных - членов класса соответствующими значениями, которые предоставлены по умолчанию или пользователем.Еще они применяются для выполнения любых шагов настройки, необходимых для используемого класса.
В отличие от обычных методов, для конструкторов есть свои правила :
они всегда должны иметь то же имя, что и класс(учитывается верхний и нижний регистры);
у конструкторов нет типа возврата(даже void’а);
конструкторы вызываются автоматически при создании объекта;
нельзя вызвать конструктор для уже существующего экземпляра.
Конструктор, не имеющий параметров, называется конструктором по умолчанию.Чтобы создать объект с определенными значениями, используется конструктор с параметрами.В одном классе их может быть несколько — главное, чтобы их параметры были уникальными(учитывается количество и тип).Это возможно благодаря перегрузке функций.

#include <iostream>

class Date
{
private:
    int m_day;
    int m_month;
    int m_year;

public:
    void setDay(int day) { m_day = day; }
    int getDay() { return m_day; }
};

int main()
{
    Date date;
    date.setDay(7);
    std::cout << date.getDay() << '\n';
}

Старайтесь создавать хотя бы один конструктор, даже если он будет пустым.
Если один класс содержит другой в качестве переменной - члена, то конструктор внутреннего класса будет вызван раньше конструктора внешнего класса :
#include <iostream>

class Time
{
public:
    Time() { std::cout << "Time\n"; }
};

class Date
{
private:
    Time m_time; // Date содержит Time, как переменную-член

public:
    Date() { std::cout << "Date\n"; }
};

int main()
{
    Date date;
    return 0;
}

Результат выполнения данной программы :
Time
Date
При создании объекта date вызывается конструктор класса Time, а затем конструктор класса Date.В этом есть смысл, так как конструктор Date() может захотеть использовать переменную m_time, поэтому сначала нужно ее инициализировать.
Список инициализации членов класса
Константные типы данных должны быть инициализированы во время объявления.Если это константные переменные - члены, то инициализировать их с помощью конструктора нельзя.Для решения этой проблемы используются списки инициализации членов.Такой список располагается сразу после параметров конструктора и начинается с двоеточия(:), а затем в круглых скобках указывается значение для каждой переменной.Список инициализаторов не заканчивается точкой с запятой.
Пример использования списка инициализаторов членов :
class Date
{
private:
    const int m_day;
    const int m_month;
    const char* m_dayOfWeek; // День недели


public:
    Date(int day, int month, char* dayOfWeek = "mon")
        : m_day(day), m_month(month), m_dayOfWeek(dayOfWeek) // напрямую инициализируем переменные-члены класса
    {
        // Нет необходимости использовать присваивание
    }

    void print()
    {
        std::cout << "Date: " << m_day << ", " << m_month << ", " << m_dayOfWeek;
    }

};

int main()
{
    Date date(3, 5); // day = 3, month = 5, dayOfWeek = “mon” (значение по умолчанию)
    date.print();
    return 0;
}

Результат: Date: 3, 5, mon
Используйте списки инициализации вместо операций присваивания, чтобы инициализировать переменные - члены вашего класса.
Переменные в списке инициализаторов инициализируются не в том порядке, в котором указаны в списке инициализации, а в котором объявлены в классе.
Инициализация членов класса
Если при написании класса с несколькими конструкторами указывать значения по умолчанию всем их членам, появится лишний код(DRY — Don’t Repeat Yourself).В таких случаях переменным - членам класса можно задать значение напрямую.При инициализации переменных через список инициализации членов приоритет будет отдан последнему.
Пример инициализации членов класса :
#include <iostream>

class Rectangle
{
private:
    double m_length = 3.5;
    double m_width = 3.5;

public:
    Rectangle() // конструктор по умолчанию (присваиваются значения по умолчанию выше)
    {
    }

    Rectangle(double length, double width)
        : m_length(length), m_width(width)
    {
        // m_length и m_width инициализируются конструктором (значения по умолчанию выше не используются)
    }

    void print()
    {
        std::cout << "length: " << m_length << " and width: " << m_width << '\n';
    }
};

int main()
{
    Rectangle one;
    one.print();
    Rectangle two(4.5, 5.5);
    two.print();
    return 0;
}

Программа выведет :
length: 3.5 and width : 3.5
length : 4.5 and width : 5.5
Деструкторы
Деструктор — это функция - член, которая выполняется при удалении объекта класса.
Если объект содержит динамически выделенную память, или файл, или базу данных, деструктор может освободить память перед уничтожением объекта.
Как и у конструкторов, у деструкторов есть правила, которые касаются их названий :
деструктор должен иметь то же имя, что и класс, но со знаком «тильда»(~) перед ним;
деструктор не может принимать аргументы(следовательно, не может быть перегружен);
у деструктора нет типа возврата.
Рассмотрим пример программы, содержащей деструктор :
#include <iostream>
#include <cassert>

class Array
{
private:
    int* m_array;
    int m_length;

public:
    Array(int length) // конструктор
    {
        assert(length > 0);

        m_array = new int[length];
        m_length = length;
    }

    ~Array() // деструктор
    {
        // Динамически удаляем массив, который выделили ранее
        delete[] m_array;
    }

    void setValue(int index, int value) { m_array[index] = value; }
    int getValue(int index) { return m_array[index]; }
    int getLength() { return m_length; }
};

int main()
{
    Array arr(15); // выделяем 15 целочисленных значений
    for (int count = 0; count < 15; ++count)
        arr.setValue(count, count + 1);
    std::cout << "The value of element 7 is " << arr.getValue(7);
    return 0;
} // объект arr

Результат выполнения : The value of element 7 is 8
В конце функции main() объект arr выходит из области видимости, что приводит к вызову деструктора и удалению массива.
Обратите внимание, что в данной программе используется оператор assert — это макрос препроцессора, который обрабатывает условное выражение во время выполнения.Если оно истинно, оператор assert ничего не делает.Если же оно ложное, то выводится сообщение об ошибке и программа завершается.Это сообщение содержит ложное условное выражение, а также имя файла с кодом и номером строки с assert.Таким образом можно легко понять, какая была проблема и где она возникла, что очень помогает при отладке программ.
Сам assert реализован в заголовочном файле <cassert> и часто используется для проверки корректности переданных параметров функции и ее возвращаемого значения.
Статические переменные - члены класса
В C++ ключевое слово static используется при создании статических переменных - членов и статических методов.Переменные - члены класса можно сделать статическими, используя ключевое слово static.В отличие от обычных переменных - членов, статические являются общими для всех объектов класса.Рассмотрим следующую программу :
class Rectangle
{
public:
    static int m_square;
};

int Rectangle::m_square = 3;

int main()
{
    Rectangle first;
    Rectangle second;

    std::cout << first.m_square << '\n';
    first.m_square = 4;
    std::cout << second.m_square << '\n';
    return 0;
}


Результат:
3
4
Поскольку m_square — это статическая переменная - член, она является общей для всех объектов класса Rectangle.Следовательно, first.m_square — это та же переменная, что и second.m_square.Программа выше показывает, что к значению, которое мы установили через первый объект, можно получить доступ и через второй.
Хотя вы можете получить доступ к статическим членам через разные объекты класса(как в примере выше), оказывается, статические члены существуют, даже если объекты класса не созданы!Подобно глобальным переменным, они создаются при запуске программы и уничтожаются, когда программа завершает выполнение.
Следовательно, статические члены принадлежат классу, а не его объектам.Поскольку m_square существует независимо от любых объектов класса, то доступ к нему осуществляется напрямую через имя класса и оператор разрешения области видимости(в данном случае — Rectangle::m_square).
Обратите внимание : это определение статического члена не подпадает под действия спецификаторов доступа.Вы можете определить и инициализировать m_square, даже если оно будет private.
Практическое задание
Создать класс Power, который содержит два вещественных числа.Этот класс должен иметь две переменные - члена для хранения этих вещественных чисел.Еще создать два метода : один с именем set, который позволит присваивать значения переменным, второй — calculate, который будет выводить результат возведения первого числа в степень второго числа.Задать значения этих двух чисел по умолчанию.
Написать класс с именем RGBA, который содержит 4 переменные - члена типа std::uint8_t : m_red, m_green, m_blue и m_alpha(#include cstdint для доступа к этому типу).Задать 0 в качестве значения по умолчанию для m_red, m_green, m_blue и 255 для m_alpha.Создать конструктор со списком инициализации членов, который позволит пользователю передавать значения для m_red, m_blue, m_green и m_alpha.Написать функцию print(), которая будет выводить значения переменных - членов.
Написать класс, который реализует функциональность стека.Класс Stack должен иметь :
private - массив целых чисел длиной 10;
private целочисленное значение для отслеживания длины стека;
public - метод с именем reset(), который будет сбрасывать длину и все значения элементов на 0;
public - метод с именем push(), который будет добавлять значение в стек.push() должен возвращать значение false, если массив уже заполнен, и true в противном случае;
public - метод с именем pop() для вытягивания и возврата значения из стека.Если в стеке нет значений, то должно выводиться предупреждение;
public - метод с именем print(), который будет выводить все значения стека.
Код main() :
    int main()
{
    Stack stack;
    stack.reset();
    stack.print();

    stack.push(3);
    stack.push(7);
    stack.push(5);
    stack.print();

    stack.pop();
    stack.print();

    stack.pop();
    stack.pop();
    stack.print();

    return 0;
}


Этот код должен выводить :
()
(3 7 5)
(3 7)
()
Дополнительные материалы
Бьерн Страуструп.Программирование.Принципы и практика использования С++.
Стивен Прата.Язык программирования С++.Лекции и упражнения.
Роберт Лафоре.Объектно - ориентированное программирование в С++.
Используемая литература
Для подготовки данного методического пособия были использованы следующие ресурсы :
Онлайн справочник программиста на C и C++.Инкапсуляция.
Бьерн Страуструп.Программирование.Принципы и практика использования С++.
Ральф Джонсон, Ричард Хелм, Эрих Гамма.Приемы объектно - ориентированного программирования.Паттерны проектирования.
*/



// УРОК №2
//--------



/*
Наследование
Управление доступом к базовому классу. Конструкторы и наследование. Создание многоуровневой иерархии классов. Указатели на производные классы. Простое и множественное наследование.

Константные объекты классов
Определение методов вне класса
Скрытый указатель this
Базовое наследование
Дружественные функции
Дружественные классы
Спецификатор доступа protected
Типы наследования
Указатели и ссылки на производные классы
Множественное наследование
Практическое задание
Дополнительные материалы
Используемая литература



Константные объекты классов
По аналогии с фундаментальными типами данных (int, float, char) объекты классов также могут быть константными. Для таких объектов запрещается изменять переменные-члены, а также вызывать их напрямую (даже если они public). Но есть способ получить значение переменной: использовать константный метод, который также должен быть объявлен в классе (например, константная get-функция-член). Константный метод гарантирует, что объект не будет изменяться. Рассмотрим следующий пример:
class Time
{
public:
    int m_hours;

    Time() { m_hours = 0; }

    void resetHours() { m_hours = 0; }
    void setHours(int value) { m_hours = value; }

    int getHours() const { return m_hours; }
    // ключевое слово const находится после списка параметров, но перед телом функции
};

В данном примере мы можем вызвать метод getHours() через любой константный объект.
Старайтесь делать все методы, которые не изменяют данные объекта, константными.

Если нужно передать внешней функции объект, сделаем это по ссылке, так как по значению будет нерационально. Передадим константную ссылку, чтобы функция случайно не изменила значение своего параметра.
#include <iostream>

class Date
{
private:
    int m_day;
    int m_month;
    int m_year;

public:
    Date(int day, int month, int year)
    {
        setDate(day, month, year);
    }

    void setDate(int day, int month, int year)
    {
        m_day = day;
        m_month = month;
        m_year = year;
    }

    int getDay() const { return m_day; }
    int getMonth() const { return m_month; }
    int getYear() const { return m_year; }
};

// Мы передаем объект date по константной ссылке, чтобы избежать создания копии объекта date
void printDate(const Date &date)
{
    std::cout << date.getDay() << "." << date.getMonth() << "." << date.getYear() << '\n';
}

int main()
{
    Date date(12, 11, 2018);
    printDate(date);

    return 0;
}

В данном примере передаем функции printDate() константный объект. Через него вызываем методы getDay(), getMonth(), getYear(), которые тоже должны быть константными.
Определение методов вне класса
Функции-члены могут быть определены как внутри класса, так и за его пределами. Первый способ определения мы уже рассматривали — поговорим о втором.
Чтобы функцию-член класса определить вне класса, в нем определяют только прототип самой функции, а ее тело — вне класса, используя в качестве префикса имя класса с оператором разрешения области видимости (::).
class Date
{
private:
    int m_day;
    int m_month;
    int m_year;

public:
    Date(int day, int month, int year);

    void SetDate(int day, int month, int year);

    int getDay() { return m_day; }
    int getMonth() { return m_month; }
    int getYear()  { return m_year; }
};

// Конструктор класса Date
Date::Date(int day, int month, int year)
{
    SetDate(day, month, year);
}

// Метод класса Date
void Date::SetDate(int day, int month, int year)
{
    m_day = day;
    m_month = month;
    m_year = year;
}


Скрытый указатель this
Может возникнуть вопрос: как при вызове метода класса C++ отслеживает, какой объект его вызвал? Ответ: C++ использует скрытый указатель this!
Пусть объект date класса Date вызывает метод setDate(): date.setDate(4, 5, 2019). Хотя кажется, что здесь только три аргумента, на самом деле их четыре. Во время компиляции эта строчка будет конвертирована в следующую: setDate(&date, 4, 5, 2019).
Теперь это всего лишь стандартный вызов функции, а объект date теперь передается по адресу в качестве аргумента функции.
Поскольку в вызове функции теперь четыре аргумента, то и метод нужно изменить соответствующим образом — чтобы он их принимал:
void setDate(Date* const this, int day, int month, int year) {
 this->m_day = day;
this->m_month = month;
this->m_year = year; }

При компиляции обычного метода компилятор неявно добавляет к нему параметр this — это скрытый константный указатель, который содержит адрес объекта, который вызывает метод класса.
Еще одна деталь: внутри метода также необходимо обновить все члены класса (функции и переменные), чтобы они ссылались на объект, который вызывает этот метод. Это легко сделать, добавив префикс this-> к каждому из них. Таким образом, в теле функции setDate(), m_day (переменная-член класса) будет конвертирована в this->m_day и так далее. И когда *this указывает на адрес date, то this->m_day будет указывать на date.m_day.
Указатель *this является скрытым параметром, который неявно добавляется к каждому методу класса. В большинстве случаев нам не нужно обращаться к нему напрямую, но при необходимости это можно сделать. Стоит отметить, что this является константным указателем: вы можете изменить значение исходного объекта, но нельзя заставить this указывать на что-то другое.
class Day {
private:
    int day;
public:
    Day(int day) {
        this->day = day;
    }
};

int main() {
    Day(4);
}


Базовое наследование
Идею наследования в С++ легко понять через аналогию с реальной жизнью. Яблоки и груши — это фрукты, и они унаследовали все свойства, которые имеют такие плоды (цвет, размер и подобное). Но и у яблок, и у груш есть индивидуальные свойства.
Вернемся к программированию. Наследование в С++ происходит между классами. Родительский (базовый) класс — это тот, от которого наследуются свойства и методы. Дочерний (производный) класс — это тот, который наследует.
Определим родительский класс Human():
#include <string>

class Human
{
public:
    std::string m_name;
    int m_age;

    Human(std::string name = "", int age = 0)
    : m_name(name), m_age(age)
    {
    }

    std::string getName() const { return m_name; }
    int getAge() const { return m_age; }

};


В нем определены только общие свойства, которые есть у любого человека: имя и возраст.
Теперь определим дочерний класс Employee():
// Employee открыто наследует Human
class Employee : public Human
{
public:
    string m_employer;
    double m_wage;

    Employee(string employer, double wage)
    : m_employer(employer), m_wage(wage)
    { }
};


В этом классе мы добавили еще две переменные-члена, которые являются специфичными для данного класса. При этом переменные класса Human() также являются переменными-членами класса Employee(). Обратите внимание, что тип наследования public (об этом поговорим дальше), а родительский класс указывается через двоеточие.
int main()
{
    // Создаем нового сотрудника
    Employee anton;
    // Присваиваем ему имя (мы можем делать это напрямую, так как m_name является public)
    anton.m_name = "Anton";
    // Выводим имя сотрудника
    std::cout << anton.getName() << '\n';
    // используем метод getName(), который мы унаследовали от класса Human
    return 0;
}

Результат выполнения этого кода: Anton
От одного класса могут наследовать несколько классов: от Human() может наследовать Employee() и другие.
Также можно создавать цепочки наследований: от класса Employee() может наследовать класс Supervisor(). Для него родительским классом будет Employee().
Построение дочернего класса начинается с самого верхнего родительского класса и заканчивается нижним классом иерархии. По мере построения выполняются и конструкторы: сначала конструктор топового класса, а в конце — дочернего. Деструкторы выполняются в обратном порядке.
Чтобы создать объект дочернего класса, необязательно создавать объект базового. А чтобы передать значения конструктору базового класса, не создавая сам объект, следует вызвать конструктор базового класса с нужными параметрами в списке инициализации производного класса. Пример такого объявления:
#include <string>
using namespace std;
class Human
{
private:
    string m_name;
    int m_age;

public:
    Human(string name = "", int age = 0) : m_name(name), m_age(age )
    { }

    string getName() const { return m_name; }
    int getAge() const { return m_age; }

};
class Employee : public Human
{
private:
    string m_employer;
    double m_wage;
public:
    Employee(string name = "", int age = 0, string employer, double wage)
    : Human(name, age), // вызывается Human(std::string, int) для инициализации членов name и age
m_employer(employer), m_wage(wage)
    { }
    string getEmployer() const { return m_employer; }
    double getWage() const { return m_wage; }
};

Преимущество наследования в том, что не надо переопределять информацию из родительских классов в дочерние. Это эффективный способ разработки сложных программ. Например, все производные классы наследуют изменения родительского.

Дружественные функции
Дружественные функции имеют доступ к закрытым членам класса. Это могут  быть как обычные функции, так и методы других классов. Дружественные функции объявляются с помощью ключевого слова friend перед прототипом функции в том классе, дружественной для которого вы хотите ее сделать. Тело функции может быть объявлено в любом другом месте программы. Рассмотрим пример:
class Cat
{
private:
    int m_age;
    // Делаем функцию resetAge() дружественной классу Cat
    friend void resetAge(Cat &cat);
};

// resetAge() теперь является другом класса Cat
void resetAge(Cat &cat)
{
    // И мы имеем доступ к закрытым членам объектов класса Cat
    cat.m_age = 0;
}

int main()
{
    Cat Frisky;
    resetAge(Frisky);
    return 0;
}

Отметим, что в качестве параметра функция resetAge() принимает объект класса Cat.
Можно создавать дружественные функции для нескольких классов.
class Cat; //это прототип, сам класс определяем позже

class Dog
{
// ...
    friend void getAge(const Cat &cat, const Dog &dog);
};

class Cat
{
// ...
    friend void getAge(const Cat &cat, const Dog &dog);
};

void getAge(const Cat &cat, const Dog &dog)
{
// ...
}

В данном случае необходимо в самом начале объявить прототип класса Cat. Без этой строчки компилятор выдаст ошибку, так как упоминание об этом классе есть в дружественной функции. Обратите внимание, что параметры в функцию передаются по ссылке. Это необходимо для того, чтобы не создавались копии объектов, так как этот процесс может быть неэффективным. Const обеспечивает, что данные классы не будут изменяться в функции.
Дружественные классы
Один класс можно сделать дружественным другому. Это откроет всем членам первого класса доступ к закрытым членам второго:
#include <iostream>
using namespace std;

class Dog
{
private:
    int m_age;
public:
    Dog (int age) : m_age(age)
    { }
    // Делаем класс Cat другом классу Dog
    friend class Cat;
};

class Cat
{
private:
    int m_age;
public:
    Cat (int age) : m_age(age)
    { }
    bool compareAge(Cat &cat, Dog &dog) {
        // у нас есть доступ к private переменным класса Dog
        return dog.m_age<cat.m_age;
    }
};

int main() {
    Cat Frisky(4);
    Dog Spike(3);
    if (Frisky.compareAge(Frisky, Spike))
        cout << "Кот старше собаки";
    else
        cout << "Кот не старше собаки";
    return 0;
}

Поскольку класс Cat — другом класса Dog, то любой из членов Cat имеет доступ к private-членам Dog.
Обратите внимание: Cat — друг Dog, но Cat не имеет прямого доступа к указателю this * объектов Dog. И это не означает, что Dog также является другом Cat. Если хотите сделать оба класса дружественными, то они должны указать друг друга в таком качестве.

Спецификатор доступа protected
Спецификатор protected открывает доступ к члену класса для дружественных функций и дочерних классов.
class Parent
{
public:
    int m_public;           // доступ к этому члену открыт для всех объектов
private:
    int m_private;          // доступ к этому члену открыт только для других членов класса Parent и для дружественных классов/функций (но не для дочерних классов)
protected:
    int m_protected;        // доступ к этому члену открыт для других членов класса Parent, дружественных классов/функций, дочерних классов
};

class Child : public Parent
{
public:
    Child()
    {
        m_public = 1;     // разрешено: доступ к открытым членам родительского класса из дочернего класса
        m_private = 2;    // запрещено: доступ к закрытым членам родительского класса из дочернего класса
        m_protected = 3;  // разрешено: доступ к защищенным членам родительского класса из дочернего класса
    }
};

int main()
{
    Child child;
    child.m_public = 1; // разрешено: доступ к открытым членам класса извне
    child.m_private = 2; // запрещено: доступ к закрытым членам класса извне
    child.m_protected = 3; // запрещено: доступ к защищенным членам класса извне
}

Спецификатор доступа protected имеет смысл применять, только если количество дочерних классов невелико. Если в члене protected появятся изменения, их придется вносить как в родительский класс, так и во все дочерние.

Типы наследования
Тип наследования определяется с помощью спецификатора доступа, который указывается возле наследуемого класса. По умолчанию тип наследования определяется как private.
Всего есть 9 комбинаций наследования для членов класса:
Спецификатор доступа в родительском классе
Спецификатор доступа при наследовании типа public в дочернем классе
Спецификатор доступа при наследовании типа private в дочернем классе
Спецификатор доступа при наследовании типа protected в дочернем классе
Public
Public
Private
Protected
Private
Недоступен
Недоступен
Недоступен
Protected
Protected
Private
Protected



class Parent
{
public:
    int m_public;
private:
    int m_private;
protected:
    int m_protected;
};

class Child: public Parent   // открытое наследование
{
    // Открытое наследование означает, что:
    // члены public остаются public в дочернем классе
    // члены protected остаются protected в дочернем классе
    // члены private остаются недоступными в дочернем классе
public:
    Child()
    {
        m_public = 1;     // разрешено: доступ к m_public открыт
        m_private = 2;    // запрещено: доступ к m_private в дочернем классе из родительского класса закрыт
        m_protected = 3;  // разрешено: доступ к m_protected в дочернем классе из родительского класса открыт
    }
};

int main()
{
    Parent parent;
    parent.m_public = 1;    // разрешено: m_public доступен извне через родительский класс
    parent.m_private = 2;   // запрещено: m_private недоступен извне через родительский класс
    parent.m_protected = 3; // запрещено: m_protected недоступен извне через родительский класс

    Child pub;
    child.m_public = 1;     // разрешено: m_public доступен извне через дочерний класс
    child.m_private = 2; // запрещено: m_private недоступен извне через дочерний класс
    child.m_protected = 3; // запрещено: m_protected недоступен извне через дочерний класс
}


Самое распространенное наследование — открытое, оно же — самое легкое. Когда дочерний класс открыто наследует родительский, унаследованные члены public остаются public, protected — protected, а унаследованные члены private по-прежнему недоступны для дочернего класса. Используйте именно этот тип наследования, если нет острой необходимости делать иначе.
class Parent
{
public:
    int m_public;
private:
    int m_private;
protected:
    int m_protected;
};

class Child: private Parent  // закрытое наследование
{
    // Закрытое наследование означает, что:
    // члены public становятся private (m_public теперь private) в дочернем классе
    // члены protected становятся private (m_protected теперь private) в дочернем классе
    // члены private остаются недоступными (m_private недоступен) в дочернем классе
public:
    Child()
    {
        m_public = 1;        // разрешено: m_public теперь private в Priv
        m_private = 2;       // запрещено: дочерние классы не имеют доступ к закрытым членам родительского класса
        m_protected = 3;     // разрешено: m_protected теперь private в Priv
    }
};

int main()
{
    Parent parent;
    parent.m_public = 1;     // разрешено: m_public доступен извне через родительский класс
    parent.m_private = 2;    // запрещено: m_private недоступен извне через родительский класс
    parent.m_protected = 3;  // запрещено: m_protected недоступен извне через родительский класс

    Child child;
    child.m_public = 1;     // запрещено: m_public недоступен извне через дочерний класс
    child.m_private = 2;    // запрещено: m_private недоступен извне через дочерний класс
    child.m_protected = 3;  // запрещено: m_protected недоступен извне через дочерний класс
}


При закрытом наследовании все члены родительского класса наследуются как закрытые и поэтому невозможно к ним обратиться извне дочернего класса. Данный тип наследования полезен, когда дочерний класс слабо связан с родительским и мы не хотим, чтобы открытые члены были доступны через объекты дочернего класса.
class Parent
{
public:
    int m_public;
private:
    int m_private;
protected:
    int m_protected;
};

class Child: private Parent  // закрытое наследование
{
    // Закрытое наследование означает, что:
    // члены public становятся private (m_public теперь private) в дочернем классе
    // члены protected становятся private (m_protected теперь private) в дочернем классе
    // члены private остаются недоступными (m_private недоступен) в дочернем классе
public:
    Child()
    {
        m_public = 1;    // разрешено: m_public теперь private в Priv
        m_private = 2;   // запрещено: дочерние классы не имеют доступ к закрытым членам родительского класса
        m_protected = 3; // разрешено: m_protected теперь private в Priv
    }
};

int main()
{
    Parent parent;
    parent.m_public = 1;    // разрешено: m_public доступен извне через родительский класс
    parent.m_private = 2;   // запрещено: m_private недоступен извне через родительский класс
    parent.m_protected = 3; // запрещено: m_protected недоступен извне через родительский класс

    Child child;
    child.m_public = 1; // запрещено: m_public недоступен извне через дочерний класс
    child.m_private = 2; // запрещено: m_private недоступен извне через дочерний класс
    child.m_protected = 3; // запрещено: m_protected недоступен извне через дочерний класс
}

Тип наследования protected почти никогда не используется. С защищенным наследованием члены public и protected становятся protected, а члены private остаются недоступными.
Указатели и ссылки на производные классы
Если создан указатель на один тип данных, он не сможет указывать на другой тип. Но в ООП указатель на объект базового класса также может указывать на объект производного. Покажем это на примере:
Animal *p_animal;  		 // указатель на объект типа Animal
Animal animal; 		       // объект типа Animal
Dog dog; 			       // объект типа Dog
                               // Следующие присвоения будут безошибочными
p_animal = &animal;   	       // р_animal указывает на объект типа Animal
p_animal = &dog;    		 // р_animal указывает на объект типа Dog, являющийся объектом, порожденным от Animal

В данном случае указатель p_animal может хранить адрес как объекта класса Animal, так и объекта класса Dog.
Но указатель р_animal может получить доступ только к членам класса Dog, которые были унаследованы от класса Animal. К специфичным членам класса Dog указатель не имеет доступа.
В следующем примере показывается использование указателя на базовый класс.

#include <iostream>
#include <string.h>
using namespace std;

class Animal {
protected:
    int m_age;
public:
    void set_age(int age) {m_age=age;}
    void show_age() {cout << m_age << endl; }
};

class Dog: public Animal {
    char m_breed[80];             // кличка собаки
public:
    void set_breed(char *breed) {
        strcpy(m_breed, breed);
    };
    void show_breed () {
        cout << m_breed << endl;
    }
};

int main()
{
    Animal *p_animal;
    Animal animal;
    Dog dog;
    p_animal = &animal;           // адрес объекта базового класса
                                  // доступ к Animal через указатель
    p_animal->set_age(5);
                                  // доступ к Dog через указатель
    p_animal = &dog;
    p_animal->set_age(10);
                                  // показать каждое имя соответствующего объекта
    animal.show_age();
    dog.show_age();
                                 // dog.set_breed("poodle");
                                 //((Dog *)p_animal) ->show_breed();

    cout << "\n";
    return 0;
}


p_animal может указывать на члены класса Animal, а также на члены класса Dog, которые были определены в базовом классе. Вместе с этим нужно помнить, что указатель нельзя использовать для доступа к члену show_breed(), пока не выполнено приведение типов:
((Dog *)p_animal) ->show_breed();

Но такую конструкцию употреблять не рекомендуется, так как это может вызвать дополнительные ошибки в коде.
Множественное наследование
В С++ существует множественное наследование: когда у одного дочернего класса несколько родительских. Например, нужно создать класс Teacher. Этот класс может наследовать от классов Employee и School. Синтаксис множественного наследования:
#include <string>
using namespace std;

class School
{
private:
    int m_number;
        string m_type;
public:
    School(int number, string type) : m_number(number), m_type(type)
    { }
};

class Employee
{
private:
    string m_employer;
    double m_wage;
public:
    Employee(string employer, double wage)
    : m_employer(employer), m_wage(wage)
    { }
};

// класс Teacher открыто наследует свойства классов Human и Employee
class Teacher: public School, public Employee
{
private:
    int m_teachesGrade;
public:
    Teacher(int number, string type, string employer, double wage, int teachesGrade)
    : School(number, type), Employee(employer, wage), m_teachesGrade(teachesGrade)
    { }
};

У класса School есть переменные-члены m_number, m_type. Это то, что есть у любой школы. У класса Employee есть переменные-члены m_employeer, m_wage. Эти свойства присущи любому работнику. Поскольку у учителя есть все свойства школы и работника, то класс Teacher наследует свойства классов School и Employee. Но у педагога есть еще своя квалификация, поэтому в классе Teacher есть переменная-член m_teachesGrade.
Множественное наследование — мощное средство языка С++, но оно же может привести к серьезным проблемам:
Когда дочерний класс пытается вызвать метод, который есть в обоих родительских классах. Компилятор сообщит об ошибке, так как не будет знать, какой из методов вызвать. Эту проблему можно устранить путем явного указания класса, которому принадлежит метод.
Когда один класс наследует от двух классов, которые в свою очередь наследуют от одного и того же родительского класса (алмаз смерти). Проблемы заключаются в неоднозначности вызова методов, а также повторном копировании членов базового класса в дочерний класс.
Множественное наследование запрещено использовать в некоторых языках программирования (Java и C#) для обычных классов, но для интерфейсных такое ограничение снято.
Таким образом, множественное наследование следует применять только в случаях крайней необходимости, если другие решения недоступны или слишком сложны.
Практическое задание
Создать класс Person (человек) с полями: имя, возраст, пол и вес. Определить методы переназначения имени, изменения возраста и веса. Создать производный класс Student (студент), имеющий поле года обучения. Определить методы переназначения и увеличения этого значения. Создать счетчик количества созданных студентов. В функции main() создать несколько студентов. По запросу вывести определенного человека.
Создать классы Apple (яблоко) и Banana (банан), которые наследуют класс Fruit (фрукт). У Fruit есть две переменные-члена: name (имя) и color (цвет). Добавить новый класс GrannySmith, который наследует класс Apple.
int main()
{
    Apple a("red");
    Banana b;
    GrannySmith c;

    std::cout << "My " << a.getName() << " is " << a.getColor() << ".\n";
    std::cout << "My " << b.getName() << " is " << b.getColor() << ".\n";
    std::cout << "My " << c.getName() << " is " << c.getColor() << ".\n";

    return 0;
}


Код, приведенный выше, должен давать следующий результат:

      My apple is red.
My banana is yellow.
My Granny Smith apple is green.


Изучить правила игры в Blackjack. Подумать, как написать данную игру на С++, используя объектно-ориентированное программирование. Сколько будет классов в программе? Какие классы будут базовыми, а какие производными? Продумать реализацию игры с помощью классов и записать результаты.
Дополнительные материалы
Бьерн Страуструп. Программирование. Принципы и практика использования С++.
Стивен Прата. Язык программирования С++. Лекции и упражнения.
Роберт Лафоре. Объектно-ориентированное программирование в С++.
Используемая литература
Для подготовки данного методического пособия были использованы следующие ресурсы:
Наследование классов в C++.
Бьерн Страуструп. Программирование. Принципы и практика использования С++.
Ральф Джонсон, Ричард Хелм, Эрих Гамма. Приемы объектно-ориентированного программирования. Паттерны проектирования.

*/


// УРОК №3
//--------



/*
Виртуальные функции и полиморфизм
Основы виртуальных функций. Чистые виртуальные функции и абстрактные классы. Интерфейсные классы. Раннее и позднее связывание. Перегрузка функций и методов.

Указатели и ссылки при наследовании
Виртуальные функции
Виртуальные деструкторы
Абстрактные классы
Интерфейсные классы
Раннее и позднее связывание
Виртуальный базовый класс
Перегрузка операторов
Перегрузка операторов через дружественные функции
Перегрузка операторов через обычные функции
Перегрузка операторов через методы класса
Перегрузка унарных операторов
Создание классов для игры Blackjack
Практические задания
Дополнительные материалы
Используемая литература


Указатели и ссылки при наследовании
Вспомним, как работают указатели и ссылки. Допустим, есть базовый класс Parent и производный Child:
class Parent
{
protected:
    int m_age;
public:
    Parent(int age) : m_age(age)
    { }
    int getAge() { return m_age; }
};

class Child : public Parent
{
public:
    Child(int age) : Parent(age)
    { }
    int getAge() { return m_age / 2; }




Создадим объект класса Child и обратимся к его членам-функциям:
#include <iostream>
using namespace std;

int main()
{
    Child child(40);
    cout << "child has age " << child.getAge() << '\n';

    Child &rChild = child; // ссылка на объект child
    cout << "rChild has age " << rChild.getAge() << '\n';

    Child *pChild = &child; // указатель на объект child
    cout << "pChild has age " << pChild->getAge() << '\n';

    return 0;
}


Результат выполнения программы:
child has age 20
rChild has age 20
pChild has age 20
Обратите внимание, что при вызове члена-функции через указатель pChild был использован оператор -> (стрелка). Теперь, если мы создадим указатель и ссылку типа Parent на объект child, также сможем вызывать члены-функции объекта child. Но при одном условии: если эти функции будут членами класса Parent.

int main()
{
    Child child(40);
    Parent &rParent = child;
    Parent *pParent = &child;

    cout << "child has age " << child.getAge() << '\n';
    cout << "rParent age " << rParent.getAge() << '\n';
    cout << "pParent age " << pParent->getAge() << '\n';

    return 0;
}


Результат выполнения программы:
child has age 20
rParent age 40
pParent age 40
Через rParent и pParent	можно вызвать только члены базового класса, при этом они не видят члены производного класса. Это проблема, решение которой рассмотрим дальше. Можно было бы отказаться от создания ссылок или указателей типа базового класса и сразу создавать их с типом производного класса. Но у такого подхода есть ряд недостатков. Например, есть несколько дочерних классов (Child1, Child2), и нам необходимо создать функцию writeAge(), которая будет выводить на экран значение члена-функции getAge для любого объекта из этих классов (причем эти члены-функции для каждого класса разные). Параметром функции writeAge() может быть объект любого из дочерних классов, поэтому логичнее сделать этот параметр типа базового класса:
void writeAge(Parent &someChild)
{}


Но мы не получим нужного решения, так как доступ к уникальным членам дочерних классов через ссылку закрыт.
Виртуальные функции
Виртуальная функция — это метод класса, который может быть переопределен в дочерних классах так, что конкретная реализация метода для вызова будет определяться во время исполнения. При использовании виртуальной функции вызывается «самый дочерний» метод — при условии, что имя, тип параметров, тип возврата дочернего метода совпадает с методом родительского класса. Если тип параметров, их количество, тип возврата метода не будет совпадать, то реализуется механизм перегрузки. Для создания виртуальной функции перед ее объявлением нужно указать ключевое слово virtual. С помощью виртуальных функций может быть решена проблема, поставленная в предыдущем разделе.

class Parent
{
protected:
    int m_age;
public:
    Parent(int age) : m_age(age)
    { }
    virtual int getAge() { return m_age; }
};
class Child: public Parent
{
public:
    Child(int age) : Parent(age)
    { }
    int getAge() override
{ return m_age / 2; }
};

void writeAge( Parent &someChild)
{
    cout << "rParent age " << someChild.getAge() << '\n';
}

int main()
{
    Child child(40);
    Parent &rParent = child;
    writeAge(rParent);
    return 0;
}


Результат выполнения программы:
rParent age 20
Так как getAge() является виртуальной функцией, компилятор проверяет, есть ли переопределение этой функции в дочерних классах. Если есть, выполняется именно метод из дочернего класса. Обратите внимание, что переопределенная функция имеет идентификатор override, который используется, чтобы явно указать, что функция должна переопределять виртуальную функцию, объявленную в базовом классе. Идентификатор override помогает избегать ошибок в коде, а также лучше понимать текст программы. Применять данный идентификатор не обязательно, поэтому мы его не будем использовать в дальнейшем.
Если функция объявлена как виртуальная, то и все переопределения функции тоже являются виртуальными, даже если это не указано явно в коде. Обратите внимание, что тип возврата виртуальной функции должен совпадать во всех ее переопределениях. Нельзя вызывать виртуальные функции в теле конструктора или деструктора, так как всегда будет вызываться родительская версия метода.
Иногда бывает необходимо проигнорировать вызов переопределений, созданных виртуальными функциями. Для этого перед вызовом функции следует указать имя класса, которому принадлежит нужная версия метода, с использованием оператора разрешения области видимости (::).
Несмотря на явные преимущества виртуальных функций, повсеместное их использование будет неэффективным, так как обработка и вызов виртуального метода занимает больше времени.
Теперь можем поговорить о еще одном принципе ООП — полиморфизме.
Полиморфизм — это возможность применять одноименные методы с одинаковыми или различными наборами параметров в одном классе или в группе классов, связанных отношениями наследования. Другими словами, полиморфизм позволяет переопределять методы для классов-наследников. Он реализуется с помощью виртуальных функций.
Виртуальные деструкторы
Виртуальные деструкторы работают по тому же принципу, что и виртуальные функции. При вызове деструктора базового класса вначале должны вызываться деструкторы производных классов. Это возможно, если деструктор объявлен как виртуальный. Рассмотрим на примере:
#include <iostream>
using namespace std;
class Parent
{
public:
    virtual ~Parent() // Деструктор виртуальный
    {
        cout << "Calling ~Parent()" << endl;
    }
};

class Child: public Parent
{
private:
    int* m_grades;

public:
    Child(int length)
    {
        m_grades = new int[length];
    }

    ~Child() // Деструктор виртуальный
    {
        delete[] m_grades;
    }
};

int main()
{
    Child *child = new Child(7);
    Parent *parent = child;
    delete parent;

    return 0;
}

Если бы деструкторы были не виртуальными, то при удалении указателя parent вызывался бы только деструктор базового класса. При этом член-переменная m_grades не будет удалена. Объявление деструктора виртуальным исправляет эту проблему.
При наследовании создавайте деструкторы виртуальными.
Абстрактные классы
Встречаются задачи, где не нужно определять виртуальную функции внутри базового класса. В таком случае объявляют чисто виртуальную функцию (или абстрактную функцию). Чтобы ее объявить необходимо написать прототип функции и присвоить ей значение 0. Класс, в котором присутствует чисто виртуальная функция, называется абстрактным. При объявлении абстрактной функции должно выполняться два условия:
нельзя создавать объекты абстрактного класса;
все производные классы должны переопределять все чисто виртуальные функции.
Абстрактные классы — крайне полезный инструмент. Их можно применять для создания указателей и использования преимуществ всех полиморфных способностей. Например:
using namespace std;
class Animal
{
public:
    virtual void say()=0;
};
class Cat: public Animal {
public:
    void say()
    {
        cout << “Meow" << endl;
    }
};
class Dog: public Animal
{
public:
    void say() {
        cout << "Woof" << endl;
    }
};

int main() {
    Cat cat;
    Dog dog;
    Animal *animal1 = &cat;
    Animal *animal2 = &dog;

    animal1 -> say();
    animal2 -> say();
}


В данном примере невозможно создать объект класса Animal. Но используя указатель типа Animal, можно вызывать методы нужных классов.
Интерфейсные классы
Интерфейсные классы не имеют переменных-членов, и все их методы — это чисто виртуальные функции. Любой класс-наследник должен предоставлять свою реализацию виртуальных методов. Интерфейсные классы создаются для конструирования «рабочих» классов.
Использование интерфейсных классов снимает большинство проблем, которые могли бы возникнуть при множественном наследовании. Это связано с отсутствием переменных-членов и определений методов.
Один интерфейсный класс может наследовать от нескольких интерфейсных классов. Таким образом создается многоуровневая направленная иерархия.
Обычные классы могут наследовать не от одного интерфейсного класса, но он должен дать определение всем методам, перечисленным в заголовках родительских классов. Если хотя бы один метод будет не переопределен, то новый класс автоматически становится абстрактным.
Интерфейсным классам принято давать названия, начинающиеся с буквы I. Пример такого класса:
class IErrorLog
{
public:
    virtual bool openLog(const char *filename) = 0;
    virtual bool closeLog() = 0;

    virtual bool writeError(const char *errorMessage) = 0;

    virtual ~IErrorLog() {}; // создаём виртуальный деструктор в случае, если удалим указатель на IErrorLog, то чтобы вызывался соответствующий деструктор дочернего класса
};

Любой класс, который наследует IErrorLog, должен предоставить свою реализацию всех трех методов класса IErrorLog. Вы можете создать дочерний класс с именем FileErrorLog, где openLog() открывает файл на диске, closeLog() закрывает файл, а writeError() записывает сообщение в файл. Можно создать еще один дочерний класс с именем ScreenErrorLog, где openLog() и closeLog() ничего не делают, а writeError() выводит сообщение во всплывающем окне на экран.
Раннее и позднее связывание
Связывание — это процесс, во время которого компилятор сопоставляет  с идентификаторами адреса в памяти. Связывание производится как для переменных, так и для функций. Существует два типа связывания: раннее (статическое) или позднее (динамическое). Рассмотрим их на примере функций.
Ранее связывание означает, что компилятор до выполнения кода определяет адрес функции и затем уже просто обращается по этому адресу. До этого мы использовали только раннее связывание.
Механизм позднего связывания представляет выбор реализации нужной функции на этапе выполнения программы. Заранее должен быть известен тип ссылки на функцию, и уже потом выбирается ее нужная реализация. В С++ данный процесс реализуют указатели на функции. Например:
#include <iostream>
using namespace std;
int add(int a, int b)
{
    return a + b;
}

int main()
{
    // Создаем указатель на функцию add
    int (*pF)(int, int) = add;
    cout << pF(4, 5) << endl; // вызов add(4 + 5)

    return 0;
}


Здесь был создан указатель на функцию add(). Позднее связывание обладает большей гибкостью, так как не нужно заранее знать, какую функцию вызывать. Но позднее связывание менее эффективно, так как появляется дополнительный указатель, который хранит адрес вызываемой функции.
Виртуальные функции — это пример использования позднего связывания. Если у дочернего класса существует переопределение виртуальной функции, то выполняется именно это переопределение. В ином случае выполняется функция, определенная в базовом классе. При создании указателя базового класса и вызове виртуальной функции через этот указатель компилятор не знает, виртуальная функция объекта какого класса (базового или производного) будет вызвана. Именно поэтому используется позднее связывание.
Виртуальный базовый класс
Вспомним проблему «алмаз смерти», которая возникает при множественном наследовании. Вкратце: от базового класса А наследуют два класса: В и С, — а от В и С наследует один класс — D. Проблема в том, что при создании объекта класса D непонятно, какой класс создает объект класса A — класс B или C?
Рассмотрим множественное наследование на конкретном примере:








Для решения данной проблемы создаются виртуальные базовые классы. Таким образом компилятор понимает, что за создание базового класса отвечает класс Cartoon (самый дочерний).

#include <iostream>
using namespace std;

class Animal
{
public:
    Animal(char a[]) {
        cout << a << endl;
    }
};

class Cat: virtual public Animal
{
public:
    Cat(char a[], char c[]) : Animal(a)
    {
        cout << c << endl;
    }
};

class Mouse: virtual public Animal
{
public:
    Mouse(char a[], char m[]) : Animal(a)
    {
        cout << m << endl;
    }
};

class Cartoon: public Cat, public Mouse
{
public:
    Cartoon(char a[], char c[], char m[]) :
    Cat(a,c), Mouse(a,m), Animal(a)
    { }
};

int main() {
    Cartoon animal("animal", "cat", "mouse");
}


int main() {
    Cartoon animal("animal", "cat", "mouse");
}


Результат выполнения программы:
animal
cat
mouse
Теперь понятно, что в момент создания объекта класса Cartoon именно этот класс и создает объекты своих родительских классов. Это необходимо учитывать при написании конструктора класса Cartoon.
Перегрузка операторов
Перегрузка функций — это определение нескольких функций с одинаковым именем, но различными параметрами. Наборы параметров перегруженных функций могут отличаться порядком следования, количеством, типом. Таким образом, перегрузка функций нужна для того, чтобы избежать дублирования имен функций, выполняющих сходные действия, но обладающих различной программной логикой.
В С++ оператором называется действие или функция, обозначенная специальным символом. Чтобы распространять эти действия на новые типы данных, сохраняя естественный синтаксис, в С++ была введена возможность перегрузки операторов.
Список операторов:
+ - * / %              //Арифметические операторы
+= -= *= /= %=
+a -a                  //Операторы знака
++a a++ --a a--        //Префиксный и постфиксный инкременты
&& || !                //Логические операторы
& | ~ ^
&= |= ^=
<< >> <<= >>=          //Битовый сдвиг
=                      //Оператор присваивания
== !=                  //Операторы сравнения
< > >= <=


Специальные операторы:
&a  *a  a->  a->*
()  []
(type)
.   ,   (a ? b : c)

Перегрузить можно почти все операторы, кроме тернарного оператора (?:), оператора (sizeof), оператора разрешения области видимости (::), оператора выбора члена (.) и указателя в качестве оператора выбора члена (.*).
Есть ряд правил и ограничений для перегрузки операторов:
Перегружать можно только существующие операторы — нельзя создавать новые или переименовывать существующие.
Хотя бы один операнд перегруженного оператора должен быть пользовательского типа данных — нельзя перегружать операторы только со встроенными типами данных.
Нельзя изменять количество операндов, поддерживаемых операторами — унарный оператор имеет только один операнд, бинарный — два, тернарный — три.
Все операторы сохраняют свой приоритет и ассоциативность по умолчанию.
Перегрузить операторы можно тремя способами:
через дружественные функции;
через обычные функции;
через методы класса.
Перегрузка операторов через дружественные функции
Покажем пример перегрузки оператора +:
#include <iostream>
using namespace std;

class Dollars
{
private:
    int m_dollars;

public:
    Dollars(int dollars) { m_dollars = dollars; }

    // выполняем Dollars + Dollars через дружественную функцию
    friend Dollars operator+ (const Dollars &d1, const Dollars &d2);

    int getDollars() const { return m_dollars; }
};

Dollars operator+(const Dollars &d1, const Dollars &d2)
{
    // используем конструктор Dollars и operator+(int, int)
    // мы имеем доступ к закрытому члену m_dollars, поскольку эта функция является дружественной классу Dollars
    return Dollars(d1.m_dollars + d2.m_dollars);
}

int main()
{
    Dollars dollars1(7);
    Dollars dollars2(9);
    Dollars dollarsSum = dollars1 + dollars2;
    cout << "I have " << dollarsSum.getDollars() << " dollars.";
    return 0;
}

Результат исполнения программы:
I have 16 dollars.
Поскольку перегруженная функция является дружественной для класса Dollars, то она имеет доступ к закрытым членам этого класса. Определять дружественную функцию можно и внутри класса, но лучше записывать определения функций в отдельном .cpp-файле, чтобы разделять интерфейс и реализацию.
Необходимо предусмотреть случай операторов с разными типами операндов. Например, в нашем случае необходим еще добавить operator+(Dollars, int), а также симметричный ему оператор operator+(int, Dollars).
Аналогичным образом можно перегружать операторы -, *, /. Обратите внимание, что операторы - и / не являются ассоциативными, то есть порядок следования операндов имеет значение.
Перегрузка операторов через обычные функции
Если у вас в классе присутствуют get-функции, можно перегружать операторы через обычные функции, которые не являются членами класса.
#include <iostream>
using namespace std;
class Dollars
{
private:
    int m_dollars;

public:
    Dollars(int dollars) { m_dollars = dollars; }

    int getDollars() const { return m_dollars; }
};

// Эта функция не является ни методом класса, ни дружественной классу Dollars!
Dollars operator+(const Dollars &d1, const Dollars &d2)
{
    // используем конструктор Dollars и operator+(int, int)
    // здесь нам не нужен прямой доступ к закрытым членам класса Dollars
    return Dollars(d1.getDollars() + d2.getDollars());
}

int main()
{
    Dollars dollars1(7);
    Dollars dollars2(9);
    Dollars dollarsSum = dollars1 + dollars2;
    cout << "I have " << dollarsSum.getDollars() << " dollars.";

    return 0;
}

В данном примере перегрузка осуществляется через обычную функцию. Данный способ рекомендуется использовать, когда в классе есть get-функции. Если их нет, специально создавать не надо, чтобы не загружать код дополнительными функциями. Поэтому необходимо использовать перегрузку через дружественные функции.
Перегрузка операторов через методы класса
Пример перегрузки оператора через метод класса:
#include <iostream>
using namespace std;
class Dollars
{
private:
    int m_dollars;

public:
    Dollars(int dollars) { m_dollars = dollars; }
    // Эта функция является методом класса!
    // Вместо параметра dollars в перегрузке через дружественную функцию здесь неявный параметр, на который указывает указатель *this
    Dollars operator+(int value)
    {
        return Dollars(m_dollars + value);
    }
    int getDollars() { return m_dollars; }
};

int main()
{
    Dollars dollars1(7);
    Dollars dollars2 = dollars1 + 3;
    cout << "I have " << dollars2.getDollars() << " dollars.\n";
    return 0;
}

В данном примере у оператора только один аргумент. На самом деле, он явный, а есть еще один — неявный, который ссылается с помощью указателя *this на текущий объект. Поэтому в строке return Dollars(m_dollars + value) переменная-член m_dollars является членом того объекта, который вызвал этот метод.
Через методы класса нужно переопределять операторы присваивания (=), индекса ([]), вызова функции (()) и выбора члена (->). Это требование языка С++.
Через методы класса нельзя переопределять операторы ввода (>>) и вывода (<<). Также не получится переопределить бинарный оператор, левый операнд которого не является классом (например, int) или это класс, который мы не можем изменить (например, ostream). Это следует из того, что левый операнд должен обязательно быть членом данного класса.
Каким из трех способов переопределять операторы, решать вам. Но обычно бинарные операторы, которые не изменяют левый операнд, переопределяют через обычные или дружественные функции. Если же левый операнд изменяется, то используют перегрузку через методы класса (например, operator+=). Унарные операторы тоже перегружаются через методы класса, так как в таком случае параметры не используются вовсе.

Операторы
Перегрузка через обычную или дружественную функцию
Перегрузка через метод класса
Унарный оператор
-
+
Бинарный оператор, не изменяющий левый операнд
+
-
Бинарный оператор, изменяющий левый операнд
-
+



Перегрузка унарных операторов
Перегрузим унарный оператор минус (-) и логический оператор НЕ (!).
#include <iostream>
using namespace std;
class Vector
{
private:
    double m_x, m_y, m_z;

public:
    Vector(double x = 0.0, double y = 0.0, double z = 0.0) :
    m_x(x), m_y(y), m_z(z)
    {
    }

    Vector operator- () const
    {
        return Vector(-m_x, -m_y, -m_z);
    }

    bool operator! () const
    {
        return (m_x == 0.0 && m_y == 0.0 && m_z == 0.0);
    }

    double getX() {return m_x;}
    double getY() {return m_y;}
    double getZ() {return m_z;}
};

int main()
{
    Vector v1; // используем конструктор по умолчанию со значениями 0.0, 0.0, 0.0
    if (!v1)
        cout << "Vector_1 is null.\n";
    else
        cout << "Vector_1 is not null.\n";

    Vector v2(1,2,3);
    cout << "Opposite vector_2 is (" << -v2.getX() << ", " << -v2.getY() << ", " << -v2.getZ() << ").";

    return 0;
}


Результат выполнения программы:
Vector_1 is null.
Opposite vector_2 is (-1, -2, -3).
Обратите внимание, что методы класса объявлены константными. Это сделано потому, что оператор не изменяет объект, вызвавший этот метод. При этом константный метод также необходим, если мы используем его для константного объекта этого класса.
Создание классов для игры Blackjack

Начиная с этого урока, будем с использованием полученных знаний по ООП создавать игру Blackjack. Суть проста: раздаются карты, за каждую из которых начисляются очки. Игрок пытается заработать 21 очко, не больше. За каждую карту с числом дается столько очков, сколько на ней указано. За туз — либо 1 очко, либо 11 (что больше подходит игроку), а за валета, даму и короля — по 10 очков.
Компьютер выступает дилером и играет против группы от одного до семи игроков. В начале кона все участники, включая дилера, получают две карты. Игроки могут видеть все свои карты, а также сумму очков. Однако одна из карт дилера скрыта на протяжении всего кона.
Далее каждый игрок может брать дополнительные карты. Если сумма очков у него превысит 21, он проигрывает. Когда все игроки получили возможность набрать дополнительные карты, дилер открывает скрытую карту. Далее он обязан брать новые карты до тех пор, пока сумма его очков не превышает 16. Если у дилера перебор, все игроки, не имеющие перебора, побеждают. В противном случае сумма очков каждого из оставшихся игроков сравнивается с суммой очков дилера. Игрок побеждает, если сумма его очков больше, чем у дилера. В противном случае — проигрывает. Если суммы очков игрока и дилера одинаковы, засчитывается ничья.
Разработаем классы, которые будем использовать в нашей программе:
Класс
Родительский класс
Описание
Card
нет
Карта
Hand
нет
Набор карт, коллекция объектов класса Card
Deck
Hand
Имеет дополнительную функциональность, которая отсутствует в классе Hand, в частности — тасование и раздачу
GenericPlayer
Hand
Обобщенно описывает игрока. Не является полноценным игроком, а лишь содержит элементы, характерные как для игрока-человека, так и для игрока-компьютера
Player
GenericPlayer
Человек-игрок
House
GenericPlayer
Компьютер-игрок
Game
нет
Игра


Обратите внимание: класс GenericPlayer создается для того, чтобы общая функциональность классов Player и House не дублировалась в обоих классах.
Колода карт отделена от дилера, поэтому карты колоды будут раздаваться игрокам-людям и игроку-компьютеру на равных. Это значит, что функция-член, предназначенная для раздачи карт, будет полиморфной.

Приведем иерархию данных классов:

Практические задания
Создать абстрактный класс Figure (фигура). Его наследниками являются классы Parallelogram (параллелограмм) и Circle (круг). Класс Parallelogram — базовый для классов Rectangle (прямоугольник), Square (квадрат), Rhombus (ромб). Для всех классов создать конструкторы. Для класса Figure добавить чисто виртуальную функцию area() (площадь). Во всех остальных классах переопределить эту функцию, исходя из геометрических формул нахождения площади.
Создать класс Car (автомобиль) с полями company (компания) и model (модель). Классы-наследники: PassengerCar (легковой автомобиль) и Bus (автобус). От этих классов наследует класс Minivan (минивэн). Создать конструкторы для каждого из классов, чтобы они выводили данные о классах. Создать объекты для каждого из классов и посмотреть, в какой последовательности выполняются конструкторы. Обратить внимание на проблему «алмаз смерти».
Примечание: если использовать виртуальный базовый класс, то объект самого "верхнего" базового класса создает самый "дочерний" класс.
Создать класс: Fraction (дробь). Дробь имеет числитель и знаменатель (например, 3/7 или 9/2). Предусмотреть, чтобы знаменатель не был равен 0. Перегрузить:
математические бинарные операторы (+, -, *, /) для выполнения действий с дробями
унарный оператор (-)
логические операторы сравнения двух дробей (==, !=, <, >, <=, >=).
Примечание: Поскольку операторы < и >=, > и <= — это логические противоположности, попробуйте перегрузить один через другой.
Продемонстрировать использование перегруженных операторов.
Создать класс Card, описывающий карту в игре БлэкДжек. У этого класса должно быть три поля: масть, значение карты и положение карты (вверх лицом или рубашкой). Сделать поля масть и значение карты типом перечисления (enum). Положение карты - тип bool. Также в этом классе должно быть два метода:
метод Flip(), который переворачивает карту, т.е. если она была рубашкой вверх, то он ее поворачивает лицом вверх, и наоборот.
метод GetValue(), который возвращает значение карты, пока можно считать, что туз = 1.

Дополнительные материалы
Бьерн Страуструп. Программирование. Принципы и практика использования С++.
Стивен Прата. Язык программирования С++. Лекции и упражнения.
Роберт Лафоре. Объектно-ориентированное программирование в С++.
Используемая литература
Для подготовки данного методического пособия были использованы следующие ресурсы:
Онлайн справочник программиста на C и C++. Полиморфизм.
Бьерн Страуструп. Программирование. Принципы и практика использования С++.
Ральф Джонсон, Ричард Хелм, Эрих Гамма. Приемы объектно-ориентированного программирования. Паттерны проектирования.

*/


// УРОК №4
//--------



/*
Отношения между объектами в С++

Композиция. Агрегация. Ассоциация. Зависимость. Контейнерные классы. Операторы приведения типа. Примеры программ на С++.

Отношения между объектами в С++
Композиция
Агрегация
Ассоциация
Зависимость
Контейнерные классы
Стандартная библиотека шаблонов
Введение в std::vector
Итераторы STL
Создание контейнерного класса
Динамическое приведение типов
Написание игры Blackjack
Практические задания
Дополнительные материалы
Используемая литература
Отношения между объектами в С++
Прежде чем изучать основные паттерны программирования, необходимо разобраться в отношениях между классами и объектами в С++. Это позволит понять связи между сущностями при использовании их в паттернах. В данном уроке рассмотрим основные типы отношений:
композицию;
агрегацию;
ассоциацию;
зависимость.
Эти типы отношений имеют аналогии в реальной жизни. Например:
квадрат является геометрической фигурой;
автомобиль имеет руль;
программист использует клавиатуру;
цветок зависит от растения;
ученик является членом класса;
мозг существует как часть человека.
Здесь мы приводим в пример типы отношений, которые есть и в программировании. Рассмотрим их подробнее.
Композиция
Композиция — это построение сложного объекта из более простых. Например, организм состоит из органов или автомобиль — из двигателя, шасси и других элементов.
Для реализации композиции объект и часть должны иметь следующие отношения:
часть (член) является составляющей объекта (класса);
часть (член) может принадлежать только одному объекту (классу) в каждом конкретном случае;
часть (член) существует под управлением объекта (класса);
часть (член) не знает о существовании объекта (класса).
Рассмотрим пример на языке программирования.
#include <iostream>
#include <string>
using namespace std;

class Human
{
public:
    void Think()
    {
        brain.Think();
    }
private:
    class Brain
    {
    public:
        void Think()
        {
            cout << "Я думаю!" << endl;
        }
    };
    Brain brain;
};

int main()
{
    Human human;
    human.Think();
}

В данном примере метод Think() можно вызвать, только если есть объект класса Human. Иными словами, объект класса Brain существует только тогда, когда существует объект класса Human. Класс Brain находится в private-области класса Human, таким образом достигается инкапсуляция данного класса.
Агрегация
Для реализации агрегации целое и его части должны соответствовать следующим отношениям:
часть (член) является составляющей целого (класса);
часть (член) может принадлежать более чем одному целому (классу) в каждом конкретном случае;
часть (член) существует не под управлением целого (класса);
часть (член) не знает о существовании целого (класса).
Как и в случае с композицией, отношения в агрегации однонаправленные и представлены в формате «часть — целое». Но в отличие от композиции, части могут принадлежать более чем одному целому, и оно не управляет существованием и временем жизни частей. При создании и уничтожении агрегации целое не несет ответственности за создание и уничтожение своих частей.
Приведем наглядный пример. Комната является частью квартиры, следовательно здесь подходит композиция, потому что комната без квартиры существовать не может. А вот мебель не является неотъемлемой частью квартиры. Но в то же время квартира содержит мебель, поэтому следует использовать агрегацию.
Рассмотрим классы Human и Cap. В реальной жизни кепка является частью одежды человека. И хотя кепка принадлежит человеку, она может принадлежать и другим объектам — например, манекену в магазине. Человек не несет ответственность за создание и уничтожение кепки. При этом человек знает, что у  него есть кепка, но сама она не в курсе, что является частью человека.
class Cap {
public:
    string getColor() {
        return color;
    }
private:
    // Пусть все кепки будут красными.
    string color = "красный";
};

class Human
{
public:
    void InspectTheCap () {
        cout << "Моя кепка имеет " << cap.getColor() << " цвет.";
    }
private:
    Cap cap;
};

int main()
{
    Human human;
    human.InspectTheCap();
}


В данном примере реализована агрегация.

Рассмотрим более сложный пример с сотрудником и отделом, где он работает:
class Worker
{
private:
    string m_name;

public:
    Worker(string name) : m_name(name)
    { }
    string getName() { return m_name; }
};

class Department
{
private:
    // Для простоты добавим только одного работника
    Worker *m_worker;
public:
    Department(Worker *worker = nullptr) : m_worker(worker)
    {  }
};

int main()
{
    // Создаем нового работника
    Worker *worker = new Worker("Anton");
    {
        // Создаем Отдел и передаем Работника в Отдел через параметр конструктора
        Department department(worker);
    } // department выходит из области видимости и уничтожается здесь

    // worker продолжает существовать
    cout << worker->getName() << " still exists!";
    delete worker;

    return 0;
}

Здесь Работник создается независимо от Отдела, а затем переходит в параметр конструктора класса Отдела. Когда department уничтожается, указатель m_worker уничтожается также, но сам Работник не удаляется — он существует до тех пор, пока не будет уничтожен в main().
При решении задачи определяйте тип отношений в зависимости от того, какой из них будет самым простым и соответствующим потребностям вашей программы.
Ассоциация
В ассоциации два несвязанных объекта должны соответствовать следующим отношениям:
первый объект (член) не связан со вторым объектом (классом);
первый объект (член) может принадлежать одновременно сразу нескольким объектам (классам);
первый объект (член) существует не под управлением второго объекта (класса);
первый объект (член) может знать или не знать о существовании второго объекта (класса).
В отличие от композиции или агрегации, где объект является частью целого, в ассоциации объекты между собой не связаны. Подобно тому, как происходит при агрегации, первый объект может принадлежать нескольким объектам одновременно и не управляться ими. Но в отличие от агрегации, где отношения однонаправленные, в ассоциации они могут быть и двунаправленными — когда оба объекта знают о существовании друг друга.
Ассоциации реализовываются по-разному. Чаще всего для этого используют указатели, где классы указывают на объекты друг друга. Покажем пример, как класс Водитель может иметь однонаправленную связь с классом Автомобиль без переменной-члена в виде указателя на объект этого класса:
#include <iostream>
#include <string>
using namespace std;

class Car
{
private:
    string m_name;
    int m_id;

public:
    Car(string name, int id) : m_name(name), m_id(id)
    { }

    string getName() { return m_name; }
    int getId() { return m_id;  }
};


// Данный класс содержит автомобили и имеет функцию для "выдачи" автомобиля
class CarLot
{
private:
    static Car s_carLot[4];

public:
    // Удаляем конструктор по умолчанию, чтобы нельзя было создать объект этого класса
    CarLot() = delete;

    static Car* getCar(int id)
    {
        for (int count = 0; count < 4; ++count)
            if (s_carLot[count].getId() == id)
                return &(s_carLot[count]);

        return nullptr;
    }
};

Car CarLot::s_carLot[4] = { Car("Camry", 5), Car("Focus", 14), Car("Vito", 73), Car("Levante", 58) };

class Driver
{
private:
    string m_name;
    int m_carId; // для связывания классов используется эта переменная

public:
    Driver(string name, int carId) : m_name(name), m_carId(carId)
    {  }
    string getName() { return m_name; }
    int getCarId() { return m_carId; }

};

int main()
{
    Driver d("Ivan", 14); // Ivan ведет машину с ID 14

    Car *car = CarLot::getCar(d.getCarId()); // Получаем этот Автомобиль из CarLot

    if (car)
        cout << d.getName() << " is driving a " << car->getName() << '\n';
    else
        cout << d.getName() << " couldn't find his car\n";

    return 0;
}

Car CarLot::s_carLot[4] = { Car("Camry", 5), Car("Focus", 14), Car("Vito", 73), Car("Levante", 58) };

class Driver
{
private:
    string m_name;
    int m_carId; // для связывания классов используется эта переменная

public:
    Driver(string name, int carId) : m_name(name), m_carId(carId)
    {  }
    string getName() { return m_name; }
    int getCarId() { return m_carId; }

};



int main()
{
    Driver d("Ivan", 14); // Ivan ведет машину с ID 14

    Car *car = CarLot::getCar(d.getCarId()); // Получаем этот Автомобиль из CarLot

    if (car)
        cout << d.getName() << " is driving a " << car->getName() << '\n';
    else
        cout << d.getName() << " couldn't find his car\n";

    return 0;
}

Результат выполнения программы:
Ivan is driving a Focus
В примере выше у нас есть CarLot (Гараж), в котором находятся наши автомобили. У Водителя, которому нужен Автомобиль, нет на него указателя, но есть Идентификатор Автомобиля, который он может использовать, чтобы получить Автомобиль из Гаража, когда ему это нужно.
Зависимость
Зависимость возникает, когда один объект обращается к функциональности другого, чтобы выполнить задание. Эти отношения слабее ассоциации, но все же любое изменение объекта, который предоставляет свою функциональность зависимому объекту, может стать причиной сбоя в его работе. Зависимость всегда однонаправленная.
Хорошим примером зависимости, которую вы уже видели много раз, является std::cout. Классы используют std::cout для вывода в консоль, но не наоборот.
Часто путают, чем зависимость отличается от ассоциации.
В C++ ассоциации — это отношения между двумя классами на уровне классов. То есть первый класс сохраняет прямую или косвенную связь со вторым через переменную-член. Например, в классе Врач есть массив указателей на объекты класса Пациент в виде переменной-члена. Вы всегда можете спросить у Врача, кто его Пациенты. Класс Водитель содержит идентификатор Автомобиля в виде целочисленной переменной-члена. Водитель знает, к чему привязан Автомобиль и как получить к нему доступ.
Зависимости обычно не представлены на уровне классов, то есть зависимый объект не связан со вторым объектом через переменную-член. Зависимый объект создается при необходимости (например, при открытии файла для записи данных) или передается в функцию в качестве параметра.
Контейнерные классы
Контейнерный класс в C++ — это класс, предназначенный для хранения и организации нескольких объектов определенного типа данных (пользовательских или фундаментальных). Есть много разных контейнерных классов, у каждого из которых свои преимущества, недостатки или ограничения. Наиболее часто используемым контейнером в программировании является массив. Хотя в C++ есть стандартные массивы, большинство программистов используют контейнерные классы-массивы — например, vector.
Обычно функциональность классов-контейнеров в C++ следующая:
создание пустого контейнера (через конструктор);
добавление нового объекта в контейнер;
удаление объекта из контейнера;
просмотр количества объектов, находящихся на данный момент в контейнере;
очистка контейнера от всех объектов;
доступ к сохраненным объектам;
сортировка объектов/элементов (не всегда).
Функциональность контейнерных классов может быть меньше, чем указанная в этом перечне.
В С++ есть стандартные контейнерные классы. Эта библиотека называется Стандартной библиотекой шаблонов (STL).
Стандартная библиотека шаблонов
STL — это часть Стандартной библиотеки С++, которая содержит набор шаблонов контейнерных классов, алгоритмов и итераторов. Преимущество STL в том, что эти классы можно использовать без необходимости писать и отлаживать их самостоятельно. Плюс вы получаете их эффективные версии.
Контейнеры STL делятся на три основные категории:
последовательные;
ассоциативные;
адаптеры.
Рассмотрим их более подробно.
Последовательные контейнеры (или контейнеры последовательности) — это контейнерные классы, элементы которых находятся в последовательности. Их определяющей характеристикой является то, что вы можете вставить свой элемент куда угодно в контейнере. Наиболее распространенным примером последовательного контейнера является массив: при вставке четырех элементов в массив они будут находиться в таком же порядке, как вы их вставляли.
STL содержит 6 контейнеров последовательности:
   std::vector;
   std::deque;
   std::array;
   std::list;
   std::forward_list;
   std::basic_string.
Класс vector рассмотрим более подробно.
Ассоциативные контейнеры — это контейнерные классы, которые автоматически сортируют все свои элементы. По умолчанию ассоциативные контейнеры выполняют сортировку элементов, используя оператор сравнения.
set — это контейнер, в котором хранятся только уникальные элементы, повторения запрещены. Элементы сортируются в соответствии с их значениями.
multiset — это set, но в котором допускаются повторяющиеся элементы.
map — это set, в котором каждый элемент является парой «ключ — значение». Ключ используется для сортировки и индексации данных и должен быть уникальным. А значение — это фактические данные.
multimap — это map, который допускает дублирование ключей. Все ключи отсортированы в порядке возрастания, и вы можете посмотреть значение по ключу.
Адаптеры — это специальные предопределенные контейнерные классы, которые адаптированы для выполнения конкретных заданий. Самое интересное заключается в том, что вы сами можете выбрать, какой последовательный контейнер должен использовать адаптер.
stack (стек) — это контейнерный класс, элементы которого работают по принципу LIFO («Last In, First Out» — «последним пришел, первым ушел»), то есть элементы вставляются (вталкиваются) в конец контейнера и удаляются (выталкиваются) оттуда же (из конца контейнера).
queue (очередь) — это контейнерный класс, элементы которого работают по принципу FIFO («First In, First Out» — «первым пришел, первым ушел»), то есть элементы вставляются (вталкиваются) в конец контейнера, но удаляются (выталкиваются) из начала контейнера.
priority_queue (очередь с приоритетом) — это тип очереди, в которой все элементы отсортированы. При вставке элемента он автоматически сортируется. Элемент с наивысшим приоритетом (самый большой) находится в самом начале очереди с приоритетом. Удаление элементов из такой очереди выполняется с самого начала очереди с приоритетом.
Введение в std::vector
Для хранения однотипных данных в С++ используются массивы. Существуют массивы с фиксированной длиной и динамические, длина которых может изменяться по ходу исполнения программы. Динамические массивы очень популярны, так как зачастую мы не знаем заранее, сколько элементов будет в массиве. Для реализации динамических массив в С++ можно использовать операторы new и delete.
#include <iostream>
using namespace std;

int main()
{
    int num;                     // размер массива
    cin >> num;                  // получение от пользователя размера массива
    int *p_array = new int[num]; // Выделение памяти для массива
    for (int i = 0; i < num; i++) {
                                 // Заполнение массива
        cin >> p_array[i];
    }
    // ....
    delete [] p_array;           // очистка памяти
    return 0;
}

Но существует более удобная версия динамических массивов — std::vector. С его помощью можно создавать массивы, длина которых задается во время выполнения, не используя операторы new и delete, то есть явно не указывая выделение и освобождение памяти. std::vector находится в заголовочном файле <vector>.
Создание динамического массива целых чисел следующее:
#include <vector>
using namespace std;
// нет необходимости указывать длину при инициализации
vector<int> array;
vector<int> array2 = { 10, 8, 6, 4, 2, 1 };
vector<int> array3 { 10, 8, 6, 4, 2, 1 };

Доступ к элементам динамического массива выполняется так же, как и в обычном массиве, — через оператор []:
array2[0] = 3;
Векторы отслеживают свою длину с помощью функции size():
array2.size();

Можно изменить длину вектора с помощью функции resize():
#include <vector>
#include <iostream>
using namespace std;

void print(vector<int> &a) {
    cout << "The length is: " << a.size() << '\n';

    for (int i=0; i<a.size(); i++)
        cout << a[i] << ' ';

    cout << endl;
}

int main()
{
    vector<int> array { 0, 1, 2, 3 };

    array.resize(7); // изменяем длину array на 7
    print(array);

    array.resize(2);
    print(array);

    return 0;
}

Результат выполнения программы:
The length is: 7
0 1 2 3 0 0 0
The length is: 2
0 1
Как видно из результата, можно увеличивать длину вектора, при этом пустые элементы будут инициализироваться начальными значениями (для типа int — 0). Или уменьшать — при этом часть элементов будет теряться.
Для добавления нового элемента в вектор существует функция push_back(). Для удаления последнего элемента вектора используйте функцию pop_back(), а для удаления всех элементов массива — clear(). Функция empty() проверяет вектор на пустоту.
#include <vector>
#include <iostream>
using namespace std;

void print(vector<int> &a) {
    cout << "The length is: " << a.size() << '\n';

    for (int i=0; i<a.size(); i++)
        cout << a[i] << ' ';

    cout << endl;
}

int main()
{
    vector<int> array { 0, 1, 2, 3 };

    array.push_back(4);
    print(array);

    array.pop_back();
    print(array);

    array.clear();
    print(array);

    if (array.empty())
        cout << "Vector is empty.\n";
    else
        cout << "Vector is not empty.\n";

    return 0;
}

Результат выполнения программы:
The length is: 5
0 1 2 3 4
The length is: 4
0 1 2 3
The length is: 0

Vector is empty.
Итераторы STL
Итератор — это объект, который способен перебирать элементы контейнерного класса, а пользователю при этом не обязательно знать, как реализован этот контейнерный класс. Во многих контейнерах (особенно в списке и ассоциативных контейнерах set, map и т.д.) итераторы являются основным способом доступа к элементам.
Об итераторе можно думать как об указателе на определенный элемент контейнерного класса с дополнительным набором перегруженных операторов для выполнения четко определенных функций:
Оператор * возвращает элемент, на который в данный момент указывает итератор.
Оператор ++ перемещает итератор к следующему элементу контейнера. Большинство итераторов также предоставляют оператор −− для перехода к предыдущему элементу.
Операторы == и != используются для определения того, указывают ли два итератора на один и тот же элемент. Для сравнения значений, на которые указывают два итератора, нужно сначала разыменовать их, а затем использовать оператор == или !=.
Оператор = присваивает итератору новую позицию (обычно начало или конец элементов контейнера). Чтобы присвоить другому объекту значение элемента, на который указывает итератор, нужно сначала разыменовать итератор, а затем использовать оператор =.
Каждый контейнерный класс имеет 4 основных метода для работы с оператором =:
begin() возвращает итератор, представляющий начало элементов контейнера.
end() возвращает итератор, представляющий элемент, который находится после последнего элемента в контейнере.
cbegin() возвращает константный (только для чтения) итератор, представляющий начало элементов контейнера.
cend() возвращает константный (только для чтения) итератор, представляющий элемент, который находится после последнего элемента в контейнере.
Наконец, все контейнеры предоставляют (как минимум) два типа итераторов:
container::iterator — итератор для чтения/записи;
container::const_iterator — итератор только для чтения.
Рассмотрим пример использования итераторов для вектора.
Заполним вектор пятью числами и, с помощью итераторов, выведем значения вектора:
#include <iostream>
#include <vector>
using namespace std;

int main()
{
    vector<int> myVector;
    for (int count=0; count < 5; ++count)
        myVector.push_back(count);

    vector<int>::const_iterator it; // объявляем итератор только для чтения
    it = myVector.begin(); // присваиваем ему начало вектора
    while (it != myVector.end()) // пока итератор не достигнет конца
    {
        cout << *it << " "; // выводим значение элемента, на который указывает итератор
        ++it; // и переходим к следующему элементу
    }
    cout << '\n';
}

Результат выполнения программы выше:
0 1 2 3 4

Создание контейнерного класса
Создадим контейнерный класс-массив, который будет реализовывать функциональность векторов. Но наш класс-массив будет только целочисленным.
Создадим файл ArrayInt.h и в нем объявим класс ArrayInt. В этом классе будет две переменные — данные массива (реализовано через указатель) и длина массива. Создадим два конструктора: один для пустого массива, другой для массива с заданной длиной и значениями. Также потребуется деструктор, который выполняет очистку памяти.
#ifndef ARRAYINT_H
#define ARRAYINT_H

#include <cassert> // для assert()

class ArrayInt
{
private:
    int m_length;
    int *m_data;

public:
    ArrayInt(): m_length(0), m_data(nullptr)
    { }

    ArrayInt(int length):
    m_length(length)
    {
        assert(length >= 0);

        if (length > 0)
            m_data = new int[length];
        else
            m_data = nullptr;
    }

    ~ArrayInt()
    {
        delete[] m_data;
    }
};

#endif


Теперь напишем функцию erase(), которая будет выполнять очитку массива и сбрасывать его длину на 0 (аналог функции clear() в векторах) и функцию для возврата длины массива (аналог size()):
    void erase()
    {
        delete[] m_data;

        // Здесь нам нужно указать m_data значение nullptr, чтобы на выходе не было висячего указателя
        m_data = nullptr;
        m_length = 0;
    }
    int getLength() { return m_length; }


Перегрузим оператор индексации [], чтобы иметь доступ к элементам массива:
        int& operator[](int index)
    {
        assert(index >= 0 && index < m_length);
        return m_data[index];
    }

Перегрузка осуществляется через метод класса. Функция перегрузки оператора [] всегда будет принимать один параметр: значение индекса. В случае с IntArray нужно, чтобы пользователь просто указал в квадратных скобках индекс для возврата значения элемента по нему. Обратите внимание, что оператор индексации использует возврат по ссылке. Если мы захотим изменить значение элемента массива, то выражение array[k] (где k — номер элемента массива) будет стоять слева от оператора присваивания =. Это означает, что array[k] должно быть l-value (переменной с адресом памяти). Поэтому перегруженная функция должна возвращать ссылку на элемент, а не просто его значение.

Напишем функцию, которая реализует возможность изменять размер массива (аналог resize()):
    // Функция resize изменяет размер массива. Все существующие элементы сохраняются. Процесс медленный
    void resize(int newLength)
    {
        // Если массив уже нужной длины — return
        if (newLength == m_length)
            return;

        // Если нужно сделать массив пустым — делаем это и затем return
        if (newLength <= 0)
        {
            erase();
            return;
        }

        // Теперь знаем, что newLength >0
        // Выделяем новый массив
        int *data = new int[newLength];

        // Затем нужно разобраться с количеством копируемых элементов в новый массив
        // Нужно скопировать столько элементов, сколько их есть в меньшем из массивов
        if (m_length > 0)
        {
            int elementsToCopy = (newLength > m_length) ? m_length : newLength;

            // Поочередно копируем элементы
            for (int index=0; index < elementsToCopy ; ++index)
                data[index] = m_data[index];
        }

        // Удаляем старый массив, так как он нам уже не нужен
        delete[] m_data;

        // И используем вместо старого массива новый! Обратите внимание, m_data указывает
        // на тот же адрес, на который указывает наш новый динамически выделенный массив. Поскольку
        // данные были динамически выделенные — они не будут уничтожены, когда выйдут из области видимости
        m_data = data;
        m_length = newLength;
    }


Напишем функцию insertBefore() для добавления нового элемента в массив (в реализации эта функция очень похожа на resize()):
    void insertBefore(int value, int index)
    {
        // Проверка корректности передаваемого индекса
        assert(index >= 0 && index <= m_length);

        // Создаем новый массив на один элемент больше старого массива
        int *data = new int[m_length+1];

        // Копируем все элементы до index-а
        for (int before=0; before < index; ++before)
            data[before] = m_data[before];

        // Вставляем новый элемент в новый массив
        data [index] = value;

        // Копируем все значения после вставляемого элемента
        for (int after=index; after < m_length; ++after)
            data[after+1] = m_data[after];

        // Удаляем старый массив и используем вместо него новый
        delete[] m_data;
        m_data = data;
        ++m_length;
    }


Теперь легко реализовать аналог функции push_back() в векторах:
void push_back(int value) { insertBefore(value, m_length); }

Динамическое приведение типов
В C++ есть 5 типов cast:
C-style_cast,
static_cast,
const_cast,
dynamic_cast
reinterpret_cast.
Сейчас рассмотрим dynamic_cast.
Применяя полиморфизм на практике, вы часто будете сталкиваться с ситуациями, когда у вас есть указатель на родительский класс, но нужно получить доступ к данным, которые есть только в дочернем.

#include <iostream>
#include <string>
using namespace std;
class Parent
{
protected:
    string m_name;

public:
    Parent(string name) : m_name(name)
    { }
    virtual ~Parent() {}
};

class Child: public Parent
{
protected:
     string m_ patronymic;

public:
    Child(string name, string patronymic) :
    Parent(name), m_ patronymic (patronymic)
    { }
    const string& getName() { return m_name; }
};

Parent* Create()
{
        return new Child("Alex", "Mike");
}

int main()
{
    Parent *p = Create();

    // как мы выведем имя объекта класса Child здесь, имея лишь один указатель класса Parent?

    delete p;
    return 0;
}



В этой программе функция Create() всегда возвращает указатель класса Parent, но он может указывать либо на объект класса Parent, либо на объект класса Child — в этом случае будем вызывать Child::getName()?
Один из способов — добавить виртуальную функцию getName() в класс Parent. Но, используя этот вариант, будем загрязнять класс Parent тем, что должно быть заботой только класса Child.
C++ позволяет неявно преобразовать указатель класса Child в указатель класса Parent — фактически, это и делает Create(). Эта конвертация называется приведением к базовому типу, или повышающим приведением типа. Но как конвертировать указатель класса Parent обратно в указатель класса Child?
В C++ оператор dynamic_cast используется именно для этого. Хотя динамическое приведение позволяет выполнять не только конвертацию указателей родительского класса в указатели дочернего класса, это наиболее распространенное применение dynamic_cast. Этот процесс называется приведением к дочернему типу, или понижающим приведением типа. Вот пример его использования:
int main()
{
    Parent *p = Create();
    // используем dynamic_cast для конвертации указателя класса Parent в указатель класса Child
    Child *ch = dynamic_cast<Child*>(p);

    cout << "The name of the Child is: " << ch->getName() << '\n';
    delete p;
    return 0;
}

Пример выше работает только из-за того, что указатель p на самом деле указывает на объект класса Child, поэтому конвертация успешна. Если бы он изначально указывал на объект класса Parent, то конвертация была бы невозможна и dynamic_cast вернул бы нулевой указатель. Именно поэтому после использования dynamic_cast необходимо выполнять проверку на нулевой указатель.
Также обратите внимание на случаи, в которых понижающее приведение с использованием dynamic_cast не работает:
Наследование типа private или protected.
Классы, которые не объявляют или не наследуют классы с какими-либо виртуальными функциями. Если бы в примере выше мы удалили виртуальный деструктор класса Parent, то преобразование через dynamic_cast не выполнилось бы.
Хотя в последнем примере мы использовали динамическое приведение с указателем (наиболее распространенная практика), dynamic_cast также может использоваться и со ссылками. Поскольку в C++ не существует «нулевой ссылки», то dynamic_cast не может вернуть «нулевую ссылку» при сбое. Вместо этого dynamic_cast генерирует исключение типа std::bad_cast (об исключениях — в следующем уроке).
В общем, лучше использовать виртуальные функции, чем понижающее приведение. Кроме ряда случаев, когда понижающее приведение предпочтительнее:
Если вы не можете изменить родительский класс, чтобы добавить в него свою виртуальную функцию (например, если он является частью стандартной библиотеки С++). При этом, чтобы использовать понижающее приведение, в родительском классе должны уже присутствовать виртуальные функции.
Если вам нужен доступ к чему-либо, что есть только в дочернем классе — например, к функции доступа.
Если добавление виртуальной функции в родительский класс не имеет смысла. Если при этом вам не нужно создавать объект родительского класса, можете использовать чистую виртуальную функцию.
Написание игры Blackjack
В прошлый раз мы создали иерархию классов игры Blackjack. В данном уроке рассмотрим функциональность каждого класса, а также напишем функцию main().
Класс Card
Член класса
Описание
rank m_Rank
Значение карты (туз, двойка, тройка и так долее). rank — это перечисление, куда входят все 13 значений
suit m_Suit
Масть карты (трефы, бубны, червы и пики). suit — это перечисление, содержащее четыре возможные масти
bool m_IsFaceUp
Указывает, как расположена карта — вверх лицом или рубашкой. Влияет на то, отображается она или нет
int GetValue()
Возвращает значение карты
void Flip()
Переворачивает карту. Может использоваться для того, чтобы перевернуть карту лицом вверх или вниз


Класс Hand
Член класса
Описание
vector<Card*> m_Cards
Коллекция карт. Хранит указатели на объекты типа Сard
void Add(Card* pCard)
Добавляет карту в руку. Добавляет указатель на объект типа Сard в вектор m_Сards
void Clear()
Очищает руку от карт. Удаляет все указатели из вектора m_Сards, устраняя все связанные с ними объекты в куче
int GetTotal()
Возвращает сумму очков карт руки


Класс GenericPlayer
Член класса
Описание
string m_Name
Имя игрока
virtual bool IsHitting() const = 0
Указывает, нужна ли игроку еще одна карта. Чистая виртуальная функция
bool IsBoosted() const
Указывает, что у игрока перебор
void Bust() const
Объявляет, что у игрока перебор



Класс Player:
Член класса
Описание
virtual bool IsHitting() const
Указывает, нужна ли игроку еще одна карта
void Win() const
Объявляет, что игрок выиграл
void Lose() const
Объявляет, что игрок проиграл
void Push() const
Объявляет, что игрок сыграл вничью


Класс House
Член класса
Описание
virtual bool IsHitting() const
Указывает, нужна ли игроку еще одна карта
void FlipFirstCard()
Переворачивает первую карту


Класс Deck
Член класса
Описание
vold Populate()
Создает стандартную колоду из 52 карт
void Shuffle()
Тасует карты
vold Deal (Hand& aHand)
Раздает в руку одну карту
void AddltionalCards (GenericPlayer& aGenerlcPlayer)
Раздает игроку дополнительные карты до тех пор, пока он может и хочет их получать


Класс Game:
Член класса
Описание
Deck m_Deck
Колода карт
House m_House
Рука дилера
vector<Player> m_Players
Группа игроков-людей. Вектор, содержащий объекты типа Player
void Play()
Проводит кон игры Blackjack


В функции main() пользователь должен будет ввести количество игроков и их имена. После этого начнется игровой цикл: создание объекта класса Game и вызов метода play(). Вот реализация функции main():
#include <vector>
using namespace std;
int main()
{
    cout << "\t\tWelcome to Blackjack!\n\n";

    int numPlayers = 0;
    while (numPlayers < 1 || numPlayers > 7)
    {
        cout << "How many players? (1 - 7): ";
        cin >> numPlayers;
    }

    vector<string> names;
    string name;
    for (int i = 0; i < numPlayers; ++i)
    {
        cout << "Enter player name: ";
        cin >> name;
        names.push_back(name);
    }
    cout << endl;

    // игровой цикл
    Game aGame(names);
    char again = 'y';
    while (again != 'n' && again != 'N')
    {
        aGame.Play();
        cout << "\nDo you want to play again? (Y/N): ";
        cin >> again;
    }

    return 0;
}


В функции main() имена игроков помещаются в вектор, поскольку мы не знаем заранее, сколько человек будет играть. Этот вектор передается в качестве параметра конструктору класса Game.
Практические задания
Добавить в контейнерный класс, который был написан в этом уроке, методы:
для удаления последнего элемента массива (аналог функции pop_back() в векторах)
для удаления первого элемента массива (аналог pop_front() в векторах)
для сортировки массива
для вывода на экран элементов.
Дан вектор чисел, требуется выяснить, сколько среди них различных. Постараться использовать максимально быстрый алгоритм.
Реализовать класс Hand, который представляет собой коллекцию карт. В классе будет одно поле: вектор указателей карт (удобно использовать вектор, т.к. это по сути динамический массив, а тип его элементов должен быть - указатель на объекты класса Card). Также в классе Hand должно быть 3 метода:
метод Add, который добавляет в коллекцию карт новую карту, соответственно он принимает в качестве параметра указатель на новую карту
метод Clear, который очищает руку от карт
метод GetValue, который возвращает сумму очков карт руки (здесь предусмотреть возможность того, что туз может быть равен 11).

Дополнительные материалы
Бьерн Страуструп. Программирование. Принципы и практика использования С++.
Стивен Прата. Язык программирования С++. Лекции и упражнения.
Роберт Лафоре. Объектно-ориентированное программирование в С++.
Используемая литература
Для подготовки данного методического пособия были использованы следующие ресурсы:
Объектно-ориентированный анализ и проектирование с примерами приложений на С++. Отношения между классами.
Бьерн Страуструп. Программирование. Принципы и практика использования С++.
Ральф Джонсон, Ричард Хелм, Эрих Гамма. Приемы объектно-ориентированного программирования. Паттерны проектирования.

*/


// УРОК №5
//--------



/*
Совместное использование функций и методов
Перегрузка операторов. Шаблоны функций и классов. Явная и частичная специализация шаблонов. Примеры простых программ.

Перегрузка операторов инкремента и декремента
Перегрузка операторов инкремента и декремента версии постфикс
Шаблоны функций
Шаблоны классов
Параметр non-type шаблона
Явная специализация шаблона функции
Явная специализация шаблона класса
Частичная специализация шаблона
Частичная специализация шаблонов и указатели
Написание игры Blackjack
Практическое задание
Дополнительные материалы
Используемая литература
Перегрузка операторов инкремента и декремента
Перегрузка операторов инкремента (++) и декремента (−−) довольно проста, но есть нюанс. Есть две версии операторов инкремента и декремента: префикс (++x, --y) и постфикс (x++, y--).
Поскольку операторы инкремента и декремента являются унарными и изменяют свои операнды, то перегрузку следует выполнять через методы класса.
Перегрузка операторов инкремента и декремента версии префикс.
#include <iostream>
using namespace std;

class Day
{
private:
    int m_day;
public:
    Day(int day=1) : m_day(day)
    { }
    Day& operator++();
    Day& operator--();
    void getDay() { cout << m_day << endl;}
};

Day& Day::operator++()
{
    // Если значением переменной m_day является 32, то выполняем сброс на 1
    if (m_day == 32)
        m_day = 1;
    // в противном случае просто увеличиваем m_day на единицу
    else
        ++m_day;

    return *this;
}

Day& Day::operator--()
{
    // Если значением переменной m_day является 0, то присваиваем m_day значение 31
    if (m_day == 0)
        m_day = 8;
    // в противном случае просто уменьшаем m_day на единицу
    else
        --m_day;
    return *this;
}

int main()
{
    Number number(8);
    number.getNumber();
    (++number).getNumber();
    (--number).getNumber();
    return 0;
}
Day& Day::operator--()
{
    // Если значением переменной m_day является 0, то присваиваем m_day значение 31
    if (m_day == 0)
        m_day = 31;
    // в противном случае просто уменьшаем m_day на единицу
    else
        --m_day;
    return *this;
}

int main()
{
    Day day(31);
    day.getDay();
    (++day).getDay();
    (--day).getDay();
    return 0;
}

Результат выполнения программы:
31
1
31
Здесь класс Day содержит число от 1 до 31. Мы перегрузили операторы инкремента/декремента таким образом, чтобы они увеличивали/уменьшали m_day в соответствии с заданным диапазоном.
Обратите внимание, мы возвращаем скрытый указатель *this в функциях перегрузки операторов (то есть текущий объект класса Day). Таким образом мы можем связать выполнение нескольких операторов в одну «цепочку».
Перегрузка операторов инкремента и декремента версии постфикс
Операторы инкремента и декремента версии префикс и постфикс имеют одно имя, оба унарные и принимают один параметр одного и того же типа данных. Как же их различать при перегрузке?
C++ использует фиктивную переменную или фиктивный параметр для операторов версии постфикс. Этот фиктивный целочисленный параметр используется с одной целью: отличить версию постфикс операторов инкремента/декремента от версии префикс. Перегрузим префиксную и постфиксную версию операторов инкремента/декремента в том же классе:
#include <iostream>
using namespace std;

class Day
{
private:
    int m_day;
public:
    Day(int day=1) : m_day (day)
    { }

    Day& operator++();   // версия префикс
    Day & operator--();  // версия префикс

    Day operator++(int); // версия постфикс
    Day operator--(int); // версия постфикс

    void getDay() { cout << m_day << endl;}
};

//префиксная версия инкремента
Day & Day::operator++()
{
    if (m_day == 32)
        m_day = 1;
    else
        ++m_day;

    return *this;
}

//префиксная версия декремента
Day & Day::operator--()
{
    if (m_number == 0)
        m_number = 31;
    else
        --m_number;

    return *this;
}

// постфиксная версия инкремента
Day Day::operator++(int)
{
    // Создаем временный объект класса Day с текущим значением переменной m_day
    Day temp(m_day);

    // Используем оператор инкремента версии префикс для реализации перегрузки оператора инкремента версии постфикс
    ++(*this); // реализация перегрузки

    // возвращаем временный объект
    return temp;
}

// постфиксная версия декремента
Day Day::operator--(int)
{
    // Создаем временный объект класса Day с текущим значением переменной m_day
    Day temp(m_day);

    // Используем оператор декремента версии префикс для реализации перегрузки оператора декремента версии постфикс
    --(*this); // реализация перегрузки

    // возвращаем временный объект
    return temp;
}

int main()
{
    Day day(31);

    (day++).getDay();
    (day).getDay();
    (day--).getDay();
    (day).getDay();

    return 0;
}



Результат выполнения программы:
31
1
1
31
В данном коде:
Отделили версию постфикс от версии префикс, используя целочисленый фиктивный параметр в версии постфикс.
Поскольку фиктивный параметр не используется в реализации самой перегрузки, то мы даже не даем ему имя. Так что компилятор будет рассматривать эту переменную как простую заглушку (заполнитель места) и даже не будет предупреждать нас, что мы объявили переменную, но никогда ее не использовали.
Операторы версий префикс и постфикс выполняют одно задание — оба увеличивают/уменьшают значение переменной объекта. Разница между ними только в значении, которое они возвращают. Операторы версии префикс возвращают объект после того, как он был увеличен или уменьшен. В версии постфикс нам нужно возвращать объект до того, как он будет увеличен или уменьшен.
Поэтому мы использовали временный объект с текущим значением переменной-члена. Тогда можно будет увеличить/уменьшить исходный объект, а возвратить обратно временный.
Обратите внимание: это означает, что возврат значения по ссылке невозможен, так как мы не можем возвратить ссылку на локальную переменную, которая будет уничтожена после завершения выполнения тела функции. Также это означает, что операторы версии постфикс обычно менее эффективны, чем операторы версии префикс — из-за дополнительных расходов ресурсов на создание временного объекта и выполнения возврата по значению вместо возврата по ссылке
Наконец, мы реализовали перегрузку операторов версии постфикс через уже перегруженные операторы версии префикс. Таким образом сократили дублированный код и упростили внесение будущих изменений в класс, то есть поддержку кода.
Шаблоны функций
Шаблоны функций — это инструкции, согласно которым создаются локальные версии функции для определенного набора параметров и типов данных. Это мощный инструмент в С++, который упрощает разработку.
Например, нам нужно запрограммировать функцию, которая выводила бы на экран элементы массива. Задача несложная, но чтобы написать такую функцию, надо знать тип данных массива, который будем выводить на экран. А если тип данных не один? Мы хотим, чтобы функция выводила массивы типа int, double, float и char. Можно, конечно, перегрузить функцию, но тогда появится 4 версии одной функции, только с другими типами параметра. Есть способ решить эту проблему проще — использовать шаблоны.
Создадим шаблон функции, определяющий максимальное из двух чисел:
template <typename T>
T max(T a, T b)
{
    return (a > b) ? a : b;
}


Для объявления шаблона функции сначала пишется ключевое слово template, которое сообщает компилятору, что дальше мы будем объявлять параметры шаблона. Они указываются в угловых скобках (<>). Для создания типов параметров шаблона используются ключевые слова typename и class. В базовых случаях использования шаблонов функций разницы между typename и class нет, поэтому можете выбрать любое. Если используете ключевое слово class, то фактический тип параметров не обязательно должен быть классом. Затем называем тип параметра шаблона (обычно «T», сокращенно от Type, что говорит о том, что это может быть любой тип данных). Если требуется несколько типов параметров шаблона, то они разделяются запятыми: template <typename T1, typename T2>.
Поскольку тип аргумента функции, передаваемый в тип T, может быть классом, а классы, как правило, не рекомендуется передавать по значению, то лучше сделать параметры и возвращаемое значение нашего шаблона функции константными ссылками. Тогда предыдущая функция перепишется следующим образом:
#include <iostream>
using namespace std;

template <typename T>
const T& t_max(const T& a, const T& b)
{
    return (a > b) ? a : b;
}


Использовать шаблоны функций можно так же, как и обычные функции:
int main()
{
    int i = t_max(4, 8);
    cout << i << '\n';

    double d = t_max(7.56, 21.434);
    cout << d << '\n';

    char ch = t_max('b', '9');
    cout << ch << '\n';

    return 0;
}

Результат выполнения программы:
8
21.434
B
Поскольку все три вызова функции t_max() имеют параметры разных типов, то компилятор создаст 3 экземпляра шаблона функции для каждого типа данных. Шаблоны функций работают как с фундаментальными типами данных (char, int, double и другими), так и с классами. Экземпляр шаблона компилируется как обычная функция. В обычной функции любые операторы или вызовы других функций, которые используются в ней, должны быть определены/перегружены — иначе вы получите ошибку компиляции. Аналогично, любые операторы или вызовы других функций, которые присутствуют в шаблоне функции, должны быть определены/перегружены для работы с передаваемыми типами данных.

Рассмотрим пример:
#include <iostream>
using namespace std;

template <typename T>
const T& t_max(const T& a, const T& b)
{
    return (a > b) ? a : b;
}

class Day
{
private:
    int m_day;
public:
    Day(int day) : m_day(day)
    { }
    // перегружаем оператор >
    friend bool operator>(const Day &d1, const Day &d2)
    {
        return (d1.m_day > d2.m_day);
    }
};
int main()
{
    Day seven(7);
    Day twelve(12);

    Day bigger = t_max(seven, twelve);

    return 0;
}


Чтобы использовать шаблон функции, необходимо перегрузить оператор сравнения для класса Dollars. После перегрузки можем спокойно использовать шаблон функции.
Обратите внимание: стандартная библиотека C++ имеет в своем арсенале шаблон функции max(), который находится в заголовочном файле algorithm. Поэтому вы можете не реализовывать эту функцию вручную в будущем. Данный шаблон функции находится в стандартном пространстве имен (namespace std;) — именно поэтому мы создали функцию t_max(), а не просто max().
Шаблоны классов
На предыдущем уроке мы создавали динамический массив-класс целых чисел. Чтобы реализовать такой класс для вещественных чисел типа float или double, идеальным решением будет добавить шаблон класса.
template <class T> // шаблон класса
class Array
{
private:
    int m_length;
    T *m_data;

public:
    Array()
    {
        m_length = 0;
        m_data = nullptr;
    }

    Array(int length)
    {
        m_data = new T[length];
        m_length = length;
    }

    ~Array()
    {
        delete[] m_data;
    }

    void Erase()
    {
        delete[] m_data;
        // Указываем m_data значение nullptr, чтобы на выходе не получить висячий указатель!
        m_data = nullptr;
        m_length = 0;
    }


    T& operator[](int index)
    {
        assert(index >= 0 && index < m_length);
        return m_data[index];
    }

    int getLength(); // определяем метод и шаблон метода getLength() ниже
};

// метод, определенный вне тела класса, нуждается в собственном определении шаблона метода
template <typename T>
int Array<T>::getLength() { return m_length; }
// обратите внимание, имя класса - Array<T>, а не просто Array


Эта версия почти идентична версии ArrayInt, за исключением того, что мы добавили объявление параметра шаблона класса и изменили тип данных на T.
Обратите внимание: мы определили функцию getLength() вне тела класса. Это необязательно, просто привели для примера — так как каждый метод шаблона класса, объявленный вне тела класса, нуждается в собственном объявлении шаблона. Имя шаблона класса — Array<T>.
Создавать экземпляры шаблона класса нужно таким образом:
Array<int> intArray(10);
Array<double> doubleArray(10);
Шаблоны классов работают так же, как и шаблоны функций: компилятор копирует шаблон класса, заменяя типы параметров шаблона класса на фактические (передаваемые) типы данных, а затем компилирует эту копию. Если у вас есть шаблон класса, но вы его не используете, то компилятор не будет его даже компилировать.
Шаблоны классов идеально подходят для реализации контейнерных классов, так как очень часто таким классам приходится работать с разными типами данных, а шаблоны позволяют это организовать в минимальном количестве кода. Рассмотренный на прошлом уроке std::vector — это шаблон класса. В стандартной библиотеке С++ много предопределенных шаблонов классов, доступных для использования.
Параметр non-type шаблона
Параметр non-type шаблона — это специальный параметр шаблона, который заменяется не типом данных, а конкретным значением. Этим значением может быть:
целочисленное значение или перечисление;
указатель или ссылка на объект класса;
указатель или ссылка на функцию;
указатель или ссылка на метод класса.
Например, для создания статического массива-класса необходим еще один параметр — длина массива. Этот параметр передается в шаблон класса:
template <class T, int size> // size является параметром non-type шаблона класса
class StaticArray
{
private:
    // параметр non-type шаблона класса отвечает за размер выделяемого массива
    T m_array[size];
    ...
}

Экземпляр класса будет создаваться следующим выражением:
StaticArray<int, 10>.
Данный класс известен из стандартной библиотеки С++ - std::array.
Явная специализация шаблона функции
При создании экземпляра шаблона функции для определенного типа данных компилятор копирует шаблон функции и заменяет параметр типа шаблона функции на передаваемый тип данных. Это означает, что все экземпляры функции имеют одну реализацию, но разные типы данных. Хотя в большинстве случаев это именно то, что требуется, иногда может понадобиться, чтобы реализация шаблона функции для одного типа данных отличалась от реализации для другого.
Специализация шаблонов именно для этого и предназначена.
Рассмотрим следующий шаблон класса:
#include <iostream>
using namespace std;

template <class T>
class Day
{
private:
    T m_day;
public:
    Day(T day)
    {
        m_day = day;
    }

    ~Day()
    { }

    void print()
    {
        cout << m_day << '\n';
    }
};


Теоретически данный класс может работать со многими типами данных (хотя этого может и не требоваться). Но что, если мы попытаемся использовать шаблон класса с типом данных char*? При создании экземпляра шаблона для типа char*, конструктор Day<char*> присвоит переменной m_day указатель day. Тогда функция print() выведет на экран значение указателя, а не сам текст. Чтобы решить эту проблему, используем явную специализацию шаблона класса:
template <>
Day<char*>::Day(char* day)
{
    // Определяем длину day
    int length=0;
    while (day[length] != '\0')
        ++length;
    ++length; // +1, учитывая нуль-терминатор

    // Выделяем память для хранения значения day
    m_day = new char[length];

    // Копируем фактическое значение day в m_day
    for (int count=0; count < length; ++count)
        m_day[count] = day[count];
}

template <>
Repository<char*>::~Repository()
{
    delete[] m_day;
}


Теперь при выделении переменной типа Day<char*> именно этот конструктор будет использоваться вместо стандартного. Чтобы избежать утечки памяти для типа char* используем деструктор, поскольку m_day не будет удален, когда переменная day выйдет из области видимости. Теперь, когда переменные типа Day<char*> выйдут из области видимости, память, выделенная в специальном конструкторе, будет удалена в специальном деструкторе.
Хотя во всех примерах выше мы работаем с методами класса, вы также можете аналогично выполнять явную специализацию шаблонов обычных функций.
Явная специализация шаблона класса
Специализация шаблона класса позволяет специализировать шаблон класса для работы с определенным типом данных (или сразу несколькими, если описано несколько параметров шаблона).
Специализация шаблона класса рассматривается компилятором как полностью отдельный и независимый класс, хотя и выделяется как обычный шаблон класса. Это означает, что мы можем изменить в классе что угодно, включая его реализацию, методы, спецификаторы доступа.
Рассмотрим класс-массив, который может хранить 8 дней:
template <class T>
class Day
{
private:
    T m_day[8];

public:
    void set(int index, const T &day)
    {
        m_day[index] = day;
    }

    const T& get(int index)
    {
        return m_day[index];
    }
};


Существуют классы, в которых переменная-член имеет тип данных bool. Для него эффективнее реализовать хранение переменных не в массиве (на что будет потрачено 8 байт), а в переменной типа unsigned char. Тогда на каждое значение bool-переменной будет уходить только по одному биту. В связи с вышесказанным потребуется отдельная специализация для типа данных bool.
Частичная специализация шаблона
Частичная специализация шаблона позволяет выполнить специализацию шаблона класса (но не функции), где некоторые параметры шаблона явно определены. Это называется частичной специализацией, потому что специализация шаблона происходит не по всем аргументам. Рассмотрим шаблон класса и его частичную специализацию:
// шаблон класса
template< typename T, typename S > class B {};
// его частичная специализация
template< typename U > class B< int, U > {};


В данном примере шаблонный класс с двумя параметрами специализируется только по одному из них. Специализация будет работать, когда первый аргумент, T, будет указан как int. При этом второй аргумент может быть любым — для этого в частичной специализации введен новый параметр U и указан в списке аргументов для специализации.
Чтобы выполнить частичную специализацию метода класса, можно сделать частичную специализация шаблона всего класса:
template <class T, int size>
class StaticArray
{
// реализация класса StaticArray
};

// частичная специализация шаблона класса
template <int size>
class StaticArray<double, size>
{
// реализация частично специализированного шаблона класса
};


Но в данном случае частично специализированный шаблон класса будет во многом дублировать код основного шаблона класса. Это проблема, которую можно решить путем наследования. Для это необходимо создать общий родительский класс:
// шаблон базового класса
template <class T, int size>
class StaticArray_Base
{
// реализация класса StaticArray_Base
};

// шаблон производного класса
template <class T, int size>
class StaticArray: public StaticArray_Base<T, size>
{
// полностью наследует функционал StaticArray_Base,
// собственные методы не нужны
};

// частично специализированный шаблон класса для типа double
template <int size>
class StaticArray<double, size>: public StaticArray_Base<double, size>
{
// реализация частично специализированного шаблона класса
};

В данном примере дублирование кода не происходит, а функционал остается прежним.
Отметим, что частичная специализация шаблонов нашла свое применение в основном при создании библиотек: stl, boost, loki и других. В библиотеках частичная специализация позволяет относительно просто реализовывать делегаты, события, сложные контейнеры и другие нужные и полезные вещи.
Частичная специализация шаблонов и указатели
В предыдущей части урока мы рассматривали пример с шаблоном класса Day и создавали полную специализацию этого шаблона для указателя типа char*. Но что, если потребуется использовать указатели и на другие типы — например, int*? Если не написать полную специализацию шаблона и для других типов указателей, программа не будет работать правильно, но получится много дублирующего кода. Выход из этой ситуации — объявить частичную специализацию шаблона класса Day, которая работала бы со всеми типами указателей.
#include <iostream>
using namespace std;

// Общий шаблон класса Day
template <class T>
class Day
{
private:
    T m_day;
public:
    Day(T day)
    {
        m_day = day;
    }

    ~Day()
    { }

    void print()
    {
        cout << m_day << '\n';
    }
};

// частичная специализация шаблона класса Day для работы с типами указателей
template <typename T>
class Day<T*>
{
private:
    T* m_day;
public:
    Day(T* day) // T - тип указателя
    {
        // Выполняем глубокое копирование
        m_day = new T(*day); // здесь копируется только одно отдельное значение
    }
    ~Day()
    {
        delete m_day; // а здесь выполняется удаление этого значения
    }

    void print()
    {
        cout << *m_day << '\n';
    }
};


Поскольку в нашей частичной специализации копируется только одно значение, то при работе со строками C-style копироваться будет только первый символ (так как строка — это массив, а указатель на массив указывает только на первый его элемент). Если же нужно скопировать целую строку, то специализация конструктора (и деструктора) для типа char* должна быть полной. В таком случае полная специализация будет иметь приоритет выше, чем частичная. Рассмотрим программу, в которой используется как частичная специализация для работы с типами указателей, так и полная специализация для работы с типом char*:
#include <iostream>
#include <cstring>
using namespace std;
// Общий шаблон класса Day для работы не с указателями
template <class T>
class Day
{
private:
    T m_day;
public:
    Repository(T day)
    {
        m_day = day;
    }

    ~Day()
    { }

    void print()
    {
        cout << m_day << '\n';
    }
};

// Частичная специализация шаблона класса Day для работы с указателями
template <class T>
class Day<T*>
{
private:
    T* m_day;
public:
    Day(T* day)
    {
        m_day = new T(*day);
    }

    ~Day ()
    {
        delete m_day;
    }

    void print()
    {
        cout << *m_day << '\n';
    }
};
}
// Полная специализация шаблона конструктора класса Day для работы с типом char*
template <>
Day<char*>::Day(char* day)
{
    // Определяем длину day
    int length = 0;
    while (day[length] != '\0')
        ++length;
    ++length; // +1, учитывая нуль-терминатор

    // Выделяем память для хранения значения day
    m_day = new char[length];



    // Копируем фактическое значение day в m_day
    for (int count = 0; count < length; ++count)
        m_day[count] = day[count];
}

// Полная специализация шаблона деструктора класса Day для работы с типом char*
template<>
/day<char*>::~Day()
{
    delete[] m_day;
}

// Полная специализация шаблона метода print для работы с типом char*
// Без этого вывод Day<char*> привел бы к вызову Day<T*>::print(), которое выводит только одно значение (в случае со строкой C-style - только первый символ)
template<>
void Day<char*>::print()
{
    cout << m_day;
}

int main()
{
    // Объявляем целочисленный объект для проверки работы общего шаблона класса
    Day<int> myDay(6);
    myDay.print();

    // Объявляем объект с типом указателя для проверки работы частичной специализации шаблона
    int x = 8;
    Dy<int*> myintptr(&x);

    // Если бы в myintptr выполнилось поверхностное копирование (присваивание указателя),
    // то изменение значения x изменило бы и значение myintptr
    x = 10;
    myintptr.print();

    // Динамически выделяем временную строку
    char *day = new char[40]{ "First" };

    // Сохраняем число
    Day<char*> myDay(day);

    // Удаляем временную строку
    delete[] name;

    // Выводим имя
    myname.print();
}
    // Удаляем временную строку
    delete[] day;

    // Выводим имя
    myDay.print();
}


Результат выполнения программы:
6
8
First
Таким образом, использование частичной специализации шаблона класса для работы с типами указателей особенно полезно, так как позволяет предусмотреть все возможные варианты использования программы на практике.
Написание игры Blackjack
На этом уроке создадим карту и колоду карт. Предлагаем масти карт и их достоинства оформить в виде перечисления, чтобы легче с ними работать:
enum rank {
        ACE = 1, TWO, THREE, FOUR, FIVE, SIX, SEVEN, EIGHT, NINE, TEN,
        JACK, QUEEN, KING
    };
enum suit { CLUBS, DIAMONDS, HEARTS, SPADES };


У класса Card есть метод, который переворачивает карту. В программе это будет реализовано с помощью переменной типа bool, где значению false соответствует карта, перевернутая рубашкой вверх, а  значению true — рубашкой вниз.
void Card::Flip()
{
    m_IsFaceUp = !(m_IsFaceUp);
}


У класса Card также есть метод, который возвращает значение карты. Но оно доступно только в том случае, когда карта перевернута лицом вверх:
int Card::GetValue() const
{
    //если карта перевернута лицом вниз, ее значение равно О
    int value = 0;
    if (m_IsFaceUp)
    {
        // значение - это число, указанное на карте
        value = m_Rank;
        // значение равно 10 для JACK, QUEEN и KING
        if (value > 10)
        {
            value = 10;
        }
    }
    return value;
}


Класс Card:
class Card
{
public:
    enum rank {
        ACE = 1, TWO, THREE, FOUR, FIVE, SIX, SEVEN, EIGHT, NINE, TEN,
        JACK, QUEEN, KING
    };
    enum suit { CLUBS, DIAMONDS, HEARTS, SPADES };

    Card(rank r = ACE, suit s = SPADES, bool ifu = true);
    int GetValue() const;
    void Flip();

private:
    rank m_Rank;
    suit m_Suit;
    bool m_IsFaceUp;
};

Card::Card(rank r, suit s, bool ifu) : m_Rank(r), m_Suit(s), m_IsFaceUp(ifu)
{}

int Card::GetValue() const
{
    int value = 0;
    if (m_IsFaceUp)
    {
        value = m_Rank;
        if (value > 10)
        {
            value = 10;
        }
    }
    return value;
}

void Card::Flip()
{
    m_IsFaceUp = !(m_IsFaceUp);
}


Теперь займемся классом Hand. Этот класс представляет собой коллекцию карт. Его конструктор резервирует в векторе m_Cards место в памяти под 7 элементов. Метод Add() добавляет новую карту в вектор. А метод Clear() очищает всю память, занятую вектором.
class Hand
{
public:
    Hand();
    // виртуальный деструктор
    virtual ~Hand();

    // добавляет карту в руку
    void Add(Card* pCard);

    // очищает руку от карт
    void Clear();

    //получает сумму очков карт в руке, присваивая тузу
    // значение 1 или 11 в зависимости от ситуации
    int GetTotal() const;

protected:
    vector<Card*> m_Cards;
};

Hand::Hand()
{
    m_Cards.reserve(7);
}
// деструктор по-прежнему виртуальный
// это уже можно не обозначать
Hand::~Hand()
{
    Clear();
}

void Hand::Add(Card* pCard)
{
    m_Cards.push_back(pCard);
}

void Hand::Clear()
{
    // проходит по вектору, освобождая всю память в куче
    vector<Card*>::iterator iter = m_Cards.begin();
    for (iter = m_Cards.begin(); iter != m_Cards.end(); ++iter)
    {
        delete *iter;
        *iter = 0;
    }
    // очищает вектор указателей
    m_Cards.clear();
}

Метод Clear() удаляет не только все указатели из вектора m_Cards, но и связанные объекты типа Card и освобождает занятую ими память. Это работает так же, как в реальном мире, когда в конце кона карты сбрасываются. Виртуальный деструктор вызывает этот метод.
Обратите внимание: хотя деструктор виртуальный, ключевое слово virtual не используется за пределами класса, а только внутри его определения.

Теперь представим реализацию метода GetTotal():
int Hand::GetTotal() const
{
    // если карт в руке нет, возвращает значение 0
    if (m_Cards.empty())
    {
        return 0;
    }

    //если первая карта имеет значение 0, то она лежит рубашкой вверх:
    // вернуть значение 0
    if (m_Cards[0]->GetValue() == 0)
    {
        return 0;
    }

    // находит сумму очков всех карт, каждый туз дает 1 очко
    int total = 0;
    vector<Card*>::const_iterator iter;
    for (iter = m_Cards.begin(); iter != m_Cards.end(); ++iter)
    {
        total += (*iter)->GetValue();
    }

    // определяет, держит ли рука туз
    bool containsAce = false;
    for (iter = m_Cards.begin(); iter != m_Cards.end(); ++iter)
    {
        if ((*iter)->GetValue() == Card::ACE)
        {
            containsAce = true;
        }
    }

    // если рука держит туз и сумма довольно маленькая, туз дает 11 очков
    if (containsAce && total <= 11)
    {
        // добавляем только 10 очков, поскольку мы уже добавили
        // за каждый туз по одному очку
        total += 10;
    }

    return total;
}

Данный метод возвращает сумму очков для карт в руке. Если рука держит туз, он считается за 1 или 11 очков в зависимости от остальных карт. Количество очков, которое дает туз, определяется так: если в руке есть туз, он дает 11 очков; затем выполняется проверка, превышает ли сумма очков карт в руке число 21. Если нет — количество очков, которое дает туз, не изменяется. В противном случае туз даст 1 очко.
Практическое задание
Реализовать шаблон класса Pair1, который позволяет пользователю передавать данные одного типа парами.
Следующий код:
int main()
{
    Pair1<int> p1(6, 9);
    cout << "Pair: " << p1.first() << ' ' << p1.second() << '\n';

    const Pair1<double> p2(3.4, 7.8);
    cout << "Pair: " << p2.first() << ' ' << p2.second() << '\n';

    return 0;
}


… должен производить результат:
Pair: 6 9
Pair: 3.4 7.8
Реализовать класс Pair, который позволяет использовать разные типы данных в передаваемых парах.
Следующий код:
int main()
{
    Pair<int, double> p1(6, 7.8);
    cout << "Pair: " << p1.first() << ' ' << p1.second() << '\n';

    const Pair<double, int> p2(3.4, 5);
    cout << "Pair: " << p2.first() << ' ' << p2.second() << '\n';

    return 0;
}


… должен производить следующий результат:
Pair: 6 7.8
Pair: 3.4 5
Подсказка: чтобы определить шаблон с использованием двух разных типов, просто разделите параметры типа шаблона запятой.
Написать шаблон класса StringValuePair, в котором первое значение всегда типа string, а второе — любого типа. Этот шаблон класса должен наследовать частично специализированный класс Pair, в котором первый параметр — string, а второй — любого типа данных.

Следующий код:
int main()
{
    StringValuePair<int> svp("Amazing", 7);
    std::cout << "Pair: " << svp.first() << ' ' << svp.second() << '\n';
    return 0;
}


… должен производить следующий результат:
Pair: Amazing 7
Подсказка: при вызове конструктора класса Pair из конструктора класса StringValuePair не забудьте указать, что параметры относятся к классу Pair.

Согласно иерархии классов, которая представлена в методичке к уроку 3, от класса Hand наследует класс GenericPlayer, который обобщенно представляет игрока, ведь у нас будет два типа игроков - человек и компьютер. Создать класс GenericPlayer, в который добавить поле name - имя игрока. Также добавить 3 метода:
IsHitting() - чисто виртуальная функция, возвращает информацию, нужна ли игроку еще одна карта.
IsBoosted() - возвращает bool значение, есть ли у игрока перебор
Bust() - выводит на экран имя игрока и объявляет, что у него перебор.


Дополнительные материалы
Бьерн Страуструп. Программирование. Принципы и практика использования С++.
Стивен Прата. Язык программирования С++. Лекции и упражнения.
Роберт Лафоре. Объектно-ориентированное программирование в С++.
Используемая литература
Для подготовки данного методического пособия были использованы следующие ресурсы:
Онлайн-справочник программиста на C и C++. Перегрузка.
Бьерн Страуструп. Программирование. Принципы и практика использования С++.
Ральф Джонсон, Ричард Хелм, Эрих Гамма. Приемы объектно-ориентированного программирования. Паттерны проектирования.

*/


// УРОК №6
//--------



/*

*/


// УРОК №7
//--------



/*

*/



// УРОК №8
//--------



/*

*/

void Metoda()
{
    cout << "------------------" << endl;
    cout << "------------------" << endl;
    cout << "------------------" << endl;
    cout << "------------------" << endl;
    cout << "------------------" << endl;
    cout << "------------------" << endl;
}